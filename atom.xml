<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HengLin31</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://henglin31.github.io/"/>
  <updated>2020-04-19T11:04:10.000Z</updated>
  <id>https://henglin31.github.io/</id>
  
  <author>
    <name>Heng Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>關於 Java CompletableFuture 的用法</title>
    <link href="https://henglin31.github.io/2020/04/19/%E9%97%9C%E6%96%BC-Java-CompletableFuture-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://henglin31.github.io/2020/04/19/關於-Java-CompletableFuture-的用法/</id>
    <published>2020-04-19T06:07:24.000Z</published>
    <updated>2020-04-19T11:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>已經好久沒有進行更新<br>最近都在熟悉新工作，與過往不同的 domain knowledge ，融入貫通的過程中學習到滿多關於硬體的知識，目前已經進入狀況</p><p>剛好最近都在使用 CompleteableFuture 處理 thread 非同步的事件<br>來寫篇文章記錄一下用法，方便之後查詢使用</p><p>CompletableFuture 使用上很像 JS 的 Promise 和 Linux 的 pipeline ( commands )<br>CompletableFuture 用於串連不同的 thread ，某種程度將 thread 之間的相依性解耦<br>某個 thread 結果要串給另一個 thread 當作輸入條件，使用 CompletableFuture 可輕鬆綁定<br>所以在設計時只需定義好每個事件個自的 input 和 output ，不需要將關聯寫死</p><p>首先是最簡單的 <code>runAsync</code> 和 <code>supplyAsync</code> 的基礎用法，差別在於是否需要 return result<br>它們都可以搭配 thread pool 使用 ( 在實際應用場景都會根據實際需求自建 thread pool 使用，若沒設置則預設是使用 JVM 本身的 thread pool )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt;  <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt;     <span class="title">supplyAsync</span><span class="params">(Supplier&lt;T&gt; supplier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt;  <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt;     <span class="title">supplyAsync</span><span class="params">(Supplier&lt;T&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>提供自建的 thread pool 給 CompletableFuture 使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"runAsync"</span>), threadPool);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync"</span>, threadPool);</span><br></pre></td></tr></table></figure></p><hr><p>CompletableFuture 也允許在事件執行完成時 callback 取得結果，方便進行下一步的處理，而且在執行過程中發生 exception ，也可以攔截 exception 後執行特定的 action<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="comment">// catch exception</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>將剛剛的 <code>supplyAsync</code> 例子改寫為強制拋出 exception ，可在 <code>completeAsync</code> 或 <code>exceptionally</code> 處理異常，非常的方便<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(<span class="keyword">new</span> Exception(<span class="string">"throw exception"</span>));</span><br><span class="line">&#125;, threadPool);</span><br><span class="line"></span><br><span class="line">supplyAsync.whenCompleteAsync((result, ex) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + result);</span><br><span class="line">    System.out.println(<span class="string">"exception: "</span> + ex);</span><br><span class="line">&#125;, threadPool).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"exceptionally: "</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> ex.getMessage();</span><br><span class="line">&#125;).join();</span><br></pre></td></tr></table></figure></p><hr><p>除此之外 CompletableFuture 也提供 <code>handle</code> 來處理 exception ，差別在於 <code>handle</code> 是允許有返回值，用於串接過程中處理 exception<br><code>handle</code> 也用於做進一步的資料轉換</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>再次改寫 <code>supplyAsync</code> ，改為使用 <code>handle</code> 處理 exception ，此例子將 exception 轉換成字串當作一般的結果往後傳遞<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(<span class="keyword">new</span> Exception(<span class="string">"throw exception"</span>));</span><br><span class="line">&#125;, threadPool);</span><br><span class="line"></span><br><span class="line">String ans = supplyAsync.handle((result, ex) -&gt; (<span class="keyword">null</span> != ex) ? ex.getMessage() : result).join();</span><br><span class="line">System.out.println(<span class="string">"ans: "</span> + ans);</span><br></pre></td></tr></table></figure></p><hr><p>若是沒有處理 exception 的需求則可以使用 <code>thenApply</code> 進行資料的轉換，類似於 stream map 的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>還有對映 flatMap 的 <code>thenCompose</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>不需要返回值的 <code>thenAccept</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><hr><p>使用 <code>thenCombine</code> 還可以將兩個獨立的 CompletableFuture 執行結果進行整合，非常的強大<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? extends V&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>現在將 supplyAsync1 和 supplyAsync2 結果整合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 1"</span>, threadPool);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 2"</span>, threadPool);</span><br><span class="line"></span><br><span class="line">String ans = supplyAsync1.thenCombine(supplyAsync2, (result1, result2) -&gt; result1 + <span class="string">", "</span> + result2).join();</span><br><span class="line">System.out.println(<span class="string">"and: "</span> + ans);</span><br></pre></td></tr></table></figure></p><p>不需要返回值的 <code>thenAcceptBoth</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,  Runnable action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>使用方式與 <code>thenCombine</code> 相同<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; supplyAsync1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 1"</span>, threadPool);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 2"</span>, threadPool);</span><br><span class="line"></span><br><span class="line">supplyAsync1.thenAcceptBothAsync(supplyAsync2, (result1, result2) -&gt; System.out.println(result1 + <span class="string">", "</span> + result2), threadPool).join();</span><br></pre></td></tr></table></figure></p><hr><p>前面提到的都是兩個獨立 CompletableFuture 的例子，若大於兩個的時候會使用 <code>allOf</code><br><code>allOf</code> 可以等待全部的 CompletableFuture 執行完成後執行 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure><p>等待 supplyAsync1, supplyAsync2, supplyAsync3 執行結束後取得最終結果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 1"</span>, threadPool);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 2"</span>, threadPool);</span><br><span class="line">CompletableFuture&lt;String&gt; supplyAsync3 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supplyAsync 3"</span>, threadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(supplyAsync1, supplyAsync2, supplyAsync3).thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        ans.append(supplyAsync1.get()).append(<span class="string">", "</span>)</span><br><span class="line">            .append(supplyAsync2.get()).append(<span class="string">", "</span>)</span><br><span class="line">            .append(supplyAsync3.get());</span><br><span class="line">        System.out.println(<span class="string">"ans: "</span> + ans.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).join();</span><br></pre></td></tr></table></figure></p><p>在 <code>allOf</code> 後面串接一個 <code>thenRun</code><br>它的用法很簡單，使用方式與 <code>thenAccept</code> 一樣，差別在於不需要傳入上一個 CompletableFuture 的執行結果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><hr><p>上述提到的都是全部完成的例子，反過來說我只想要其中一個有完成就往下執行<br>CompletableFuture 也可以做到這點<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>沒有返回值的 <code>acceptEither</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic</span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt;  <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt;  <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// use your own thread pool</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Void&gt;  <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><p>用於多個 CompletableFuture 的 <code>anyOf</code> ，在眾多 CompletableFuture 只需一個完成就可往下執行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已經好久沒有進行更新&lt;br&gt;最近都在熟悉新工作，與過往不同的 domain knowledge ，融入貫通的過程中學習到滿多關於硬體的知識，目前已經進入狀況&lt;/p&gt;
&lt;p&gt;剛好最近都在使用 CompleteableFuture 處理 thread 非同步的事件&lt;br&gt;來寫篇
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO ByteBuffer 基本操作圖</title>
    <link href="https://henglin31.github.io/2020/01/13/Java-NIO-ByteBuffer-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%9C%96/"/>
    <id>https://henglin31.github.io/2020/01/13/Java-NIO-ByteBuffer-基本操作圖/</id>
    <published>2020-01-13T13:02:08.000Z</published>
    <updated>2020-01-14T12:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>剛剛在刪舊圖片時發現以前為了學 ByteBuffer 時自己畫的操作圖<br><img src="/images/nio-byte-buffer-001.png" width="50%" height="50%" alt="img1"><br>這張圖簡單顯示 ByteBuffer 的寫入與讀取時 position point 和 limit point 的位移<br>allocate 宣告 buffer capacity ，配給 JVM heap ，屬於 GC 可管範圍，需要 copy data ，速度慢於 allocateDirect<br>put(bytes[4]) position 一路從 0 移動到 4 ，0 ~ 3 依序放入內容值， 4 為下一個寫入位置<br>flip() 為準備讀取 buffer 資料前的動作，為了讀取剛剛寫入 0 ~ 3 的內容，則改變 point 指向位置 limit = position 接著 position = 0<br>get(bytes[4]) position 一路從 0 移動到 4 ，0 ~ 3 依序取出內容值<br>clear() 清除不是真的清除資料，也只是改變 point 指向位置， position = 0 且 limit = capacity ，因為下次有資料寫入會直接覆蓋 buffer 內的舊值</p><p>使用 NIO 時會經常使用 ByteBuffer 來做讀取和寫入資料，是一種基於 channel 和 buffer 的 I/O 方式<br>還有一種是 ByteBuffer.allocateDirect(capability) 配給 OS local memory ，不屬於 GC 可控制範圍，不需要 copy 所以速度較快<br>換句話說，它可以使用 native 直接配給 java heap 外的 memory ，之後通過 java heap 裡面的 DirectByteBuffer 針對這一塊 memory refernce 進行操作<br>可在某些使用情況下可提高性能，它避免了 java heap 和 native heap 中來回 copy data</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;剛剛在刪舊圖片時發現以前為了學 ByteBuffer 時自己畫的操作圖&lt;br&gt;&lt;img src=&quot;/images/nio-byte-buffer-001.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;img1&quot;&gt;&lt;br&gt;這張圖簡單顯示 ByteBuf
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="nio" scheme="https://henglin31.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>對於 Java Fork Join framework 的理解</title>
    <link href="https://henglin31.github.io/2020/01/07/%E5%B0%8D%E6%96%BC-Java-Fork-Join-framework-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://henglin31.github.io/2020/01/07/對於-Java-Fork-Join-framework-的理解/</id>
    <published>2020-01-07T12:05:00.000Z</published>
    <updated>2020-01-07T15:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>老實說我在工作中沒直接用過 Java 的 Fork Join 只有以前在作自主練習時用過，知道這個東西<br>如果沒有特別需要，也沒有必要為了使用而使用，一切還是要回歸需求面<br>因最近複習 multi-thread 的相關知識，才有這個機會再次使用<br>它可 parallel 處理 divide and conquer 的問題<br>適合可獨立拆分的問題，且拆出的子問題之間不要存在相依性<br>感覺很像 MapperReduce 的運作</p><p>ForkJoinPool:<br>與 ThreadPoolExecutor 一樣都是繼承自 AbstractExecutorService<br>fork(): 將分割的 task 放入 workQueue ，task 交由 ForkJoinPool 處理<br>join(): blocking 等待 task 完成<br>與 ThreadPoolExecutor 不同的是 ForkJoinPool 內的所有 workThread 都有自己的 workQueue<br>而 ThreadPoolExecutor 是大家共用一個 workQueue<br>這裡要注意的是 workThread 的 workQueue 是 Deque<br>workThread 會從 workQueue 頭部取 task<br>當 workThread 內的 workQueue 沒有 task 可執行，會從其他 workThread 的 workQueue 尾端取 task</p><p>目前看到比較常用的三種 ForkJoinTask<br>RecursiveTask: 有返回值<br>RecursiveAction: 無返回值<br>CountedCompleter: 完成 task 後將觸發其他 task</p><hr><p>這裡練習使用 RecursiveTask 寫一個 merge sort<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] arr, <span class="keyword">final</span> <span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.THRESHOLD = threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt;= THRESHOLD)&#123;</span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> midIndex = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, midIndex);</span><br><span class="line">        <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, midIndex, arr.length);</span><br><span class="line">        </span><br><span class="line">        MergeSort left = <span class="keyword">new</span> MergeSort(leftArr, THRESHOLD);</span><br><span class="line">        MergeSort right = <span class="keyword">new</span> MergeSort(rightArr, THRESHOLD);</span><br><span class="line">        </span><br><span class="line">        left.fork();</span><br><span class="line">        right.fork();</span><br><span class="line">        </span><br><span class="line">        left.join();</span><br><span class="line">        right.join();</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(left.getArr()));</span><br><span class="line">        System.out.println(Arrays.toString(right.getArr()));</span><br><span class="line">        </span><br><span class="line">        arr = mergeArr(left.getArr(), right.getArr());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getArr()&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mergeArr(<span class="keyword">final</span> <span class="keyword">int</span>[] leftArr, <span class="keyword">final</span> <span class="keyword">int</span>[] rightArr)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] resultArr = <span class="keyword">new</span> <span class="keyword">int</span>[leftArr.length + rightArr.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(leftIndex &lt; leftArr.length &amp;&amp; rightIndex &lt; rightArr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftArr[leftIndex] &lt;= rightArr[rightIndex])&#123;</span><br><span class="line">                resultArr[resultIndex] = leftArr[leftIndex];</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resultArr[resultIndex] = rightArr[rightIndex];</span><br><span class="line">                rightIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            resultIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(leftIndex &lt; leftArr.length)&#123;</span><br><span class="line">            resultArr[resultIndex] = leftArr[leftIndex];</span><br><span class="line">            leftIndex++;</span><br><span class="line">            resultIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rightIndex &lt; rightArr.length)&#123;</span><br><span class="line">            resultArr[resultIndex] = rightArr[rightIndex];</span><br><span class="line">            rightIndex++;</span><br><span class="line">            resultIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行 merge sort<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> Random().ints(<span class="number">25</span>, <span class="number">1</span>, <span class="number">100</span>).toArray();</span><br><span class="line">    System.out.println(<span class="string">"ori: "</span> + Arrays.toString(arr) + <span class="string">"\n ---"</span>);</span><br><span class="line">    </span><br><span class="line">    ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">5</span>);</span><br><span class="line">    MergeSort mergeSort = <span class="keyword">new</span> MergeSort(arr, <span class="number">5</span>);</span><br><span class="line">    threadPool.invoke(mergeSort);</span><br><span class="line">    System.out.println(<span class="string">"---\nresult: "</span> + Arrays.toString(mergeSort.getArr()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>執行結果:<br><img src="/images/fork-join-001.png" width="50%" height="50%" alt="img1"></p><p>這篇聊得比較少，也只練習了 RecursiveTask<br>目前稍微熟悉一下就好，等未來有需要使用時再深入了解吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老實說我在工作中沒直接用過 Java 的 Fork Join 只有以前在作自主練習時用過，知道這個東西&lt;br&gt;如果沒有特別需要，也沒有必要為了使用而使用，一切還是要回歸需求面&lt;br&gt;因最近複習 multi-thread 的相關知識，才有這個機會再次使用&lt;br&gt;它可 para
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java BlockingQueue 適合應用在哪些場景</title>
    <link href="https://henglin31.github.io/2020/01/06/Java-BlockingQueue-%E9%81%A9%E5%90%88%E6%87%89%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%A0%B4%E6%99%AF/"/>
    <id>https://henglin31.github.io/2020/01/06/Java-BlockingQueue-適合應用在哪些場景/</id>
    <published>2020-01-06T10:03:44.000Z</published>
    <updated>2020-02-10T00:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>BlockingQueue 適用於緩衝如經典的 producer / consumer 場景<br>大多用在多個 thread 之間倆倆需要共享資料時，一個放另一個取，非常方便，通常我用它來取代 wait() 和 notify() 做 thread 通信<br>上一篇 ThreadPoolExecutor 第5個參數就是 BlockingQueue 用來存放等待從 thread pool 取得 thread 的 task<br>可根據不同的應用場景可搭配適合的 BlockingQueue<br>這個主題偏向於應用面的思考，針對不同場景選擇使用 BlockingQueue</p><hr><p>BlockingQueue:<br>ArrayBlockingQueue</p><p>適用場景:<br>在非高併發任務，且可預估出固定處理速率時<br>如: 一般的緩衝區</p><p>特色:<br>queue 容量固定個數，屬於有 bounded 的類型，滿或空的時候會 blocking<br>放入與取出使用同一個 lock ，所以不利於高併發下使用</p><hr><p>BlockingQueue:<br>PriorityBlockingQueue</p><p>適用場景:<br>當需要優先處理特定任務時，需讓高優先權任務盡快被取出處理，再接著處理次要的任務<br>如: 在有階級機制下的搶票系統，可根據階級設定每個人的優先權，讓高優先權的人優先取得票</p><p>特色:<br>queue 容量為 Integer.MAX_VALUE – 8 ， Java doc 上說明為 unbounded<br>根據 priority 排序，優先級高的會被優先取出處理<br>比較特別的是它 add(), offer(), put() 操作都一樣，都是 offer() 操作</p><hr><p>BlockingQueue:<br>LinkedBlockingQueue</p><p>適用場景:<br>需要高併發情況下使用，但需要評估取出時的消耗率，避免高併發下取出速度趕不上放入速度造成 OutOfMemory<br>如: 即時訊息處理</p><p>特色:<br>queue 容量可調整， Java doc 上說明為 optionally-bounded ，預設值為 Integer.MAX_VALUE，但一般來說會根據需求設值<br>用於高併發，使用讀寫分離，放入使用 putLock 而取出使用 takeLock<br>在上一篇 ThreadPoolExecutor 有稍微提到<br>且 newFixedThreadPool, newSingleThreadExecutor 都使使用 LinkedBlockingQueue 作為 workQueue</p><hr><p>BlockingQueue:<br>LinkedBlockingDeque</p><p>適用場景:<br>有雙向需求<br>如: real-time 處理任務，在某些危險的情況下需要警急處理終止命令</p><p>特色:<br>有雙向需求，基本上與 LinkedBlockingQueue 相似<br>可以當作極端的 PriorityBlockingQueue ，但只有一般和最高兩種權限</p><hr><p>BlockingQueue:<br>SynchronousQueue</p><p>場景:<br>目前想不到單獨使用的場請，所以需搭配 newCachedThreadPool 使用<br>newCachedThreadPool 適用於在特定情況或時間下會才一瞬間出現大量 task，但在大部分情況下處理量不高<br>如: 某些監控系統或感應器，只有在警報發生或瞬間觸發多個動作時需要處理大量 task ，其餘時間皆為正常的處理量</p><p>特色:<br>它沒有容量，所以 peek() 永遠為空，底層是 transfer 且等待為0秒，放與取只能手把手地快速交換<br>目前所知需搭配 newCachedThreadPool 使用，其底層實作為上一篇提到的 ThreadPoolExecutor<br>因 SynchronousQueue 沒容量，因此 newCachedThreadPool 可以根據 task 需求量在 thread pool 中創建多個 thread 直到設定的上限值<br>而不受 workQueue 影響</p><hr><p>BlockingQueue:<br>DelayQueue</p><p>適用場景:<br>延後處理，或者有時間倒數的情況<br>如: 某些嚴格的登入系統因安全性考量，當每次登入後可能只有3分鐘時間可處理，等時間超過3分鐘則會自動登出</p><p>特色:<br>queue 容量為 Integer.MAX_VALUE ， Java doc 上說明為 unbounded<br>task 放入 queue 後需要過一段時間後才可被取出<br>假設目前有 t1, t2 兩個 task 需放入 queue<br>將 t1 設定5秒後處理後放入 queue ，接著 t2 設定2秒後處理後放入 queue<br>拿的時候會先 blocking 等到2秒後先取出 t2 ，若 t2 需處理較長的時間，假設需要10秒<br>此時 t1 還在 queue 中，所以可能在10秒後才從 queue 中取出 t1<br>反之 t2 若瞬間處理結束，則需 blocking 直到5秒後取出 t1</p><hr><p>BlockingQueue:<br>LinkedTransferQueue</p><p>適用場景:<br>producer 壓榨 consumer ，producer 想要在指定時間內或需要 consumer 立即處理，此時 consumer 需要有快速消耗的能力<br>如: 追求高併發極限，只要有 task 就立即處理</p><p>特色:<br>確保 producer 的資料能立即被 consumer 處理<br>底層與 SynchronousQueue 一樣都是使用 transfer ，除非超時，否則會一直 blocking<br>一般的 BlockingQueue 是 producer 放完資料就結束，除非 queue 滿了才會 blocking<br>而 LinkedTransferQueue 需要等 consumer 處理才算結束，不然就 blocking</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BlockingQueue 適用於緩衝如經典的 producer / consumer 場景&lt;br&gt;大多用在多個 thread 之間倆倆需要共享資料時，一個放另一個取，非常方便，通常我用它來取代 wait() 和 notify() 做 thread 通信&lt;br&gt;上一篇 Th
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>對於 Java ThreadPoolExecutor 的理解</title>
    <link href="https://henglin31.github.io/2020/01/05/%E5%B0%8D%E6%96%BC-Java-ThreadPoolExecutor-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://henglin31.github.io/2020/01/05/對於-Java-ThreadPoolExecutor-的理解/</id>
    <published>2020-01-05T11:26:00.000Z</published>
    <updated>2020-01-07T07:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到 thread 就會想到 thread pool ，因為在實際應用上可能需要處理成千上萬的 task<br>不可能一個 task 就開一個 thread 且 thread 過多光是頻繁的 context switch 就可能造成效能低落<br>頻繁的創建與銷毀 thread 也是不小的開銷<br>所以一般都是根據實際需求創建 thread pool 來控制 thread 個數<br>Executors 有提供好幾種 thread pool 如 newFixedThreadPool, newSingleThreadExecutor, newCachedThreadPool 等<br>它們的底層都是使用 ThreadPoolExecutor 搭配不同參數所實現的<br>在正常情況下我會依據問題的需求自己調整參數，因為 Executors 大多使用 LinkedBlockingQueue 其預設容量為 Integer.MAX_VALUE<br>在高併發下，最終可能累計過多 task 造成 OutOfMemory 的情況發生</p><p>ThreadPoolExecutor 有7個參數可供調整，只要熟悉每個參數的使用，就可以根據需求來設計 thread pool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize: thread pool 建立後初始化的 thread 個數<br>maximumPoolSize: thread pool 內同時間執行 thread 的上限值，因為當 workQueue 滿了又有 task 進入時需要創建更多 thread 來處理，但不能無限增加 thread 數量，故使用此設定值<br>keepAliveTime: thread pool 沒用到的空閒 thread 的存活時間，因為當 loading 降低時，需要將 thread pool 個數需要降回 corePoolSize 減少資源的浪費<br>unit: keepAliveTime 時間的單位<br>workQueue: 任何實現 BlockingQueue 的 queue，放尚未被執行的 task<br>threadFactory: 沒什麼好說的，就生成 thread 用的 factory ，用預設值就好<br>handler(rejected): 當 workQueue滿了且 thread pool 內的 thread 已達 maximumPoolSize 的上限，無法處理新的 task 所以需進行額外的處理</p><hr><p>畫個圖簡單說明 ThreadPoolExecutor 執行的情況，以下系列圖中的 t 為 task ，所以 t1 表示 task 1<br>實線方體為可用 thread ，虛線方體為未存在的 thread ，長方灰階為 work queue<br>這裡 corePoolSize = 2 所以有兩個實線方體， maximumPoolSize = 5 所以最多可生成5個 thread ， workQueue = 4 所以長方灰階最多可排4個 task<br><img src="/images/thread-pool-executor-001.png" width="50%" height="50%" alt="img1"></p><hr><p>假設目前 t1, t2, t3 3個 task 執行 execute() 此時需決定是否取得 thread 執行 task ，或者放入 workQueue 等待<br><img src="/images/thread-pool-executor-002.png" width="50%" height="50%" alt="img2"></p><hr><p>可用 thread 個數為2，所以 t1, t2 取得 thread 執行， 而 t3 進入 workQueue 等待<br><img src="/images/thread-pool-executor-003.png" width="50%" height="50%" alt="img3"></p><hr><p>此時 t4, t5, t6 3個 task 執行 execute() 後需決定是否取得 thread 執行 task ，或者放入 workQueue 等待<br><img src="/images/thread-pool-executor-004.png" width="50%" height="50%" alt="img4"></p><hr><p>無可用 thread 所以 t4, t5, t6 放入 workQueue 等待<br><img src="/images/thread-pool-executor-005.png" width="50%" height="50%" alt="img5"></p><hr><p>很快的 t7, t8, t9 也執行 execute()<br><img src="/images/thread-pool-executor-006.png" width="50%" height="50%" alt="img6"></p><hr><p>無可用 thread 且 workQueue 已滿，所以生成3個 thread 讓 t3, t4, t5 取得 thread 後 t7, t8, t9 放入 workQueue<br><img src="/images/thread-pool-executor-007.png" width="50%" height="50%" alt="img7"></p><hr><p>t10 執行 execute() 後發現 thread 個數已達 maximumPoolSize 且 workQueue 已滿，觸發 handler 處理<br>RejectedExecutionHandler 提供四種策略<br>AbortPolicy: 直接拋出 RejectedExecutionException 阻止正常執行<br>CallerRunsPolicy: 不會觸發 exception，回給 caller 執行<br>DiscardOldestPolicy: 移除 workQueue 內等待最久的 task ，並將新的 task 放入<br>DiscardPolicy: 直接拒絕 task 不觸發任何 exception<br><img src="/images/thread-pool-executor-008.png" width="50%" height="50%" alt="img8"></p><hr><p>過一段時間 workQueue 已空且只剩2個 thread 被 t8, t9 取用<br><img src="/images/thread-pool-executor-009.png" width="50%" height="50%" alt="img9"></p><hr><p>又過了一段時間，根據 keepAliveTime = 60, unit = sec 所以在3個未用的 thread 經過60秒後銷毀<br><img src="/images/thread-pool-executor-010.png" width="50%" height="50%" alt="img10"></p><hr><p>已無任何 task 需要執行， thread pool 回到原始狀態<br><img src="/images/thread-pool-executor-001.png" width="50%" height="50%" alt="img11"></p><hr><p>了解執行原理後，接下來就需要根據經驗來調整參數<br>要如何合理的配置 thread pool 的 thread 個數<br>這需要牽扯到要解的問題是遇到 CPU bound 還是 I/O bound<br>若是 CPU bound 可以設置 maximumPoolSize 設為趨近目前電腦或 VM 所配置的核心數，減少 context switch 的切換<br>Java 可用 Runtime.getRuntime().availableProcessors() 取得此數據<br>若是 I/O bound 就可以盡量設置高一點，因為在做頻繁 I/O 時 task 大多需要等待 I/O 執行完畢，卡在身上不如給其他人使用，提高 CPU 的利用率<br>以此為基礎多跑幾次實驗，最終可調出較佳的結果，這東西很迷沒有正確的數值只能慢慢調整</p><p>結論</p><ol><li>為了效能需求 thread pool 最好使用 ThreadPoolExecutor 依據需求自行設定</li><li>請根據 CPU bound 或 I/O bound 進行調整 thread 個數</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提到 thread 就會想到 thread pool ，因為在實際應用上可能需要處理成千上萬的 task&lt;br&gt;不可能一個 task 就開一個 thread 且 thread 過多光是頻繁的 context switch 就可能造成效能低落&lt;br&gt;頻繁的創建與銷毀 thre
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java ReentrantLock 和 ReentrantReadWriteLock 的使用時機</title>
    <link href="https://henglin31.github.io/2020/01/04/Java-ReentrantLock-%E5%92%8C-ReentrantReadWriteLock-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F/"/>
    <id>https://henglin31.github.io/2020/01/04/Java-ReentrantLock-和-ReentrantReadWriteLock-的使用時機/</id>
    <published>2020-01-04T06:25:47.000Z</published>
    <updated>2020-01-05T11:10:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在實際工作中我大多使用 ReentrantReadWriteLock 因為遇到的使用情景都是讀取的需求遠大於寫入<br>所以除非某些場景需要使用 synchronized 為了更好的效能可能會用 ReentrantLock 取代<br>synchronized 是 JVM 層級的同步鎖，底層機制鎖死整個區塊，而 Lock 類的是使用 java.util.concurrent 下實現的 lib<br>而且可以綁定多個 condition 可以喚醒特定的 thread (thread.signal())，不像 synchronized 只能一次喚醒全部或者隨機一個，彈性上強上許多</p><p>如果用一句話解釋 ReentrantLock 和 ReentrantReadWriteLock 兩者的差別就是<br>ReentrantLock: One thread at a time.<br>ReentrantReadWriteLock: One writer thread at a time or multiple reader threads at a time.<br>它們分別 implement Lock 和 ReadWriteLock<br>ReadWriteLock其實就是基於 Lock 上作讀寫分離<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>先聊 ReentrantLock<br>在正常使用下只需針對存取變數block包覆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//access the resource</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReentrantLock 如字面上的意思他是所以可以重入(會計算重入次數，離開時遞減次數)，但 lock 和 unlock 必須成對出現<br>但在一般情況下是不會使用兩層 lock ，主要是針對不同 method 之間有交互引用時，存取共享變數資料時好用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//access the resource</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>還有它初始化時可以設置公平鎖和非公平鎖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FairSync: multi-thread 按照申請鎖的順序來獲取鎖，類似排隊，先來後到<br>NonfairSync: 獲取鎖的順序並不是按照申請鎖的順序，可能後申請的 thread 比先申請的優先權高，在高併發的情況下，可能造成優先級別反轉或者飢餓現象(長時間都拿不到cpu執行權限)</p><hr><p>接著來談 ReentrantReadWriteLock<br>簡單的說它與 ReentrantLock 最大的不同在於 readLock 可以放多個讀取操作進入，而且 readLock 與 writeLock 是互斥的<br>為了更容易了解，就簡單畫個圖來說明，這裡的 t 表示 thread<br><img src="/images/reentrant-read-write-lock-001.png" width="50%" height="50%" alt="img1"><br>當 t1 取得鎖在執行寫入操作時(writeLock)，後面有3個thread進入等待<br>此時 t1 執行完畢後，接著執行 readLock ，允許多個 read 操作進入(same read lock)，所以 t2 和 t4 也進入讀取變數<br>t5 進入等待區，t5 雖然也是讀取操作，但沒有與 t2 和 t4 一樣進入區間，因為在 t2 和 t4進入後 read 操作的 thread 等待個數為 0 所以下次需讓給 write lock<br>t2 和 t4 讀取結束，放 t3 進入，因為 t3 為寫操作，所以只能是自已進入作寫入(single thread)</p><p>Java中的ReentrantReadWriteLock使用一個 int 作為鎖的計數<br>sharedCount() 共享鎖(高位元16)，用於 readLock ，允許多個 read thread<br>exclusiveCount() 獨佔鎖(低位元16)，用於 writeLock ，只允許一個 write thread</p><p>有時候為了確保讀寫互斥安全性會做鎖降級或鎖升級<br>鎖降級: 在 writeLock 沒有釋放的時候，獲取 readLock，再釋放 writeLock<br>鎖升級: 在 readLock 沒有釋放的時候，獲取 writeLock，再釋放 readLock<br>這裡示範鎖降級，利用讀寫互斥在 writeLock.unlock() 前面卡 readLock.lock()，避免被其他 write thread 搶佔cpu更新變數，保證一次性的 atomic 操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWriteResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span>(isUpdate)&#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="comment">//write the resource</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//read the resource</span></span><br><span class="line">    readLock.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這裡需注意 isUpdate 需要設置 volatile 讓全部 thread 可見 flag 變化</p><hr><p>結論</p><ol><li>ReentrantLock 可作為 synchronized 的替代品，需使用公平鎖機制時使用</li><li>ReentrantReadWriteLock 用於讀取遠大於寫入的場景，</li></ol><p>目前先寫到這，其他等以後想到其他再補充吧…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在實際工作中我大多使用 ReentrantReadWriteLock 因為遇到的使用情景都是讀取的需求遠大於寫入&lt;br&gt;所以除非某些場景需要使用 synchronized 為了更好的效能可能會用 ReentrantLock 取代&lt;br&gt;synchronized 是 JVM 
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java volatile 的使用時機</title>
    <link href="https://henglin31.github.io/2020/01/03/Java-volatile-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F/"/>
    <id>https://henglin31.github.io/2020/01/03/Java-volatile-的使用時機/</id>
    <published>2020-01-03T10:35:13.000Z</published>
    <updated>2020-01-21T16:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近重頭複習 java multi-thread 的相關知識，紀錄下來方便自己往後開發時可參照<br>今天來談 volatile 它可以當成一個輕量的鎖<br>我通常使用它來控制 multi-thread 共享變數，用來通知多個 thread 任務完成後正常離開<br>但它不能用於 java 計數，如 <code>count++</code>, <code>index--</code> 之類的操作，這些動作看起來是一步，但實際上卻是三步</p><ol><li>iload_1</li><li>iinc 1, 1</li><li>istore_1<br>若在執行期間 1 ~ 3 不能一氣呵成的執行完畢，中間被其他 thread 打斷後操作同個變數，其結果可能會與預期中的不同<br>因為它不保證 atomic ，若有計數的需求需使用 AtomicInteger, AtomicReference, AtomicStampedReference 之類的 lib 來實現</li></ol><p>在使用 volatile 之前要先了解 java thread 使用記憶體的情況<br>在 process 有宣告變數時主記憶體會提供空間存放變數資料 (這裡的 process 不是指 main() 因為 main() 一樣是 thread ，由 JVM 運行時創建)<br>但是在多個 thread 使用宣告的共享變數時，記憶體一樣會有一份共享變數資料<br>不同的是多個 thread 並不是直接共用此份共享變數資料<br>而是各自從共享變數 copy 一份變數資料到各自的 thread 中 ( cache )<br>當 thread 更新變數資料時，首先是改變自己內部的資料後再寫回記憶體中的那份共享變數<br>所以若是其他 thread 沒有從記憶體內的共享變數重新更新最資料回自己的 thread 時<br>會造成資料不一致的後果</p><p>那為什麼其他 thread 不更新自己變數資料呢?<br>這是 Java 為了性能優化而做的預設的行為<br>因為其他 thread 可能只有做讀取的操作，所以 Java 認為不需要再從主記憶體重新拿資料<br>不知道已經有 thread 已經更新變數內容</p><p>為了避免 thread 共享變數資料不一致得問題發生 volatile 就派上用場了<br>volatile 可以強迫 thread 更新資料回記憶體共享變數資料後並通知前他 thread 更新它們內部的資料<br>來保證資料的可見性<br>前面有說過 volatile 並不可用於計數相關的處理，因為它並不是真的鎖住整個物件<br>所以不保證只有一個 thread 可進入後單獨更新變數，因此當此 thread 可能在數值更新時並未 assign 回變數時<br>就被其他 thread 取得 cpu 控制權，並 assign 同筆資料時造成互蓋的問題</p><p>之前有做過實驗使用 10 個 thread 並將共享變數宣告為 volatile 從0一路增加到1000<br>在預期的情況下 10 * 1000 會是 10000 ，但在實際運行多次的情況下沒有一次得到10000<br>通常數值落在 7000 ~ 9000 多，就是高併發快速交錯運行下互蓋資料的後果</p><p>結論</p><ol><li>volatile 可確保資料可見性，一個 thread 更新變數，其他 thread 也會重新更新內部變數</li><li>volatile 不保證 atomic，不可用於計數操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重頭複習 java multi-thread 的相關知識，紀錄下來方便自己往後開發時可參照&lt;br&gt;今天來談 volatile 它可以當成一個輕量的鎖&lt;br&gt;我通常使用它來控制 multi-thread 共享變數，用來通知多個 thread 任務完成後正常離開&lt;br&gt;但它
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud 使用 gradle 打包 docker image</title>
    <link href="https://henglin31.github.io/2019/11/11/spring-cloud-%E4%BD%BF%E7%94%A8-gradle-%E6%89%93%E5%8C%85-docker-image/"/>
    <id>https://henglin31.github.io/2019/11/11/spring-cloud-使用-gradle-打包-docker-image/</id>
    <published>2019-11-11T08:59:11.000Z</published>
    <updated>2019-11-12T13:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前在github上看到的spring cloud project中大部分都是使用maven來建立專案<br>使用gradle的不太多，更別說是使用gradle將spring cloud service打包成docker image<br>因此花了一些時間研究一下如何使用gradle直接建立docker image而不是透過DockerFile<br>目前找到一個可以直接將springBootApplication打包成docker image的plugin</p><p>在此先看一下目錄結構<br><img src="/images/spring-cloud-gradle-docker-001.png" width="300px" height="15%" alt="img1"></p><p>第一步先來到spring-cloud project (root)下設置gradle檔案<br>第10行引入”com.bmuschko:gradle-docker-plugin:5.3.0”才可以讓gradle script實現打包docker image的功能<br>第19行引入apply plugin: “com.bmuschko.docker-spring-boot-application”讓整個sub project中的module都可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/milestone'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://plugins.gradle.org/m2/'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span></span><br><span class="line">        classpath <span class="string">"com.bmuschko:gradle-docker-plugin:5.3.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    apply plugin: <span class="string">'idea'</span></span><br><span class="line">    apply plugin: <span class="string">'java'</span></span><br><span class="line">    apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">    apply plugin: <span class="string">"io.spring.dependency-management"</span></span><br><span class="line">    apply plugin: <span class="string">"com.bmuschko.docker-spring-boot-application"</span></span><br><span class="line"></span><br><span class="line">    group = <span class="string">'pers.henglin'</span></span><br><span class="line">    version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">    jar.enabled = <span class="keyword">true</span></span><br><span class="line">    bootJar.enabled = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/milestone'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        compileOnly <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">        annotationProcessor <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">        testImplementation <span class="string">"org.springframework.boot:spring-boot-starter-test"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencyManagement &#123;</span><br><span class="line">        imports &#123;</span><br><span class="line">            mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root project下的settings.gradle也要記得設定使用哪些module，不然subprojects區塊內的效果不會引入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rootProject.name</span> <span class="string">=</span> <span class="string">'spring-cloud'</span></span><br><span class="line"><span class="string">include</span> <span class="string">'core'</span></span><br><span class="line"><span class="string">include</span> <span class="string">'eureka'</span></span><br><span class="line"><span class="string">include</span> <span class="string">'demo-server'</span></span><br><span class="line"><span class="string">include</span> <span class="string">'demo-client'</span></span><br></pre></td></tr></table></figure><hr><p>第二步來到eureka module下的gradle檔案中設置<br>第8~14行打包docker成docker images，baseImage指定docker image，ports指定預設docker image exposed ports<br>還有其他的應用和設定可以查看文件：<br><a href="https://bmuschko.github.io/gradle-docker-plugin/" target="_blank" rel="noopener">https://bmuschko.github.io/gradle-docker-plugin/</a><br>此例子是直接使用文件中第4節所提到的springBootApplication的打包功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'org.springframework:springloaded:1.2.8.RELEASE'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-devtools'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker &#123;</span><br><span class="line">    springBootApplication &#123;</span><br><span class="line">        baseImage = <span class="string">'openjdk:jre-alpine'</span></span><br><span class="line">        maintainer = <span class="string">'heng-lin "enjoymycodinglife@gmail.com"'</span></span><br><span class="line">        ports = [<span class="number">8761</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>第三步實現在docker中動態傳參數的效果<br>來到eureka module下的application.yml檔案中動態設置hostname<br>在此使用環境變量${EUREKA_HOST:localhost}，此語法為若環境變量中有EUREKA_HOST就使用其內容，若無則使用預設值localhost<br>未來可在docker下動態設置環境變量來達成傳參的效果</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">$&#123;EUREKA_HOST:localhost&#125;</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><hr><p>設置docker-compose目錄下的spring-cloud.env檔<br>內容中EUREKA_HOST指定hostname為sc-eureka，sc是spring cloud的意思</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### mysql</span></span><br><span class="line"><span class="string">DATASOURCE_DBTYPE=mysql</span></span><br><span class="line"><span class="string">DATASOURCE_HOST=sc-mysql</span></span><br><span class="line"><span class="string">DATASOURCE_PORT=3306</span></span><br><span class="line"><span class="string">DATASOURCE_USERNAME=root</span></span><br><span class="line"><span class="string">DATASOURCE_PASSWORD=123456</span></span><br><span class="line"><span class="string">DATASOURCE_DRIVER=com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### eureka</span></span><br><span class="line"><span class="string">EUREKA_HOST=sc-eureka</span></span><br></pre></td></tr></table></figure><hr><p>設置docker-compose目錄下的docker-compose.yml<br>第27~34行為eureka module於docker建立container時的設定<br>第34行env_file指定spring-cloud.env為變數時，會將EUREKA_HOST=sc-eureka設為docker的環境變數<br>因此eureka module下的application.yml也會將hostname: ${EUREKA_HOST:localhost}值設為sc-eureka而不是預設的localhost</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">sc-mysql</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">sc-net</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/mysql:/var/lib/mysql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  demo-server:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">pers.henglin/demo-server:0.0.1-snapshot</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">sc-demo-server</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">sc-net</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line"><span class="attr">    env_file:</span> <span class="string">spring-cloud.env</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  eureka:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">pers.henglin/eureka:0.0.1-snapshot</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">sc-eureka</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">sc-net</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8761</span><span class="string">:8761</span></span><br><span class="line"><span class="attr">    env_file:</span> <span class="string">spring-cloud.env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  sc-net:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><p>最後來到spring-cloud目錄(root)下設定eureka.sh<br>第4~8行移動到eureka module下執行gradle DockerBuildImage會觸發gradle下的docker{…}的打包作業<br>第14~17行移動到docker-compose目錄下指定執行eureka (daemon)，會依據docker-compose.yml設定環境變數<br>並且啟動docker container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build gradle to docker image</span></span><br><span class="line"><span class="built_in">cd</span> eureka || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'current dir: '</span> &amp;&amp; <span class="built_in">pwd</span></span><br><span class="line">docker rm -f sc-eureka &amp;&gt; /dev/null</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'build docker image...'</span></span><br><span class="line">gradle DockerBuildImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># root</span></span><br><span class="line"><span class="built_in">cd</span> - || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run</span></span><br><span class="line"><span class="built_in">cd</span> docker-compose || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'current dir: '</span> &amp;&amp; <span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'docker run...'</span></span><br><span class="line">docker-compose -f docker-compose.yml up -d eureka</span><br></pre></td></tr></table></figure><hr><p>執行docker ps看到sc-eureka container已啟動<br><img src="/images/spring-cloud-gradle-docker-002.png" width="100%" height="50%" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前在github上看到的spring cloud project中大部分都是使用maven來建立專案&lt;br&gt;使用gradle的不太多，更別說是使用gradle將spring cloud service打包成docker image&lt;br&gt;因此花了一些時間研究一下如何使用g
      
    
    </summary>
    
    
      <category term="gradle" scheme="https://henglin31.github.io/tags/gradle/"/>
    
      <category term="docker" scheme="https://henglin31.github.io/tags/docker/"/>
    
      <category term="spring cloud" scheme="https://henglin31.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop RecordReader</title>
    <link href="https://henglin31.github.io/2019/11/06/Hadoop-RecordReader/"/>
    <id>https://henglin31.github.io/2019/11/06/Hadoop-RecordReader/</id>
    <published>2019-11-06T05:03:25.000Z</published>
    <updated>2019-11-11T12:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多時候我們會自定義一些讀取資料的格式，而hadoop默認的RecordReader是LineRecordReader<br>會一行一行的讀取資料，key為偏移量，value為整行內容</p><p>現在嘗試客製化一個新的RecordReader，在此使用LineRecrodReader為基礎<br>並使用上一篇BuyPhoneJob的運算結果封裝成BuyPhoneBean，實現RecordReader後，可自定義資料格式傳給map</p><p>第一步建立BuyPhoneBean，一樣implements Writable，做序列化和反序列化<br>customerIds雖然為多個值組成，但在這裡當整個字串處理</p><table><thead><tr><th>procuctName</th><th>productPrice</th><th>customerIds</th></tr></thead><tbody><tr><td>iPhone 8 Plus</td><td>449.97</td><td>001,026,022,015,007</td></tr><tr><td>iPhone 7</td><td>207.0</td><td>004,029,024,018,010</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhoneBean</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> productPrice;</span><br><span class="line">    <span class="keyword">private</span> String customerIds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyPhoneBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.productName);</span><br><span class="line">        out.writeDouble(<span class="keyword">this</span>.productPrice);</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.customerIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productName = in.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.productPrice = in.readDouble();</span><br><span class="line">        <span class="keyword">this</span>.customerIds = in.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>第二步自定義RecordReader，讀取依舊是使用LineRecordReader，只是將結果改為key是productName，而value是BuyPhoneBean<br>在繼承RecordReader後需要Override一些methods，運作方式會在之後做說明<br>這裡需要注意的是LineRecordReader使用完後在close method上進行關閉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhoneRecordReader</span> <span class="keyword">extends</span> <span class="title">RecordReader</span>&lt;<span class="title">Text</span>, <span class="title">BuyPhoneBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(BuyPhoneRecordReader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LineRecordReader lineRecordReader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Text key = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">private</span> BuyPhoneBean value = <span class="keyword">new</span> BuyPhoneBean();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Text lineValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(InputSplit split, TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lineRecordReader = <span class="keyword">new</span> LineRecordReader();</span><br><span class="line">        <span class="keyword">this</span>.lineRecordReader.initialize(split, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextKeyValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lineRecordReader.nextKeyValue())&#123;</span><br><span class="line">            lineValue = lineRecordReader.getCurrentValue();</span><br><span class="line">            <span class="keyword">byte</span>[] line = lineValue.getBytes();</span><br><span class="line">            <span class="keyword">int</span> lineLen = lineValue.getLength();</span><br><span class="line">            String data = <span class="keyword">new</span> String(line, <span class="number">0</span>, lineLen);</span><br><span class="line">            setKeyValue(<span class="keyword">this</span>.key, <span class="keyword">this</span>.value, data.split(REGEX_COLS_SPLIT_SYMBOL));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKeyValue</span><span class="params">(Text key, BuyPhoneBean value, String[] cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cols.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            logger.warn(<span class="string">"this cols[] length &lt; 3"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String productName = cols[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> productPrice = Double.parseDouble(cols[<span class="number">1</span>]);</span><br><span class="line">        String customerIds = cols[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        key.set(<span class="keyword">new</span> Text(productName));</span><br><span class="line"></span><br><span class="line">        value.setProductName(productName);</span><br><span class="line">        value.setProductPrice(productPrice);</span><br><span class="line">        value.setCustomerIds(customerIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">getCurrentKey</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BuyPhoneBean <span class="title">getCurrentValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getProgress</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lineRecordReader.getProgress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lineRecordReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>運作方式可看hadoop Mapper的source code (org.apache.hadoop.mapreduce.Mapper)<br>這裡擷取裡面136~151行的code，這裡可以看到 while(context.netKeyValue) 就是執行RecordReader的nextKeyValue method<br>而 map(context.getCurrentKey(), context.getCurrentValue(), context) 就是執行RecordReader的getCurrentKey()和getCurrentValue() method<br>在每次執行context.nextKeyValue()時判斷是否有下筆資料，因為我是借用LineRecordReader讀資料，所以直接使用它的nextKeyValue<br>只是將資料重新封裝成key是productName，value是BuyPhoneBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expert users can override this method for more complete control over the</span></span><br><span class="line"><span class="comment"> * execution of the Mapper.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  setup(context);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (context.nextKeyValue()) &#123;</span><br><span class="line">      map(context.getCurrentKey(), context.getCurrentValue(), context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    cleanup(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>第三步將客製化的RecordReader覆寫到InputFormat，才可以讓hadoop使用自己做的RecordReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhoneInputFormat</span> <span class="keyword">extends</span> <span class="title">FileInputFormat</span>&lt;<span class="title">Text</span>, <span class="title">BuyPhoneBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RecordReader&lt;Text, BuyPhoneBean&gt; <span class="title">createRecordReader</span><span class="params">(InputSplit split, TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        BuyPhoneRecordReader recordReader = <span class="keyword">new</span> BuyPhoneRecordReader();</span><br><span class="line">        recordReader.initialize(split, context);</span><br><span class="line">        <span class="keyword">return</span> recordReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>執行job前需要指定setInputFormatClass為我們上一步建立的BuyPhoneInputFormat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(otherArgs.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        System.err.println(<span class="string">"Usage: "</span> + JOB_NAME + <span class="string">" &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">        System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Job job = <span class="keyword">new</span> HadoopJob(conf, JOB_NAME)</span><br><span class="line">            .mapReduce(TestRecordReaderJob.class, SequenceMapper.class, SequenceReducer.class)</span><br><span class="line">            .mapKeyValue(Text.class, BuyPhoneBean.class)</span><br><span class="line">            .reducerKeyValue(Text.class, BuyPhoneBean.class)</span><br><span class="line">            .getJob();</span><br><span class="line"></span><br><span class="line">    job.setInputFormatClass(BuyPhoneInputFormat.class);</span><br><span class="line">    job.setOutputFormatClass(SequenceFileOutputFormat.class);</span><br><span class="line"></span><br><span class="line">    FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡mapper與reducer沒做特別處理，只是單純的輸出，主要還是測試自己寫的RecordReader<br><img src="/images/hadoop-recordreader-001.png" width="300px" height="15%" alt="img1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多時候我們會自定義一些讀取資料的格式，而hadoop默認的RecordReader是LineRecordReader&lt;br&gt;會一行一行的讀取資料，key為偏移量，value為整行內容&lt;/p&gt;
&lt;p&gt;現在嘗試客製化一個新的RecordReader，在此使用LineRecro
      
    
    </summary>
    
    
      <category term="hadoop" scheme="https://henglin31.github.io/tags/hadoop/"/>
    
      <category term="big data" scheme="https://henglin31.github.io/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Writable</title>
    <link href="https://henglin31.github.io/2019/11/03/Hadoop-Writable/"/>
    <id>https://henglin31.github.io/2019/11/03/Hadoop-Writable/</id>
    <published>2019-11-03T04:10:44.000Z</published>
    <updated>2019-11-11T12:55:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>近幾天花了一些時間研究一下Hadoop，幾年前在使用HBase時有稍微玩一下<br>但沒有深入去瞭解，目前正在學習使用docker，看到docker hub上有人已經包好hadoop cluster<br>就建個cluster來測試一下</p><p>啟動hadoop cluster成功<br><img src="/images/hadoop-writable-001.png" width="50%" height="50%" alt="img1"></p><p><img src="/images/hadoop-writable-002.png" width="50%" height="50%" alt="img2"></p><p><img src="/images/hadoop-writable-003.png" width="50%" height="50%" alt="img3"></p><p>這次主題為客製化Writable，將資料包裝為Serializable Object後傳輸<br>為了傳輸效能Hadoop有自己的序列化，而不直接使用Java自帶的序列化<br>同樣是序列化，但是Java序列化產生出的byte stream包了較多的物件資訊(重量)<br>Hadoop的序列化自帶的序列化資訊比較簡潔(輕量)</p><p>要使用Hadoop的序列化必須implements Writable<br>它會要求Override write和readFields作為序列化與反序列化資料轉化為byte stream</p><p>此次使用場景為統計各個產品被哪些顧客購買<br>資料分為三種：<br>顧客資料(customer.txt)</p><table><thead><tr><th>customerId</th><th>productId</th></tr></thead><tbody><tr><td>001</td><td>01</td></tr><tr><td>002</td><td>04</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>產品資料(product.txt)</p><table><thead><tr><th>productId</th><th>productName</th></tr></thead><tbody><tr><td>01</td><td>iPhone 8 Plus</td></tr><tr><td>02</td><td>iPhone 7</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>產品價格(price.txt)</p><table><thead><tr><th>productId</th><th>productPrice</th></tr></thead><tbody><tr><td>01</td><td>449.97s</td></tr><tr><td>02</td><td>207.00</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>先建立一個CustomerBean將來資料從map傳給reducer時可用<br>這裡要注意write和readFields在做序列化和反序列化時“順序”需要保持順序一致<br>才不會解析錯誤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBean</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String CUSTOMER = <span class="string">"customer.txt"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT = <span class="string">"product.txt"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRICE = <span class="string">"price.txt"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String dataType;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> productPrice;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.dataType);</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.customerId);</span><br><span class="line">        out.writeUTF(<span class="keyword">this</span>.productName);</span><br><span class="line">        out.writeDouble(<span class="keyword">this</span>.productPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataType = in.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.customerId = in.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.productName = in.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.productPrice = in.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下來建立一個BuyPhoneMapper將資料封裝到CustomerBean後傳給reducer處理<br>因為資料源有三種，所以第一步需要在setup時預先判別資料源類型，這裡使用檔名做為區別<br>第二步根據資料類型封裝資料到CustomerBean此時也需要紀錄資料源類型，方便在reducer時判別<br>第三步將資料寫入context，分組key為productId(三種資料源共通使用)，value為CustomerBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhoneMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">CustomerBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(BuyPhoneMapper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String dataType;</span><br><span class="line">    <span class="keyword">private</span> CustomerBean customerBean = <span class="keyword">new</span> CustomerBean();</span><br><span class="line">    <span class="keyword">private</span> Text outputKey = <span class="keyword">new</span> Text();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        FileSplit inputSplit = (FileSplit) context.getInputSplit();</span><br><span class="line">        <span class="keyword">this</span>.dataType = inputSplit.getPath().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String record = value.toString();</span><br><span class="line">        String[] cols = record.split(Constant.REGEX_COLS_SPLIT_SYMBOL);</span><br><span class="line">        <span class="keyword">this</span>.customerBean.setDataType(<span class="keyword">this</span>.dataType);</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.dataType)&#123;</span><br><span class="line">            <span class="keyword">case</span> CUSTOMER:</span><br><span class="line">                setCustomer(cols, <span class="keyword">this</span>.outputKey, <span class="keyword">this</span>.customerBean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PRODUCT:</span><br><span class="line">                setProduct(cols, <span class="keyword">this</span>.outputKey, <span class="keyword">this</span>.customerBean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PRICE:</span><br><span class="line">                setPrice(cols, <span class="keyword">this</span>.outputKey, <span class="keyword">this</span>.customerBean);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.warn(<span class="string">"It can't find this data type: &#123;&#125;"</span>, <span class="keyword">this</span>.dataType);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(<span class="keyword">this</span>.outputKey, <span class="keyword">this</span>.customerBean);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// record: customerId, productId</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(String[] cols, Text key, CustomerBean customerBean)</span></span>&#123;</span><br><span class="line">        String customerId = cols[<span class="number">0</span>];</span><br><span class="line">        String productId = cols[<span class="number">1</span>];</span><br><span class="line">        customerBean.setCustomerId(customerId);</span><br><span class="line">        customerBean.setProductId(productId);</span><br><span class="line">        customerBean.setProductName(ENPTY_STRING);</span><br><span class="line">        customerBean.setProductPrice(<span class="number">0</span>d);</span><br><span class="line">        key.set(productId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// record: productId, productName</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setProduct</span><span class="params">(String[] cols, Text key, CustomerBean customerBean)</span></span>&#123;</span><br><span class="line">        String productId = cols[<span class="number">0</span>];</span><br><span class="line">        String productName = cols[<span class="number">1</span>];</span><br><span class="line">        customerBean.setCustomerId(ENPTY_STRING);</span><br><span class="line">        customerBean.setProductId(productId);</span><br><span class="line">        customerBean.setProductName(productName);</span><br><span class="line">        customerBean.setProductPrice(<span class="number">0</span>d);</span><br><span class="line">        key.set(productId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// record: productId, productPrice</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(String[] cols, Text key, CustomerBean customerBean)</span></span>&#123;</span><br><span class="line">        String productId = cols[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> productPrice = Double.parseDouble(cols[<span class="number">1</span>]);</span><br><span class="line">        customerBean.setCustomerId(ENPTY_STRING);</span><br><span class="line">        customerBean.setProductId(productId);</span><br><span class="line">        customerBean.setProductName(ENPTY_STRING);</span><br><span class="line">        customerBean.setProductPrice(productPrice);</span><br><span class="line">        key.set(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>BuyPhoneReducer統計手機產品被哪些顧客購買<br>第一步根據資料源類型取得顧客資料(customer)產品名稱(productName)和產品價格(productPrice)<br>第二步統計顧客使用的產品<br>第三步依據產品名稱(productId)與產品價格(productPrice)分群(key)，統計買該產品的顧客們(customerIds)輸出為value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhoneReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">CustomerBean</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(BuyPhoneReducer.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Text outputKey = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">private</span> Text outputValue = <span class="keyword">new</span> Text();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;CustomerBean&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        List&lt;CustomerBean&gt; customers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String productName = ENPTY_STRING;</span><br><span class="line">        <span class="keyword">double</span> productPrice = <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">for</span>(CustomerBean customerBean:values)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(customerBean.getDataType())&#123;</span><br><span class="line">                <span class="keyword">case</span> CUSTOMER:</span><br><span class="line">                    addCustomer(customers, customerBean);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PRODUCT:</span><br><span class="line">                    productName = customerBean.getProductName();</span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                <span class="keyword">case</span> PRICE:</span><br><span class="line">                    productPrice = customerBean.getProductPrice();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    logger.warn(<span class="string">"It can't find this data type: &#123;&#125;"</span>, customerBean.getDataType());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writeResult(context, customers, productName, productPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCustomer</span><span class="params">(List&lt;CustomerBean&gt; customers, CustomerBean customer)</span></span>&#123;</span><br><span class="line">        CustomerBean temp = <span class="keyword">new</span> CustomerBean();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanUtils.copyProperties(temp, customer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        customers.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeResult</span><span class="params">(Context context, List&lt;CustomerBean&gt; customers, String productName, <span class="keyword">double</span> productPrice)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customers.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; customerIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(CustomerBean customer:customers)&#123;</span><br><span class="line">            customer.setProductName(productName);</span><br><span class="line">            customer.setProductPrice(productPrice);</span><br><span class="line">            customerIds.add(customer.getCustomerId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.outputKey.set(productName + REGEX_COLS_SPLIT_SYMBOL + productPrice);</span><br><span class="line">        <span class="keyword">this</span>.outputValue.set(Joiner.on(REGEX_DATA_JOIN_SPLIT_SYMBOL).join(customerIds));</span><br><span class="line">        context.write(<span class="keyword">this</span>.outputKey, <span class="keyword">this</span>.outputValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>到最後一個步驟了，包裝成hadoop任務(job)，yarn可以根據此設定進行執行<br>當job送出時會也會包含Configuration的xml設定一起送出<br>這裡我將Job多包裝一層，比較方便閱讀和使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(otherArgs.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        System.err.println(<span class="string">"Usage: "</span> + JOB_NAME + <span class="string">" &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">        System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Job job = <span class="keyword">new</span> HadoopJob(conf, JOB_NAME)</span><br><span class="line">            .mapReduce(BuyPhoneJob.class, BuyPhoneMapper.class, BuyPhoneReducer.class)</span><br><span class="line">            .mapKeyValue(Text.class, CustomerBean.class)</span><br><span class="line">            .reducerKeyValue(Text.class, Text.class)</span><br><span class="line">            .getJob();</span><br><span class="line">    </span><br><span class="line">    FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/hadoop-writable-004.png" width="300px" height="15%" alt="img4"></p><p>將產品資料寫入到hdfs<br><img src="/images/hadoop-writable-005.png" width="50%" height="50%" alt="img5"></p><p><img src="/images/hadoop-writable-006.png" width="50%" height="50%" alt="img6"></p><p>執行job</p><p><img src="/images/hadoop-writable-007.png" width="50%" height="50%" alt="img7"></p><p>執行完成</p><p><img src="/images/hadoop-writable-008.png" width="50%" height="50%" alt="img8"></p><p>查看結果</p><p><img src="/images/hadoop-writable-009.png" width="50%" height="50%" alt="img9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近幾天花了一些時間研究一下Hadoop，幾年前在使用HBase時有稍微玩一下&lt;br&gt;但沒有深入去瞭解，目前正在學習使用docker，看到docker hub上有人已經包好hadoop cluster&lt;br&gt;就建個cluster來測試一下&lt;/p&gt;
&lt;p&gt;啟動hadoop cl
      
    
    </summary>
    
    
      <category term="hadoop" scheme="https://henglin31.github.io/tags/hadoop/"/>
    
      <category term="big data" scheme="https://henglin31.github.io/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>JSDC 2019</title>
    <link href="https://henglin31.github.io/2019/10/26/JSDC-2019/"/>
    <id>https://henglin31.github.io/2019/10/26/JSDC-2019/</id>
    <published>2019-10-26T10:57:45.000Z</published>
    <updated>2019-10-26T13:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年JSDC跟JCConf剛好都在10月份</p><p>今天第一場的標題Deep Learning in JS還以爲有新的lib可以做machine learning<br>沒想到是Tensorflow出了JS的版本 (Tensorflow.js)<br>稍微查了一下，好像是去年剛發佈，但直到今天我才知道它的存在</p><p><img src="/images/jsdc-2019-001.png" width="50%" height="50%" alt="img1"></p><p>報到還送手提袋和環保吸管，贈品還算滿實用的…</p><p><img src="/images/jsdc-2019-002.png" width="50%" height="50%" alt="img2"></p><p>幾年前參加的時候只送手機拭淨布…</p><p><img src="/images/jsdc-2019-003.png" width="50%" height="50%" alt="img3"></p><p>提到贈品，以前的Java Conference送的東西都滿好的<br>當年參加Java Developer Day的時候還有送包包和杯子<br>可惜停辦了，JCConf印象中好像沒有送什麼贈品…</p><p><img src="/images/jsdc-2019-004.png" width="50%" height="50%" alt="img4"></p><p><img src="/images/jsdc-2019-005.png" width="50%" height="50%" alt="img5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年JSDC跟JCConf剛好都在10月份&lt;/p&gt;
&lt;p&gt;今天第一場的標題Deep Learning in JS還以爲有新的lib可以做machine learning&lt;br&gt;沒想到是Tensorflow出了JS的版本 (Tensorflow.js)&lt;br&gt;稍微查了一下，好
      
    
    </summary>
    
    
      <category term="conference" scheme="https://henglin31.github.io/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>簡易版shell script作自動化處理</title>
    <link href="https://henglin31.github.io/2019/10/22/%E7%B0%A1%E6%98%93%E7%89%88shell-script%E4%BD%9C%E8%87%AA%E5%8B%95%E5%8C%96%E8%99%95%E7%90%86/"/>
    <id>https://henglin31.github.io/2019/10/22/簡易版shell-script作自動化處理/</id>
    <published>2019-10-22T08:26:18.000Z</published>
    <updated>2020-02-09T03:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久沒有寫sh了…都快忘光了…所以今天寫一個簡單的自動化腳本作為複習</p><ul><li>最常見的就是滿足三個功能<ul><li>執行某個命令後自動化處理某些事情</li><li>更改設定黨特定參數</li><li>參數防呆，避免將數值改壞</li></ul></li></ul><p>先來完成第一步<br>首先要透過發出不同的命令去執行特定任務，大多都會使用case來針對不同命令做特定處理，最後增加一個case *) 當命令錯誤時可提示使用方式<br>這裡將處理的任務各自寫成獨立的function，是為了方便後續的維護與修改<br>下方的＄1是sh檔取得command line輸入的第一個參數，若有多個參數數值會依序count，如：\$1, \$2, \$3…</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cmd=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">edit_config</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'edit config'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">run_start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'run start'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">run_stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'run stop'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$cmd</span> <span class="keyword">in</span></span><br><span class="line">    config)</span><br><span class="line">        edit_config;</span><br><span class="line">        ;;</span><br><span class="line">    start)</span><br><span class="line">        run_start;</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        run_stop;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Usage 1. config id, 2. start, 3. stop'</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>第二步來修改設定檔案特定的參數<br>假設現在要修改某個config檔案叫作test.cfg，裡面內容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># test config</span></span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">id=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># other</span></span><br><span class="line">other.cmd=xxx</span><br></pre></td></tr></table></figure><p>想要修改數值可以使用sed命令即時修改特定參數id<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/原字串/取代字串/g 修改檔案名稱</span></span><br></pre></td></tr></table></figure></p><p>因為筆電是macbook所以直接執行會出錯，要在前面再加一個空字串…<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">''</span> <span class="string">'s/原字串/取代字串/g 修改檔案名稱</span></span><br></pre></td></tr></table></figure></p><p>接下來使用if/else來檢查第二參數id有沒有參數 (防呆) ，參數-z為檢查字串長度，若是0則為true，所以可用來判斷是否有輸入id<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$id</span> ]</span><br></pre></td></tr></table></figure></p><p>檢查命令為config才設置id<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cmd=<span class="variable">$1</span></span><br><span class="line">file=test.cfg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$cmd</span> == <span class="string">'config'</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    id=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">edit_config</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="variable">$id</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'no arg "id"'</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'edit config, id='</span><span class="variable">$id</span></span><br><span class="line">        sed -i <span class="string">''</span> <span class="string">'s/\(id=\).*/id='</span><span class="variable">$id</span><span class="string">'/g'</span> <span class="variable">$file</span> </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最終完成後的格式如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="variable">$1</span></span><br><span class="line">file=test.cfg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$cmd</span> == <span class="string">'config'</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    id=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">edit_config</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="variable">$id</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'no arg "id"'</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'edit config, id='</span><span class="variable">$id</span></span><br><span class="line">        sed -i <span class="string">''</span> <span class="string">'s/\(id=\).*/id='</span><span class="variable">$id</span><span class="string">'/g'</span> <span class="variable">$file</span> </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">run_start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'run start'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">run_stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'run stop'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$cmd</span> <span class="keyword">in</span></span><br><span class="line">    config)</span><br><span class="line">        edit_config;</span><br><span class="line">        ;;</span><br><span class="line">    start)</span><br><span class="line">        run_start;</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        run_stop;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Usage 1. config id, 2. start, 3. stop'</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p><p>測試命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./test_cmd.sh</span><br><span class="line">Usage 1. config id, 2. start, 3. stop</span><br><span class="line"></span><br><span class="line">./test_cmd.sh config</span><br><span class="line">no arg "id"</span><br><span class="line"></span><br><span class="line">./test_cmd.sh config 2</span><br><span class="line">edit config, id=2</span><br><span class="line"></span><br><span class="line">./test_cmd.sh start</span><br><span class="line">run start</span><br><span class="line"></span><br><span class="line">./test_cmd.sh stop</span><br><span class="line">run stop</span><br></pre></td></tr></table></figure></p><p>將結果放到 /etc/rc.local 在server開啟時自動執行 /server-script/test_cmd start<br>如果是做成 service 可以放到 /etc/init.d/ 後啟動，使用 chkconfig 設定此 service 為 on</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久沒有寫sh了…都快忘光了…所以今天寫一個簡單的自動化腳本作為複習&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最常見的就是滿足三個功能&lt;ul&gt;
&lt;li&gt;執行某個命令後自動化處理某些事情&lt;/li&gt;
&lt;li&gt;更改設定黨特定參數&lt;/li&gt;
&lt;li&gt;參數防呆，避免將數值改壞&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
      <category term="shell" scheme="https://henglin31.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>JCConf 2019</title>
    <link href="https://henglin31.github.io/2019/10/04/JCConf-2019/"/>
    <id>https://henglin31.github.io/2019/10/04/JCConf-2019/</id>
    <published>2019-10-04T13:14:23.000Z</published>
    <updated>2019-10-10T14:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>又過了一年，整整一年沒有更新…<br>今年又來參加JCConf了，順便記錄一下吧~</p><p><img src="/images/jcconf-2019-001.png" width="50%" height="50%" alt="img1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又過了一年，整整一年沒有更新…&lt;br&gt;今年又來參加JCConf了，順便記錄一下吧~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jcconf-2019-001.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="conference" scheme="https://henglin31.github.io/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>JCConf 2018</title>
    <link href="https://henglin31.github.io/2018/10/21/JCConf-2018/"/>
    <id>https://henglin31.github.io/2018/10/21/JCConf-2018/</id>
    <published>2018-10-21T14:26:02.000Z</published>
    <updated>2019-10-10T14:10:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年又參加了JCConf</p><p><img src="/images/jcconf-2018-001.png" width="50%" height="50%" alt="img1"></p><p><br><br><br>還在Oath攤位抽到一隻黃色小鴨</p><p><img src="/images/jcconf-2018-002.png" width="50%" height="50%" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年又參加了JCConf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jcconf-2018-001.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;還在Oath攤位抽到一隻黃色小鴨&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="conference" scheme="https://henglin31.github.io/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>用illustrator幫自己畫一個新頭像</title>
    <link href="https://henglin31.github.io/2018/07/15/%E7%94%A8illustrator%E5%B9%AB%E8%87%AA%E5%B7%B1%E7%95%AB%E4%B8%80%E5%80%8B%E6%96%B0%E9%A0%AD%E5%83%8F/"/>
    <id>https://henglin31.github.io/2018/07/15/用illustrator幫自己畫一個新頭像/</id>
    <published>2018-07-15T15:33:59.000Z</published>
    <updated>2019-10-10T15:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像</p><p>決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式<br>所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用<br>但看起來好像少了些什麼…</p><p><img src="/images/heng-001.png" width="50%" height="50%" alt="head img 1"></p><p><br><br><br>現在增加coding字型的底座，看起來就像火炬，滿符合我設定的主題</p><p><img src="/images/heng-002.png" width="50%" height="50%" alt="head img 2"></p><p>替換成功囉!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像&lt;/p&gt;
&lt;p&gt;決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式&lt;br&gt;所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用&lt;br&gt;但看起來好像少了些什麼…&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="illustrator" scheme="https://henglin31.github.io/tags/illustrator/"/>
    
  </entry>
  
  <entry>
    <title>使用視覺化來解釋數學原理的youtube - 3Blue1Brown</title>
    <link href="https://henglin31.github.io/2018/06/24/%E4%BD%BF%E7%94%A8%E8%A6%96%E8%A6%BA%E5%8C%96%E4%BE%86%E8%A7%A3%E9%87%8B%E6%95%B8%E5%AD%B8%E5%8E%9F%E7%90%86%E7%9A%84youtube-3Blue1Brown/"/>
    <id>https://henglin31.github.io/2018/06/24/使用視覺化來解釋數學原理的youtube-3Blue1Brown/</id>
    <published>2018-06-24T15:27:40.000Z</published>
    <updated>2020-01-21T17:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究<br><div class="video-container"><iframe src="//www.youtube.com/embed/spUNpyF58BY" frameborder="0" allowfullscreen></iframe></div></p><p>3Blue1Brown上還有許多數學相關視覺化影片，如：線性代數, 微積分, 類神經網路<br><div class="video-container"><iframe src="//www.youtube.com/embed/fNk_zzaMoSs" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/WUvTyaaNkzM" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/aircAruvnKk" frameborder="0" allowfullscreen></iframe></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究&lt;br&gt;&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//www.youtube.com/embed/spUNpyF58BY
      
    
    </summary>
    
    
      <category term="math" scheme="https://henglin31.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>使用 Gradle 自動初始化 Spock</title>
    <link href="https://henglin31.github.io/2018/05/20/%E4%BD%BF%E7%94%A8-Gradle-%E8%87%AA%E5%8B%95%E5%88%9D%E5%A7%8B%E5%8C%96-Spock/"/>
    <id>https://henglin31.github.io/2018/05/20/使用-Gradle-自動初始化-Spock/</id>
    <published>2018-05-20T14:23:10.000Z</published>
    <updated>2018-06-04T15:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接觸gradle是從v1.7這個版本開始的(2013年)<br>工作上則是使用v2.2版本(2014年)，開發上測試是使用junit<br>但私底下都使用Spock來測試我自己寫的程式<br>因為寫過Spock後就不會想寫junit了… 只是工作上就是規定使用junit…也只能乖乖配合</p><p>最近升級gradle順便看一下有支援哪些新的功能，發現從v2.11開始可以直接建立Spock的專案了<br><a href="https://docs.gradle.org/2.11/release-notes.html?_ga=2.65549740.32788303.1526825308-661634901.1526653677" target="_blank" rel="noopener">gradle v2.11 release-notes</a></p><p>再往前查看了一下，發現早在v2.6版開始就有支援Spock，只是沒有指令可以直接建立Spock測試，所以只能算半成品吧，直到v2.11後才算完整<br><a href="https://docs.gradle.org/2.6/release-notes.html?_ga=2.129521294.32788303.1526825308-661634901.1526653677" target="_blank" rel="noopener">gradle v2.6 release-notes</a></p><p>指令很簡單，只需打一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle init --type java-library --test-framework spock</span><br></pre></td></tr></table></figure></p><p>想到以後就不需要再自己引入Spock，太感動了<br>gradle真的是越來越方便，難怪Android會使用gradle來建立專案</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次接觸gradle是從v1.7這個版本開始的(2013年)&lt;br&gt;工作上則是使用v2.2版本(2014年)，開發上測試是使用junit&lt;br&gt;但私底下都使用Spock來測試我自己寫的程式&lt;br&gt;因為寫過Spock後就不會想寫junit了… 只是工作上就是規定使用juni
      
    
    </summary>
    
    
      <category term="gradle" scheme="https://henglin31.github.io/tags/gradle/"/>
    
      <category term="unit test" scheme="https://henglin31.github.io/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>提升Socket傳送Large file的速度</title>
    <link href="https://henglin31.github.io/2018/05/13/%E6%8F%90%E5%8D%87Socket%E5%82%B3%E9%80%81Large-file%E7%9A%84%E9%80%9F%E5%BA%A6/"/>
    <id>https://henglin31.github.io/2018/05/13/提升Socket傳送Large-file的速度/</id>
    <published>2018-05-13T15:43:53.000Z</published>
    <updated>2020-01-23T18:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在工作上遇到前端上傳large file後需再透過socket傳送給某個service處理<br>這裡的service是用C#實現，所以是client (Java) -&gt; server (C#)<br>在傳送前一開始就會拿到一個完整的byte array<br>若只是幾kb的小檔案最快的做法當然是直接<br><code>write(byte[] bytes, 0, bytes.length);</code><br>但是遇到這麼大的檔案不可能這麼做，根據經驗會爆掉的機會很高，只能分成多次寫入<br>最先想到的是用NIO的方式ByteBuffer.allocate(size)方式建立緩衝，取得SocketChannel後分批將buffer內的資料透過channel送出，想必處理速度會快很多<br>但經過測試各種方法後，發現直接取得檔案大小後直接切好buffer大小，接著操作OutputStream直接寫入的處理的速度是最快的<br>在此情境下NIO(buffer)處理比直接寫OutputStream(stream)還慢有可能是網路傳輸還是以stream方式傳輸或者與service方的socket server實現的方式有關吧(server端是C#實現)…<br>若client和server都是使用Java感覺應該會是NIO略勝一籌</p><p>其實這個做法其實跟Java本身提供的BufferedOutputStream做法一樣<br>只是不需要另外檢查buffer是否寫滿(因為這個做法在一開始就知道要切到哪一個byte)<br>也少了一層FilterOutputStream (它們的轉換關係 BufferedOutputStream -&gt; FilterOutputStrean -&gt; OutputStream)<br>而是選擇直接操作OutputStream，所以才可以做到如此快速</p><p>提醒一下<br>這個方式比較不適合用在”讀檔”後使用socket傳送大檔案<br>因為讀檔可以邊讀邊傳(寫入)可以有效降低memory的使用量，所以直接串BufferedOutputStream<br>或者使用ByteBuffer串channel，畢竟使用NIO從硬碟讀取大的檔案速度會比傳統Java I/O快很多</p><p>最終的程式碼如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BYTE_BUF_SIZE = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sendCmd</span><span class="params">(String ip, <span class="keyword">int</span> port, <span class="keyword">byte</span>[] byteArray)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = <span class="keyword">true</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> bufSize = BYTE_BUF_SIZE;<span class="comment">// buffer limit</span></span><br><span class="line">    <span class="keyword">int</span> byteArrayLength = byteArray.length;</span><br><span class="line">    <span class="keyword">int</span> writeCount = byteArrayLength / bufSize;<span class="comment">// how many times to write</span></span><br><span class="line">    <span class="keyword">int</span> byteRemain = byteArrayLength % bufSize;<span class="comment">// how many bytes are left</span></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;writeCount; count++)&#123;</span><br><span class="line">            out.write(byteArray, offset, bufSize);</span><br><span class="line">            offset += bufSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(byteRemain &gt; <span class="number">0</span>)&#123;<span class="comment">// have the remaining bytes</span></span><br><span class="line">            out.write(byteArray, offset, byteRemain);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"use socket send command fail!!, ip: &#123;&#125;, port: &#123;&#125; exceptionMsg:&#123;&#125;"</span>, ip, port, e);</span><br><span class="line">        isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                logger.warn(<span class="string">"socket close fail: &#123;&#125;"</span>, e1);</span><br><span class="line">                isSuccess = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作上遇到前端上傳large file後需再透過socket傳送給某個service處理&lt;br&gt;這裡的service是用C#實現，所以是client (Java) -&amp;gt; server (C#)&lt;br&gt;在傳送前一開始就會拿到一個完整的byte array&lt;br&gt;若只是
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>你真的了解Java中的Thread運作嗎？ - 容易讓人誤解的synchronized method</title>
    <link href="https://henglin31.github.io/2018/04/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84Thread%E9%81%8B%E4%BD%9C%E5%97%8E%EF%BC%9F-%E5%AE%B9%E6%98%93%E8%AE%93%E4%BA%BA%E8%AA%A4%E8%A7%A3%E7%9A%84synchronized-method/"/>
    <id>https://henglin31.github.io/2018/04/29/你真的了解Java中的Thread運作嗎？-容易讓人誤解的synchronized-method/</id>
    <published>2018-04-29T14:11:28.000Z</published>
    <updated>2020-02-09T22:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午聽到討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”<br>前面敘述是OK的，但最後一句話聽起來怪怪的…“thread是鎖method的”，這個說法有點不妥</p><p>在某個method上面增加synchronized很直覺的會認為只是會鎖此method，但若實際寫code去驗證的話，在使用javap查看.class檔案會發現不是針對method鎖而是將整個object當作鎖，與synchronized(this)幾乎是一樣的效果，反之若使用某個object當作key如synchronized(key)，此時key就可以當作進入區間的唯一鑰匙，就看誰先搶到進入</p><p>以另外一個角度來看，Java的wait(), notify(), notifyAll()都是定義在Object，而不是在thread上，如果thread在sychronized區塊不是針對Object做鎖的動作，那它就需要一個唯一可以當作鎖的依據，可以在sychronized區塊某些情況下釋放鎖給其他thread，很明顯thread中是沒有定義這個東西，還是需要透過Object內的wait()去blocked和notify()做wakeup thread</p><p>很多時候程式實際運作與自己想像是有落差的，不論是書上寫的或者在技術blog上讀到的都不一定是對的，只有自己嘗試寫code執行過才會知道</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天下午聽到討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="thread" scheme="https://henglin31.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>從無到有DIY chart (二)</title>
    <link href="https://henglin31.github.io/2018/04/14/%E5%BE%9E%E7%84%A1%E5%88%B0%E6%9C%89DIY-chart-%E4%BA%8C/"/>
    <id>https://henglin31.github.io/2018/04/14/從無到有DIY-chart-二/</id>
    <published>2018-04-14T14:17:36.000Z</published>
    <updated>2019-10-22T04:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下<br><html>    <head>        </head>    <body>        <div align="center">            <h2>Chart</h2>            <div>                <canvas id="chart" width="300" height="150"></canvas>            </div>        </div>    </body></html><script language="javascript">class Chart{    constructor(params){    this._LINE_TENSION = 0.2    this._LINE_WIDTH_ORI = 2;    this._LINE_WIDTH_FOCUS = 5;    this._COLOR_GRAY = 'gray';    this._COLOR_WHITE = 'white';        this._id = params.id;    this._matrix = params.matrix;    this._radius = params.radius;    this._dataSet = [];    this._curveDataSet = [];        this._canvas;    this._canvasWidth;    this._canvasHeight;    this._ctx;    this._preFocusPoint;        this._Coordinate;        this._init();    }    _init(){        this._canvas = document.getElementById(this._id);        if(!this._canvas.getContext){            throw "can't get canvas context!";        }        this._canvasWidth = this._canvas.width;        this._canvasHeight = this._canvas.height;        this._ctx = this._canvas.getContext('2d');            this._initCoordinate();        this._initDataSet();        this._initCurveLines();        this._bindMouseEvent();        this.draw();    }        _initCoordinate(){        this._Coordinate = new Coordinate({            canvas: this._canvas,            matrix: this._matrix        });    }    _initDataSet(){        for(const [index, point] of this._matrix.entries()){            var reverseY = this._canvasHeight - point[1];            this._dataSet.push({                index: index,                x: point[0],                y: reverseY,                color: this._randomColor()            });        }    }        _initFrame(){        const rect = this._Coordinate.getChartBoundingRect();        this._drawRect({            x: 0,            y: 0,            width: this._canvasWidth,            height: this._canvasHeight,            lineWidth: this._LINE_WIDTH_ORI,            color: this._COLOR_GRAY        });                this._drawRect({            x: 0,            y: 0,            width: this._canvasWidth,            height: this._canvasHeight,            lineWidth: this._LINE_WIDTH_ORI,            color: this._COLOR_GRAY        });    }        _initLines(){        this._ctx.beginPath();        const dataLength = this._dataSet.length;        if(dataLength < 2) return;        if(dataLength == 2){            const firstPoint = this._dataSet[0];            const secondPoint = this._dataSet[1];            this._ctx.moveTo(firstPoint.x, firstPoint.y);            this._ctx.lineTo(secondPoint.x, secondPoint.y);            this._ctx.stroke();            return;        }                for(const [index, point] of this._dataSet.entries()){            if(index == 0){                this._ctx.moveTo(point.x, point.y);                continue;            }            const preControlPoint = this._curveDataSet[index - 1];            const controlPoint = this._curveDataSet[index];            this._ctx.bezierCurveTo(                preControlPoint.next.x, preControlPoint.next.y,                 controlPoint.pre.x, controlPoint.pre.y,                 point.x, point.y            );                    }        this._ctx.stroke();    }        _showControlPoint(){        for(const [index, point] of this._dataSet.entries()){            if(index == 0){                continue;            }            const preControlPoint = this._curveDataSet[index - 1];            const controlPoint = this._curveDataSet[index];                        this._drawCircle({x: preControlPoint.next.x, y: preControlPoint.next.y, radius: 2, lineWidth: 1, color: preControlPoint.oriPoint.color});            this._drawCircle({x: controlPoint.pre.x,     y: controlPoint.pre.y,     radius: 2, lineWidth: 1, color: controlPoint.oriPoint.color});                        this._ctx.stroke();        }    }        _initCircles(){        const _self = this;        this._dataSet.forEach((point) => {            _self._drawCircle({                x: point.x,                 y: point.y,                 radius: _self._radius,                 lineWidth: _self._LINE_WIDTH_ORI,                color: point.color            });        });    }        _initCurveLines(){        const dataLength = this._dataSet.length;        /*            less than three points don't need to use curve        */        if(dataLength <= 2) return;        for(let index=1; index<(dataLength-1); index++){            const prePoint = this._dataSet[index - 1];            const currentPoint = this._dataSet[index];            const nextPoint = this._dataSet[index + 1];            /*                use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale            */            const deltaX = nextPoint.x - prePoint.x;            const deltaY = nextPoint.y - prePoint.y;            const distance = this._distance(prePoint, nextPoint);            const cos = deltaX / distance;            const sin = deltaY / distance;            /*                calc current point distance between two points pre and next            */            const preRelativeDistance = this._distance(prePoint, currentPoint);            const nextRelativeDistance = this._distance(currentPoint, nextPoint);            /*                calc actual offset by current point and pre point                ps: actual offset = current point - (scale * two point distance * tension)            */            const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);            const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);            /*                calc actual offset by current point and next point            */            const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);            const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);            /*                            */            this._curveDataSet.push({                oriPoint: currentPoint,                pre: {x: preControlPointX, y: preControlPointY},                 next: {x: nextControlPointX, y: nextControlPointY},            });                    }            const firstPoint = this._dataSet[0];        const secondCurvePoint = this._curveDataSet[1];        this._curveDataSet.unshift({            oriPoint: firstPoint,            next: {                x: (firstPoint.x + secondCurvePoint.pre.x) / 2,                y: (firstPoint.y + secondCurvePoint.pre.y) / 2            }        });                const lastPoint = this._dataSet[dataLength - 1];        const secondLastCurvePoint = this._curveDataSet[dataLength - 2];        this._curveDataSet.push({            oriPoint: lastPoint,            pre: {                x: (lastPoint.x + secondLastCurvePoint.next.x) / 2,                 y: (lastPoint.y + secondLastCurvePoint.next.y) / 2            }        });    }        _bindMouseEvent(){        const _self = this;        this._canvas.addEventListener("mousemove", (event) => {            const rect = _self._canvas.getBoundingClientRect();            const x = event.clientX - rect.left;            const y = event.clientY - rect.top;            _self._findNearPointByMouse({x: x, y: y});        });    }        _randomColor(){        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);    }        _drawRect(params){        this._ctx.lineWidth = params.lineWidth;        this._ctx.strokeStyle = params.color;        this._ctx.beginPath();        this._ctx.rect(params.x, params.y, params.width, params.height);        this._ctx.stroke();    }        _drawLine(point1, point2){        this._ctx.lineWidth = point2.lineWidth;        this._ctx.strokeStyle = point2.color;        this._ctx.beginPath();        this._ctx.moveTo(point1.x, point1.y);        this._ctx.lineTo(point2.x, point2.y);        this._ctx.stroke();    }    _drawCircle(point){        this._ctx.lineWidth = point.lineWidth;        this._ctx.beginPath();        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);        this._ctx.strokeStyle = point.color;        this._ctx.fillStyle  = point.color;        this._ctx.fill();        this._ctx.stroke();    }        _drawFocusPoint(point){        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});    }        _findNearPointByMouse(mousePos){        let minDistancePoint;        let minDistance = Number.MAX_VALUE;        for(var index=0, size= this._dataSet.length; index<size; index++){            const currentPos = this._dataSet[index];            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);                        if(minDistance > distanceBetweenTwoPoints){                minDistancePoint = currentPos;                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);            }        }        if(!this._preFocusPoint){            this._drawFocusPoint(minDistancePoint);            this._preFocusPoint = minDistancePoint;            return;        }        /*            if pre point isn't self, it's need to render        */        if(this._preFocusPoint.index !== minDistancePoint.index){            this.render();            this._drawFocusPoint(minDistancePoint);        }        this._preFocusPoint = minDistancePoint;    }        _distance(point1, point2){        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));    }        _clear(){        this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);    }        /* public */    draw(){        this._initFrame();        this._initLines();        this._initCircles();    }        render(){        this._clear();        this.draw();        console.log('render');    }    printDataSet(){        console.log('dataSet', this._dataSet);    }}class Coordinate{    constructor(params){        this._LEFT_OFFSET = 20;        this._BOTTOM_OFFSET = 20;        this._TOP_OFFSET = 10;        this._RIGHT_OFFSET = 10;                this._canvas = params.canvas;        this._oriMatrix = params.matrix;                this._chartBoundingRect;        this._xAxis;        this._yAxis;                this._init();    }        _init(){        this._initChartBoundingRect();        this._initXAxisAndYAxis();    }        _initChartBoundingRect(){        const oriCanvasRect = this._canvas.getBoundingClientRect();        //console.log(oriCanvasRect);        this._chartBoundingRect = {            left: 0 + this._LEFT_OFFSET,            top: 0 + this._TOP_OFFSET,            bottom: oriCanvasRect.height - this._BOTTOM_OFFSET,            right: oriCanvasRect.width - this._RIGHT_OFFSET,                        width: oriCanvasRect.width - this._LEFT_OFFSET - this._RIGHT_OFFSET,            height: oriCanvasRect.height - this._BOTTOM_OFFSET - this._TOP_OFFSET,        }        console.log(this._chartBoundingRect);    }    _initXAxisAndYAxis(){        let xMax = Number.MIN_VALUE;        let xMin = Number.MAX_VALUE;                let yMax = Number.MIN_VALUE;        let yMin = Number.MAX_VALUE;                this._oriMatrix.forEach((point) => {            const x = point[0];            const y = point[1];                        xMax = Math.max(xMax, x);            xMin = Math.min(xMin, x);                        yMax = Math.max(yMax, y);            yMin = Math.min(yMin, y);        });                const xNormal = (xMax - xMin);        const yNormal = (yMax - yMin);    }        getChartBoundingRect(){        return this._chartBoundingRect;    }}(function(global){    const canvasId = 'chart';    const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];    const radius = 4;    const chart = new Chart({        id: canvasId,         matrix: matrix,        radius: radius    });    chart.draw();    chart.printDataSet();    console.log('chart', chart);    console.log(chart._id);})(this);</script></p><p>主要增加的程式碼如下，參考chart.js繪製曲線的方式，自己試做看看，主要是針對點與點之間距離的計算出bezier curve的control point<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index=<span class="number">1</span>; index&lt;(dataLength<span class="number">-1</span>); index++)&#123;</span><br><span class="line">    <span class="keyword">const</span> prePoint = <span class="keyword">this</span>._dataSet[index - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> currentPoint = <span class="keyword">this</span>._dataSet[index];</span><br><span class="line">    <span class="keyword">const</span> nextPoint = <span class="keyword">this</span>._dataSet[index + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> deltaX = nextPoint.x - prePoint.x;</span><br><span class="line">    <span class="keyword">const</span> deltaY = nextPoint.y - prePoint.y;</span><br><span class="line">    <span class="keyword">const</span> distance = <span class="keyword">this</span>._distance(prePoint, nextPoint);</span><br><span class="line">    <span class="keyword">const</span> cos = deltaX / distance;</span><br><span class="line">    <span class="keyword">const</span> sin = deltaY / distance;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        calc current point distance between two points pre and next</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> preRelativeDistance = <span class="keyword">this</span>._distance(prePoint, currentPoint);</span><br><span class="line">    <span class="keyword">const</span> nextRelativeDistance = <span class="keyword">this</span>._distance(currentPoint, nextPoint);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        calc actual offset by current point and pre point</span></span><br><span class="line"><span class="comment">        ps: actual offset = current point - (scale * two point distance * tension)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> preControlPointX = currentPoint.x - (cos * preRelativeDistance * <span class="keyword">this</span>._LINE_TENSION);<span class="comment">// _LINE_TENSION = 0.2</span></span><br><span class="line">    <span class="keyword">const</span> preControlPointY = currentPoint.y - (sin * preRelativeDistance * <span class="keyword">this</span>._LINE_TENSION);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        calc actual offset by current point and next point</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * <span class="keyword">this</span>._LINE_TENSION);</span><br><span class="line">    <span class="keyword">const</span> nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * <span class="keyword">this</span>._LINE_TENSION);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>._curveDataSet.push(&#123;</span><br><span class="line">        oriPoint: currentPoint,</span><br><span class="line">        pre: &#123;<span class="attr">x</span>: preControlPointX, <span class="attr">y</span>: preControlPointY&#125;, </span><br><span class="line">        next: &#123;<span class="attr">x</span>: nextControlPointX, <span class="attr">y</span>: nextControlPointY&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 繪製出曲線<br>其中cp1x, cp1y 第一個控制點，而cp2x, cp2y 第二個控制點，最後一組參數x, y 為繪製的終點座標</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [index, point] <span class="keyword">of</span> <span class="keyword">this</span>._dataSet.entries())&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._ctx.moveTo(point.x, point.y);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> preControlPoint = <span class="keyword">this</span>._curveDataSet[index - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> controlPoint = <span class="keyword">this</span>._curveDataSet[index];</span><br><span class="line">    <span class="keyword">this</span>._ctx.bezierCurveTo(</span><br><span class="line">        preControlPoint.next.x, preControlPoint.next.y, </span><br><span class="line">        controlPoint.pre.x, controlPoint.pre.y, </span><br><span class="line">        point.x, point.y</span><br><span class="line">    );            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下&lt;br&gt;
&lt;html&gt;
    &lt;head&gt;
    
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div align=&quot;center&quot;&gt;
            &lt;h2&gt;Chart&lt;/h2&gt;
  
      
    
    </summary>
    
    
      <category term="js" scheme="https://henglin31.github.io/tags/js/"/>
    
  </entry>
  
</feed>
