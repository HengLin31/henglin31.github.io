<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HengLin31</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://henglin31.github.io/"/>
  <updated>2018-03-25T11:17:24.000Z</updated>
  <id>https://henglin31.github.io/</id>
  
  <author>
    <name>Heng Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>標準常態分佈的機率密度函數</title>
    <link href="https://henglin31.github.io/2018/03/24/%E6%A8%99%E6%BA%96%E5%B8%B8%E6%85%8B%E5%88%86%E4%BD%88%E7%9A%84%E6%A9%9F%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B8/"/>
    <id>https://henglin31.github.io/2018/03/24/標準常態分佈的機率密度函數/</id>
    <published>2018-03-24T14:03:21.000Z</published>
    <updated>2018-03-25T11:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子在做SPC逆向工程…<br>為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念<br>皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果<br>為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差…</p><p>下一個任務是需要產生機率密度函數去看資料的離散程度…<br>至於什麼是常態分佈，可以到<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83" target="_blank" rel="noopener">常態分佈wiki</a>上看，應該會比我自己說還要詳細<br>一直很好奇為什麼要定義成鐘型，看了下面的youtube影片就可以了解，原來是大自然的一種規律(巧合？)<br><div class="video-container"><iframe src="//www.youtube.com/embed/4HpvBZnHOVI" frameborder="0" allowfullscreen></iframe></div><br>球從中間落下（期望值的位置），最終形成的結果接近於鐘型</p><p>上面簡介完了，接著進入主題，想要深入了解標準常態分佈的機率密度函數的公式，如下：<br>公式： $ f(x) = {1 \over \sqrt{2\pi}}\exp(-{x^2 \over 2}) $</p><p>如果直接從wiki看完公式後，很容易實作出來，只是我更想知道公式背後的原理<br>以下是我查完書和上網查完資料後，根據自己理解所歸納的結果</p><p>先看 $ f(x) = \exp(-{x^2}) $ 這部分：</p><p>那又為什麼要使用 $ -x^2 $ 呢？<br>$ x^2 $是開口向上的鐘型形狀，如下圖所示(以下圖片都是透過Maxima產生)：<br><img src="/images/st-001.png" alt="x^2"><br>但我們要的鐘型是開口向下，想要開口向下只需要乘上-1，即 $ -x^2 $<br><img src="/images/st-002.png" alt="-x^2"></p><p>為什麼要使用$ \exp(-{x^2}) $呢？<br>因為 $ -x^2 $ 的函數是落在第二和第三象限，若需要讓函數在第一和第四象限需要弄成指數型函數<br>以下是 $ 3^{-x^2} $的函數圖形<br><img src="/images/st-003.png" alt="x^2"><br>其實任何常數指數為 $ -x^2 $ 都為鐘型圖形，如下圖為$ 100^{-x^2} $的函數圖形<br><img src="/images/st-004.png" alt="x^2"></p><p>雖然取任何常數都可以形成鐘型，那為什麼要取exp當作底呢？<br>主要是需要它的部分特性，主要有以下五點：</p><ol><li>左右對稱(以0為中心點，常數c與-c的值會得到相同值)</li><li>x軸為0時(中心點)， $ f(0) $ 會取得最大值(鐘型的最高點)</li><li>隨著x值逐漸遠離0時(中心點)，值會漸漸縮小，且值“不會是負的”(這點很重要，因為機率值不可為負的)</li><li>當x趨近於無窮大或趨近於負無窮大時，直趨近於0</li><li>比較好做積分…(連續型的機率密度函數是透過計算面積的方式去獲得機率區間範圍內的機率所以要做積分)</li></ol><p>但是只有 $ f(x) = \exp(-{x^2}) $ 是不夠的，因為對機率來說，總體 $ P(\Omega) = 1 $<br>所以從負無限大到無限大做積分整個 $ f(x) $的總面積必須是1<br>嘗試對 $ \exp(-{x^2}) $從負無窮大到無窮大做積分，得到以下結果<br><img src="/images/st-005.png" alt="x^2"><br>竟然是 $ \sqrt{\pi} $ ，所以要讓值為1的方法就是除以 $ \sqrt{\pi} $<br>最終會得到 $ f(x) = {1 \over \sqrt{\pi}}\exp(-{x^2}) $<br>我們得到了常態分佈的機率密度函數，但還不能稱為“標準”常態分佈的機率密度函數<br>因為要達到“標準”的要求還需要有以下三個特性：</p><ol><li>期望值( $ \mu $ )為0</li><li>變異數( $ Var $ )為1</li><li>標準差( $ \sigma $ )為1</li></ol><p>記做 $ N(\mu, \sigma) $， 求 $ N(0, 1) $<br>但前面的機率分佈函數是 $ N(0, {1 \over \sqrt{2}}) = {1 \over \sqrt{\pi}}\exp(-{x^2}) $不是我們要的</p><p>我們從wiki可以知道連續型隨機變數求期望值和變異數的公式為:</p><p>$ E[X] = \int xf(x)dx $<br>$ Var(x) = E[(x-\mu)^2] $</p><p>因為 $ E[X] = 0 $ ，所以 $ Var(x) = E[x^2] $</p><p>先令$ g(x) = af(ax) $，其中a是一個大於零的常數，我們需要求出a值<br>a值需要滿足 $ xg(x) = E(x) $ 積分為0且 $ x^2g(x) = Var(x) $ 積分等於1<br>$ x^2g(x) $ 積分後求得 $ 1 \over {2a^2} $<br>最終得到$ a = {1 \over \sqrt{2}} $則 $ Var(x) = 1 $ 且 $ E[X] = 0 $<br>也可以求得 $ \sigma = \sqrt{Var(x)} = 1 $<br>$ N(0, 1) = {1 \over \sqrt{2}} f({x \over \sqrt{2}}) $ 帶入公式後得到 $ f(x) = {1 \over \sqrt{2\pi}}\exp(-{x^2 \over 2}) $</p><p>這樣就符合“標準”常態機率密度函數</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前陣子在做SPC逆向工程…&lt;br&gt;為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念&lt;br&gt;皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果&lt;br&gt;為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差…&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 如何避免重複執行特定jar</title>
    <link href="https://henglin31.github.io/2018/03/17/Linux-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E8%A4%87%E5%9F%B7%E8%A1%8C%E7%89%B9%E5%AE%9Ajar/"/>
    <id>https://henglin31.github.io/2018/03/17/Linux-如何避免重複執行特定jar/</id>
    <published>2018-03-17T13:00:34.000Z</published>
    <updated>2018-03-17T16:04:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>因為Linux是真正多人多工，若是在不同電腦上遠端登入<br>執行同一個特定jar，就會造成重複執行<br>所以在一般情況下，會寫script 做成 service<br>再透過 start stop restart 去執行</p><p>但是目前我遇到的問題是，需要幫還不熟悉linux同事寫一個script<br>讓他可以執行他寫的jar，需求上是不允許重複執行又不要做成 service<br>而且若發現JVM執行中，則需要刪除舊的JVM後重新執行</p><p>所以寫個這個script，去做刪除JVM的動作</p><figure class="highlight shell"><figcaption><span>kill jar JVM, if exist .sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID=$(ps aux | grep jar-[0-9] | awk '&#123;print $2&#125;')</span><br><span class="line">echo "PID: "$PID</span><br><span class="line">if [ -z $PID ]; then</span><br><span class="line">    echo "not exist PID"</span><br><span class="line">else</span><br><span class="line">    echo "kill PID: "$PID</span><br><span class="line">    kill -9 $PID</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>第1行 ps aux 是找出所有user目前執行中的process<br>接著使用 grep 找出特定的process，因為這個jar會帶版號<br>例如： jar-1.1.jar 或是升級後 jar-1.2.jar<br>所以多判斷帶版號的regex<br>最後執行 awk 印出第2欄（因為第2欄是process的PID）<br>第3行是檢查PID是否為空字串<br>若PID不是空字串就表示JVM已經存在需要執行第7行去強制刪除JVM</p><p>這樣一個簡單的script就完成了，現在同事只需要在執行jar前呼叫此.sh檔<br>就可以避免重複執行了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因為Linux是真正多人多工，若是在不同電腦上遠端登入&lt;br&gt;執行同一個特定jar，就會造成重複執行&lt;br&gt;所以在一般情況下，會寫script 做成 service&lt;br&gt;再透過 start stop restart 去執行&lt;/p&gt;
&lt;p&gt;但是目前我遇到的問題是，需要幫還不
      
    
    </summary>
    
    
      <category term="shell" scheme="https://henglin31.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>使用 WeakReference 解決 Android 發生 memory leak 問題</title>
    <link href="https://henglin31.github.io/2018/03/10/%E4%BD%BF%E7%94%A8-WeakReference-%E8%A7%A3%E6%B1%BA-Android-%E7%99%BC%E7%94%9F-memory-leak-%E5%95%8F%E9%A1%8C/"/>
    <id>https://henglin31.github.io/2018/03/10/使用-WeakReference-解決-Android-發生-memory-leak-問題/</id>
    <published>2018-03-10T13:03:49.000Z</published>
    <updated>2018-03-17T16:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>源由:<br>前陣子幫離職的同事改寫他的Android APP<br>因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash…<br>所以需要常常重啟APP</p><p>在Android Studio上觀察了一下memory<br>執行了一段時間後發現記憶體會不正常增長，就算手動執行GC也無法釋放<br>初步研判是發生了memory leak<br>馬上做heap dump<br>再使用MAT稍微分析了一下</p><p>果然…<br>activity的context沒有被正常釋放掉<br>主因是activity將自身的context傳給了AsyncTask去執行跟Server拿資料的任務<br>因為此APP是屬於Web Service，需要頻繁的執行request<br>所以同時間會產生多個AsyncTask<br>最終造成多個AsyncTask需等待其他AsyncTask完成任務<br>但又佔用activity的context，所以activity無法釋放</p><p>簡單的說就是AsyncTask的生命週期比activity的生命週期還要長<br>所以activity沒辦法回收memory</p><p>確認問題的原因後，接下來就好辦了</p><p>首先是解決activity context無法釋放的問題<br>在這裡我是將傳入activity context宣告成WeakReference<br>WeakReference是Java的弱引用，可以讓 activityContext 可以被系統正常GC<br>不會因AsyncTask長期佔用 activityContext 造成 memory 無法釋放的問題發生</p><figure class="highlight java"><figcaption><span>WeakReference 使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Context&gt; contextRef = <span class="keyword">new</span> WeakReference&lt;Context&gt;(activityContext);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != contextRef.get())&#123;<span class="comment">//判斷有無被系統GC</span></span><br><span class="line">    Context context = contextRef.get();</span><br><span class="line">    <span class="comment">//可以執行到這，就表示 context 還未被系統回收，可繼續做接下來的任務</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是最佳的做法應該是不要隨意傳遞activity的context，因為他的生命週期非常短暫<br>若真的需要使用context的話應該使用application context，而不是activity context<br>因為application context是APP的context，所以不像activity context一直不斷被創建和釋放<br>只是application context不能用來更新UI</p><p>若想使用activity context去更新UI的話，也應該要回歸到activity內部執行<br>而不是讓外部的Object直接引用，無形中提高了memory leak發生的風險</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源由:&lt;br&gt;前陣子幫離職的同事改寫他的Android APP&lt;br&gt;因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash…&lt;br&gt;所以需要常常重啟APP&lt;/p&gt;
&lt;p&gt;在Android Studio上觀察了一下memory&lt;br&gt;執行了一段時間後發現記憶體會不正
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="android" scheme="https://henglin31.github.io/tags/android/"/>
    
      <category term="memory leak" scheme="https://henglin31.github.io/tags/memory-leak/"/>
    
  </entry>
  
  <entry>
    <title>比較好的nested map寫法</title>
    <link href="https://henglin31.github.io/2018/03/03/%E6%AF%94%E8%BC%83%E5%A5%BD%E7%9A%84nested-map%E5%AF%AB%E6%B3%95/"/>
    <id>https://henglin31.github.io/2018/03/03/比較好的nested-map寫法/</id>
    <published>2018-03-03T15:02:41.000Z</published>
    <updated>2018-03-17T16:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code<br>仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group</p><p>輸入資料為n*m的matrix<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] dataMatrix = &#123;&#123;<span class="string">"level 1"</span>, <span class="string">"level 2"</span>, <span class="string">"level 3"</span>, <span class="string">"data 1"</span>&#125;,</span><br><span class="line">                         &#123;<span class="string">"level 1"</span>, <span class="string">"level 2"</span>, <span class="string">"level 3"</span>, <span class="string">"data 2"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p><p>但是原始的code寫的滿複雜的，為了方便說明就簡化一下，寫成程式碼 1</p><figure class="highlight java"><figcaption><span>程式碼 1:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class="line">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String level1 = <span class="string">"level 1"</span>;</span><br><span class="line">String level2 = <span class="string">"level 2"</span>;</span><br><span class="line">String level3 = <span class="string">"level 3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(level1))&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.get(level1).get(level2).put(level3, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(level1).put(level2, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.get(level1).get(level2).put(level3, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    map.put(level1, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    <span class="keyword">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.get(level1).get(level2).put(level3, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(level1).put(level2, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.get(level1).get(level2).put(level3, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">            map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(level1).get(level2).get(level3).get(<span class="number">0</span>));</span><br><span class="line">System.out.println(map.get(level1).get(level2).get(level3).get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>程式碼 1 的寫法用了三層的巢狀，也包含許多重複的判斷邏輯，不但不容易閱讀，也不利於後續的維護和修改…<br>看到這段程式碼時，當下真的有種想幫他重構的衝動<br>但想一想此段code沒有bug，只是醜了點，若重構既花時間也沒有實質效益<br>最終只在程式碼 1 的上方增加註解，寫了個比較好的作法，就是下方的程式碼 2</p><figure class="highlight java"><figcaption><span>程式碼 2:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class="line">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String level1 = <span class="string">"level 1"</span>;</span><br><span class="line">String level2 = <span class="string">"level 2"</span>;</span><br><span class="line">String level3 = <span class="string">"level 3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(level1)) &#123;</span><br><span class="line">    map.put(level1, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!map.get(level1).containsKey(level2)) &#123;</span><br><span class="line">    map.get(level1).put(level2, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!map.get(level1).get(level2).containsKey(level3)) &#123;</span><br><span class="line">    map.get(level1).get(level2).put(level3, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.get(level1).get(level2).get(level3).add(<span class="string">"data 1"</span>);</span><br><span class="line">map.get(level1).get(level2).get(level3).add(<span class="string">"data 2"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(level1).get(level2).get(level3).get(<span class="number">0</span>));</span><br><span class="line">System.out.println(map.get(level1).get(level2).get(level3).get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>程式碼 2 的寫法可以輕鬆地在執行過程中自動做初始化<br>因為第7~9行就可以將level 1為null的可以性完全排除，在第7行後level 1就不可能是null<br>以此類推第10行和第13行都可以自動幫level 2和level 3做初始化，所以後面只需專注於放資料即可<br>不管之後增加幾層map都不需要寫成複雜的巢狀判斷式</p><p>隔天想了一下，如果沒有什麼特殊需求，其實只需要將三層的key組合成一個唯一的字串即可…<br>就如同下方的程式碼 3</p><figure class="highlight java"><figcaption><span>程式碼 3:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map&lt;level 1 + level 2 + level 3, List&lt;data&gt;&gt;</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">String level1 = <span class="string">"level 1"</span>;</span><br><span class="line">String level2 = <span class="string">"level 2"</span>;</span><br><span class="line">String level3 = <span class="string">"level 3"</span>;</span><br><span class="line"></span><br><span class="line">String combinKey = level1 + level2 + level3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!map.put(combinKey)) &#123;</span><br><span class="line">    map,put(combinKey, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.get(combinKey).add(<span class="string">"data 1"</span>);</span><br><span class="line">map.get(combinKey).add(<span class="string">"data 2"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(combinKey).get(<span class="number">0</span>));</span><br><span class="line">System.out.println(map.get(combinKey).get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>若是能夠使用 java 8 的 stream 的話就更簡單了，如同下方的程式碼 4</p><figure class="highlight java"><figcaption><span>程式碼 4:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(dataMatrix).collect(</span><br><span class="line">                Collectors.toMap(</span><br><span class="line">                    kv -&gt; kv[<span class="number">0</span>] + kv[<span class="number">1</span>] + kv[<span class="number">2</span>],</span><br><span class="line">                    kv -&gt; Lists.newArrayList(kv[<span class="number">3</span>]),</span><br><span class="line">                    (newVal, oldVal) -&gt; &#123;</span><br><span class="line">                        newVal.addAll(oldVal);</span><br><span class="line">                        <span class="keyword">return</span> newVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            );</span><br></pre></td></tr></table></figure><p>結論：<br>我一直認為寫出簡潔易讀且好維護的程式碼是身為一個軟體開發者該有的素養<br>不是只求程式會跑就好，這樣只會累積一些不必要的技術債…<br>所以我覺得每個開發者，都應該買本“clean code 無瑕的程式碼 + 番外篇”來讀一讀<br>時時提醒自己不要埋地雷給別人踩，顯現自己的專業</p><p>此時想起我放在辦公室的clean code一書被同事們借來借去，現在也不知道流浪到哪位同事的辦公桌上…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code&lt;br&gt;仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group&lt;/p&gt;
&lt;p&gt;輸入資料為n*m的matrix&lt;br&gt;&lt;figure class=&quot;highlight jav
      
    
    </summary>
    
    
      <category term="java" scheme="https://henglin31.github.io/tags/java/"/>
    
      <category term="clean code" scheme="https://henglin31.github.io/tags/clean-code/"/>
    
  </entry>
  
  <entry>
    <title>更換hexo themes</title>
    <link href="https://henglin31.github.io/2018/02/20/%E6%9B%B4%E6%8F%9Bhexo-themes/"/>
    <id>https://henglin31.github.io/2018/02/20/更換hexo-themes/</id>
    <published>2018-02-20T13:41:43.000Z</published>
    <updated>2018-03-17T16:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>稍微嘗試更換hexo themes<br>雖然原生的landscape theme的介面已經很簡潔<br>但還是想要更精簡一些</p><p>比較了幾個比較知名的theme<br>最後決定使用yilia這個theme<br>介面簡潔乾淨而且RWD的效果也不錯<br>除了不支援舊版IE以外沒什麼好挑惕的<br>最後當然要幫作者github上的yilia專案加顆星<br>也順便學習設定disqus當作留言板</p><p>今天是連假的最後一天<br>這幾天有空的時候就練習Git的操作<br>感覺不賴</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;稍微嘗試更換hexo themes&lt;br&gt;雖然原生的landscape theme的介面已經很簡潔&lt;br&gt;但還是想要更精簡一些&lt;/p&gt;
&lt;p&gt;比較了幾個比較知名的theme&lt;br&gt;最後決定使用yilia這個theme&lt;br&gt;介面簡潔乾淨而且RWD的效果也不錯&lt;br&gt;除了不支
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://henglin31.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇Blog，從SVN到Git</title>
    <link href="https://henglin31.github.io/2018/02/16/%E7%AC%AC%E4%B8%80%E7%AF%87Blog%EF%BC%8C%E5%BE%9ESVN%E5%88%B0Git/"/>
    <id>https://henglin31.github.io/2018/02/16/第一篇Blog，從SVN到Git/</id>
    <published>2018-02-16T09:28:42.000Z</published>
    <updated>2018-02-18T08:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是大年初一<br>趁春節的這段時間，來讀之前買的 O’Reilly “版本控制使用Git”</p><p>在這之前都是使用SVN來管理自己的source code<br>直到去年我的MacBook Pro的SSD硬碟無預期掛掉…<br>近五年的code就跟著一起消失了…</p><p>所以今年改使用Git管理，因為可以免費將code上傳到github上儲存<br>至少下次硬碟壞掉時，code不會跟著蒸發</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是大年初一&lt;br&gt;趁春節的這段時間，來讀之前買的 O’Reilly “版本控制使用Git”&lt;/p&gt;
&lt;p&gt;在這之前都是使用SVN來管理自己的source code&lt;br&gt;直到去年我的MacBook Pro的SSD硬碟無預期掛掉…&lt;br&gt;近五年的code就跟著一起消失了…
      
    
    </summary>
    
    
      <category term="Blog" scheme="https://henglin31.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
