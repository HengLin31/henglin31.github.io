{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/chart-diy-001.png","path":"images/chart-diy-001.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/googlef6c955fb09e49d48.html","path":"googlef6c955fb09e49d48.html","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"source/images/app-icon-002.png","path":"images/app-icon-002.png","modified":0,"renderable":0},{"_id":"source/images/chart-diy-002.png","path":"images/chart-diy-002.png","modified":0,"renderable":0},{"_id":"source/images/jcconf-2018-001.png","path":"images/jcconf-2018-001.png","modified":0,"renderable":0},{"_id":"source/images/jcconf-2018-002.png","path":"images/jcconf-2018-002.png","modified":0,"renderable":0},{"_id":"source/images/jcconf-2019-001.png","path":"images/jcconf-2019-001.png","modified":0,"renderable":0},{"_id":"source/images/st-005.png","path":"images/st-005.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"source/images/app-icon-001.png","path":"images/app-icon-001.png","modified":0,"renderable":0},{"_id":"source/images/st-001.png","path":"images/st-001.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"source/images/app-icon-003.png","path":"images/app-icon-003.png","modified":0,"renderable":0},{"_id":"source/images/st-003.png","path":"images/st-003.png","modified":0,"renderable":0},{"_id":"source/images/st-004.png","path":"images/st-004.png","modified":0,"renderable":0},{"_id":"source/assets/avatar.png","path":"assets/avatar.png","modified":0,"renderable":0},{"_id":"source/images/st-002.png","path":"images/st-002.png","modified":0,"renderable":0},{"_id":"source/images/heng-001.png","path":"images/heng-001.png","modified":0,"renderable":0},{"_id":"source/images/heng-002.png","path":"images/heng-002.png","modified":0,"renderable":0},{"_id":"source/resume/link.svg","path":"resume/link.svg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"d28d32f68f81aedb8c08ae1840132e8d897b92c6","modified":1571314491000},{"_id":"themes/yilia/.DS_Store","hash":"10af0e520caf203fb43cc84cb5e72914e1397965","modified":1531670186000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1518766939000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1518766939000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1518766939000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1518766939000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1518766939000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1518766939000},{"_id":"themes/yilia/_config.yml","hash":"25eb48cb0d16609047954b3a9513d2a86e3ae65b","modified":1571315076000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1518766939000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1518766939000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1518766939000},{"_id":"source/_posts/.DS_Store","hash":"80113056083cd288c3160dc116b0e8b4f3cef34e","modified":1521299153000},{"_id":"source/_posts/JCConf-2018.md","hash":"90c8c16086c525e41e1e5d8b6baa690ab07b436c","modified":1570716615000},{"_id":"source/_posts/JCConf-2019.md","hash":"f30e27287b7b37359287e664fe61494619843d9e","modified":1570716700000},{"_id":"source/_posts/Linux-如何避免重複執行特定jar.md","hash":"a52ae2d43415b39db4adfb4680f1c4b3ad485642","modified":1522590599000},{"_id":"source/_posts/以前設計的APP-Icon.md","hash":"2d39f712a13b0adba6a65991c4586bbc9168bd26","modified":1570720613000},{"_id":"source/_posts/你真的了解Java中的Thread運作嗎？-容易讓人誤解的synchronized-method.md","hash":"86089ddf22c1a2c841562ec577e361b219ccd0a7","modified":1570782588000},{"_id":"source/_posts/使用-Gradle-自動初始化-Spock.md","hash":"95f65b5688d86e1a10624efdb371962ad24f46c9","modified":1528125494000},{"_id":"source/_posts/使用-WeakReference-解決-Android-發生-memory-leak-問題.md","hash":"7f399deabedc57eb46516c5f321d8b3f90b12860","modified":1521994079000},{"_id":"source/_posts/使用視覺化來解釋數學原理的youtube-3Blue1Brown.md","hash":"609e9ddbed0b3bc6cff906544223da8d908ef029","modified":1570781688000},{"_id":"source/_posts/從無到有DIY-chart-一.md","hash":"af5bf6734e233f0a4589c8e484d50b5e70815cc6","modified":1528297686000},{"_id":"source/_posts/更換hexo-themes.md","hash":"4d500dc551241b6132a7a326dee8c5f5655a6bca","modified":1521303963000},{"_id":"source/_posts/從無到有DIY-chart-二.md","hash":"4093316081f9b3422e802d98045fe0955f23c479","modified":1570780526000},{"_id":"source/_posts/提升Socket傳送Large-file的速度.md","hash":"25ce47a8366590805539e16aa961b1e4bc452edf","modified":1528125479000},{"_id":"source/_posts/標準常態分佈的機率密度函數.md","hash":"1290948bbd65a293aeb8dfbd4b4a80a65b30cd37","modified":1570788198000},{"_id":"source/_posts/比較好的nested-map寫法.md","hash":"2f506d45acd4d0043b1ad05398d0919d81041acf","modified":1521994177000},{"_id":"source/_posts/用illustrator幫自己畫一個新頭像.md","hash":"7e84c3b846dfbca5bd67bdc1ae11a79fe65734c9","modified":1570722145000},{"_id":"source/_posts/第一篇Blog，從SVN到Git.md","hash":"750f2030b4b8abcd5a7437a59caa821d49ae4b08","modified":1518941505000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1570716247000},{"_id":"source/images/chart-diy-001.png","hash":"737647a3fbd83abf5339b6c525ca6e705970b1c3","modified":1522595338000},{"_id":"source/resume/index.html","hash":"cf73b7931dbfdee51d75597842d1e25ea367677b","modified":1571386294000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1518766939000},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1518767044000},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1518767044000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1518766939000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1518766925000},{"_id":"themes/yilia/.git/index","hash":"6db65bb4d369595d1ad1979d130aeaaab6a857e5","modified":1518766939000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1518766939000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1518766939000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1518766939000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1518766939000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1518766939000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1518766939000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1518766939000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1518766939000},{"_id":"themes/yilia/layout/.DS_Store","hash":"22f5eef2275c7b08742d28cfe85ab44849c47d73","modified":1518880926000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1518766939000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1518766939000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1518766939000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1518766939000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1518766939000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1518766939000},{"_id":"themes/yilia/source/.DS_Store","hash":"545d503a1be0dfd5343bc707e0befd4ffb1ecc6d","modified":1531670181000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1518766939000},{"_id":"themes/yilia/source/googlef6c955fb09e49d48.html","hash":"20626ce3703e9ed561e62b08c9ab89968fde4361","modified":1518885657000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1518766939000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1518766939000},{"_id":"themes/yilia/source-src/.DS_Store","hash":"16fd14b5fed94e155d63b8f25ccd9cd6c40995c9","modified":1518885635000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1518766939000},{"_id":"source/images/app-icon-002.png","hash":"12bc4f5424f48161cfc3ecdd2ba8ec16921bfee5","modified":1570718186000},{"_id":"source/images/chart-diy-002.png","hash":"c284f3d1c4e9ec9ae3c3c020e2c5d17b3f4ccf74","modified":1522595440000},{"_id":"source/images/jcconf-2018-001.png","hash":"8c2e3c2522e01ffb5d4d67afa567822608cd0776","modified":1570714236000},{"_id":"source/images/jcconf-2018-002.png","hash":"f412fd26faa1e1c278af8f5d3e66a41ff8b986d0","modified":1570714236000},{"_id":"source/images/jcconf-2019-001.png","hash":"105b39b7a9eafde41c0aaeda6ab982a87a337a97","modified":1570714236000},{"_id":"source/images/st-005.png","hash":"2f94f87d403b1b99827ae523a6d42a76ed47b04e","modified":1521968961000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518766939000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1518766939000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1518766939000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1518766939000},{"_id":"source/images/app-icon-001.png","hash":"6b7963067d7e7f08a14c79d24be8e557c8ba1aef","modified":1570718236000},{"_id":"source/images/st-001.png","hash":"755199424b395d5ba10b161cec8a20993dc68b23","modified":1521967598000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1518766925000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1518766925000},{"_id":"themes/yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1518766925000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"9443501ffded543b21afc6d6ff842840a109723f","modified":1518766939000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1518766925000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1518766939000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1518766939000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1518766939000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1518766939000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1518766939000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1518766939000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1518766939000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1518766939000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1518766939000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1518766939000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1518766939000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1518766939000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1518766939000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1518766939000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1518766939000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1518766939000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1518766939000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1518766939000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1518766939000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1518766939000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1518766939000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1518766939000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1518766939000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1518766939000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1518766939000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1518766939000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1518766939000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1518766939000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1518766939000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1518766939000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1518766939000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1518766939000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1518766939000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1518766939000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1518766939000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1518766939000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1518766939000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1518766939000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1518766939000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1518766939000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1518766939000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1518766939000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1518766939000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1518766939000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1518766939000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1518766939000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1518766939000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1518766939000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1518766939000},{"_id":"source/images/app-icon-003.png","hash":"e65901b659b3ebe01354b3ffbe2fb4cd2377d271","modified":1570718580000},{"_id":"source/images/st-003.png","hash":"c12882f52d6537cce223b739a5e853db537d4cba","modified":1521967994000},{"_id":"source/images/st-004.png","hash":"f7ec8687ea8756ebed4957aee26da4bce5b2bc07","modified":1521969719000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1518766939000},{"_id":"source/assets/avatar.png","hash":"051012510a3057692395a06c508ab23225fa1c37","modified":1531671255000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1518766939000},{"_id":"themes/yilia/.git/objects/pack/pack-2a3671e37306f5316414a4c829b868393dcf07ac.idx","hash":"dd89b7a8a3bebd8e29106242daee9999d2edda44","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1518766939000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1518766939000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1518766939000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1518766939000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1518766939000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1518766939000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1518766939000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1518766939000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1518766939000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1518766939000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1518766939000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1518766939000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1518766939000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1518766939000},{"_id":"source/images/st-002.png","hash":"564d4bb161ad872375c4cfc69be31fbfeb5771d9","modified":1521967645000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"9443501ffded543b21afc6d6ff842840a109723f","modified":1518766939000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1518766939000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"9443501ffded543b21afc6d6ff842840a109723f","modified":1518766939000},{"_id":"source/images/heng-001.png","hash":"96d3720a39040f9ee2fded302d070e16142bf8b7","modified":1531381930000},{"_id":"source/images/heng-002.png","hash":"bcb46780fd962bf9db9f32f6b034df22eada5f3a","modified":1531706586000},{"_id":"themes/yilia/.git/objects/pack/pack-2a3671e37306f5316414a4c829b868393dcf07ac.pack","hash":"d7ade42cc38a51c1544ae10903fe0a1526266320","modified":1518766939000},{"_id":"public/atom.xml","hash":"ba40423aeb4e4629f6ac0d4d21c4d13388fc2cac","modified":1571314609157},{"_id":"public/content.json","hash":"34824559752446983ddc71dfde75d9a33f989824","modified":1571314609184},{"_id":"public/sitemap.xml","hash":"2a7fcd5d91c9d65da9ba6f8fc962473eda28d1de","modified":1571386619404},{"_id":"public/2018/10/21/JCConf-2018/index.html","hash":"458a4507cbb453e3b7a01b1c4d6e24cd668986f2","modified":1571315084215},{"_id":"public/2019/10/04/JCConf-2019/index.html","hash":"b602a88fe20bc19755ec392207a8a37c81e6854b","modified":1571315084215},{"_id":"public/2018/07/15/用illustrator幫自己畫一個新頭像/index.html","hash":"d6d8f310ed00f98306bb6ab7e20cc275c8beb762","modified":1571315084215},{"_id":"public/2019/10/10/以前設計的APP-Icon/index.html","hash":"0b95478bfaedb14c34547602896c17a68cd8b51b","modified":1571315084215},{"_id":"public/2018/06/24/使用視覺化來解釋數學原理的youtube-3Blue1Brown/index.html","hash":"e2ee32ccfbf4e8c4e7e99b7d437f22d9192a1acf","modified":1571315084215},{"_id":"public/resume/index.html","hash":"abb79d547775ca454969b6f8f0c3d0c029cac7be","modified":1571386619452},{"_id":"public/2018/05/20/使用-Gradle-自動初始化-Spock/index.html","hash":"b8d416beaa97895dc7c4e5054ebd1dced3065cb4","modified":1571315084215},{"_id":"public/2018/04/29/你真的了解Java中的Thread運作嗎？-容易讓人誤解的synchronized-method/index.html","hash":"9f55e69fcca4d3576a432e31387025ab1b5c8697","modified":1571315084216},{"_id":"public/2018/04/01/從無到有DIY-chart-一/index.html","hash":"4891d2662c9dbfc3b85fff7359a108b99cce7c35","modified":1571315084216},{"_id":"public/2018/05/13/提升Socket傳送Large-file的速度/index.html","hash":"876758ea9bbea9fc9fefcd40c13d8dc6b7cccc63","modified":1571315084216},{"_id":"public/2018/03/10/使用-WeakReference-解決-Android-發生-memory-leak-問題/index.html","hash":"3f5f280742144d230680ca2d3ab1000f2763fc82","modified":1571315084216},{"_id":"public/2018/03/17/Linux-如何避免重複執行特定jar/index.html","hash":"c1fdc518f92265aa5e9861f43902da3fcf0a871c","modified":1571315084216},{"_id":"public/2018/03/03/比較好的nested-map寫法/index.html","hash":"3ac9ec99a43cde2c3b68b774927faef1ee0599d9","modified":1571315084216},{"_id":"public/2018/02/20/更換hexo-themes/index.html","hash":"d49016d80057c02d57864715713cdd6fe58218a7","modified":1571315084216},{"_id":"public/archives/index.html","hash":"a392ea46ee8c898637666eddae85d456b521acd9","modified":1571315084219},{"_id":"public/2018/04/14/從無到有DIY-chart-二/index.html","hash":"72b478fa51c3eca674016a5f730b8e2236edb46c","modified":1571315084216},{"_id":"public/2018/02/16/第一篇Blog，從SVN到Git/index.html","hash":"2e873d3c3a8e91faa6c3cbf819f02457cde648d2","modified":1571315084216},{"_id":"public/archives/page/2/index.html","hash":"647125cfdad9d53c8d4bb939d0558e13cb7dde41","modified":1571315084219},{"_id":"public/archives/2018/index.html","hash":"ba61b09101df566c65941f20ed7394c3254f6498","modified":1571315084219},{"_id":"public/archives/2018/page/2/index.html","hash":"32e77a2e003bf1ab8b12185b3186ef5f5129d7b4","modified":1571315084219},{"_id":"public/archives/2018/02/index.html","hash":"1d9c58fe5eaea610c118ae4b42c6b77325811312","modified":1571315084219},{"_id":"public/archives/2018/03/index.html","hash":"f9345c62c0d2546a6c837ed4f431a68a29a72a39","modified":1571315084219},{"_id":"public/2018/03/24/標準常態分佈的機率密度函數/index.html","hash":"8e07cd65476276c4adb76398e5d82bfb2825b27c","modified":1571315084216},{"_id":"public/archives/2018/04/index.html","hash":"086b58c96c396ef658f39fc205718310dc174b5f","modified":1571315084219},{"_id":"public/archives/2018/07/index.html","hash":"f96481eec5e070e3ad9e6ad05924331b933ea599","modified":1571315084220},{"_id":"public/archives/2018/06/index.html","hash":"ce5258356c404337e94e86e8798cc16d4e96aacb","modified":1571315084219},{"_id":"public/archives/2019/index.html","hash":"42521bf26713fa06e20ca9dd15c190a46bb9da43","modified":1571315084220},{"_id":"public/index.html","hash":"238943d65ba5dbf06bdb307dfdac5dba11d922f5","modified":1571315084218},{"_id":"public/archives/2019/10/index.html","hash":"e03510e2e63686a9b2c4beea3dd7e2a3d758de01","modified":1571315084220},{"_id":"public/archives/2018/10/index.html","hash":"839b1c0e008ffad8e5cb0eebc19e353855b7dbb3","modified":1571315084220},{"_id":"public/tags/conference/index.html","hash":"5e8744b13282a8a777eb01aa1eba794e2a50bbe4","modified":1571315084217},{"_id":"public/page/2/index.html","hash":"ee24314490f53df6f76080f11024af7bf8cf683d","modified":1571315084218},{"_id":"public/tags/shell/index.html","hash":"1038c192981d8f27957bbdb5ec4dece698d9bf1f","modified":1571315084217},{"_id":"public/tags/java/index.html","hash":"303d4d50f7bd2a4c3e4d12df1fa56f39537904d5","modified":1571315084217},{"_id":"public/archives/2018/05/index.html","hash":"3162a09b08e4c147cc054df87cbbe1b2c9501dcd","modified":1571315084219},{"_id":"public/tags/thread/index.html","hash":"4cf85576a0be9fc30ecdf3f617cfbd3ea1f35085","modified":1571315084217},{"_id":"public/tags/illustrator/index.html","hash":"12ee939529685e41d2bfbe356cac4c1ac15b6377","modified":1571315084217},{"_id":"public/tags/gradle/index.html","hash":"7fea5da28422fb77046771458e99be33a6a764e8","modified":1571315084217},{"_id":"public/tags/unit-test/index.html","hash":"741cbd11f9bcb43fc190801837cedf1ff8f393d8","modified":1571315084217},{"_id":"public/tags/android/index.html","hash":"5a928320023269fd5bf8b357d86ba3cd48528efd","modified":1571315084217},{"_id":"public/tags/memory-leak/index.html","hash":"0a9d013930af22315b66a39d42a787d91f850f42","modified":1571315084217},{"_id":"public/tags/hexo/index.html","hash":"368fcf3ca0247facb9d7d39660beb82e9322e59b","modified":1571315084218},{"_id":"public/tags/clean-code/index.html","hash":"12f281c4c598fcd623d1d05ee414519772d73a8d","modified":1571315084218},{"_id":"public/tags/Blog/index.html","hash":"a76fa2c88d069d778411ba48a4977636d25c9661","modified":1571315084218},{"_id":"public/tags/js/index.html","hash":"9a388eddc71f83a2a5e67d68bd538420df3d19d0","modified":1571315084218},{"_id":"public/tags/probability/index.html","hash":"577823d2572d0019c90e44820a0e79921be2ffac","modified":1571315084218},{"_id":"public/tags/statistics/index.html","hash":"1715ec841fd27899cef00299caf560abd4c2409a","modified":1571315084218},{"_id":"public/tags/math/index.html","hash":"df3fbb83e5709c0b4fefe953bbebf856a9a9e8dc","modified":1571315084217},{"_id":"public/images/chart-diy-001.png","hash":"737647a3fbd83abf5339b6c525ca6e705970b1c3","modified":1571314609565},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1571314609565},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1571314609566},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1571314609566},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1571314609566},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1571314609566},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1571314609566},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1571314609566},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1571314609566},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1571314609566},{"_id":"public/images/chart-diy-002.png","hash":"c284f3d1c4e9ec9ae3c3c020e2c5d17b3f4ccf74","modified":1571314609571},{"_id":"public/images/app-icon-002.png","hash":"12bc4f5424f48161cfc3ecdd2ba8ec16921bfee5","modified":1571314609571},{"_id":"public/images/jcconf-2018-002.png","hash":"f412fd26faa1e1c278af8f5d3e66a41ff8b986d0","modified":1571314609571},{"_id":"public/images/jcconf-2018-001.png","hash":"8c2e3c2522e01ffb5d4d67afa567822608cd0776","modified":1571314609572},{"_id":"public/images/jcconf-2019-001.png","hash":"105b39b7a9eafde41c0aaeda6ab982a87a337a97","modified":1571314609572},{"_id":"public/images/st-005.png","hash":"2f94f87d403b1b99827ae523a6d42a76ed47b04e","modified":1571314609572},{"_id":"public/googlef6c955fb09e49d48.html","hash":"20626ce3703e9ed561e62b08c9ab89968fde4361","modified":1571314609573},{"_id":"public/images/st-001.png","hash":"755199424b395d5ba10b161cec8a20993dc68b23","modified":1571314609585},{"_id":"public/images/app-icon-003.png","hash":"e65901b659b3ebe01354b3ffbe2fb4cd2377d271","modified":1571314609585},{"_id":"public/images/st-003.png","hash":"c12882f52d6537cce223b739a5e853db537d4cba","modified":1571314609590},{"_id":"public/images/st-004.png","hash":"f7ec8687ea8756ebed4957aee26da4bce5b2bc07","modified":1571314609590},{"_id":"public/images/st-002.png","hash":"564d4bb161ad872375c4cfc69be31fbfeb5771d9","modified":1571314609590},{"_id":"public/images/app-icon-001.png","hash":"6b7963067d7e7f08a14c79d24be8e557c8ba1aef","modified":1571314609595},{"_id":"public/assets/avatar.png","hash":"051012510a3057692395a06c508ab23225fa1c37","modified":1571314609598},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1571314609600},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1571314609603},{"_id":"public/images/heng-001.png","hash":"96d3720a39040f9ee2fded302d070e16142bf8b7","modified":1571314609603},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1571314609604},{"_id":"public/images/heng-002.png","hash":"bcb46780fd962bf9db9f32f6b034df22eada5f3a","modified":1571314609605},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1571314609608},{"_id":"source/resume/progress.css","hash":"48cf445ad2ef3582626c0e31927b8da3f5879f8d","modified":1571369027000},{"_id":"public/resume/progress.css","hash":"48cf445ad2ef3582626c0e31927b8da3f5879f8d","modified":1571386101748},{"_id":"source/resume/data.json","hash":"49d0c9363a37cb07a76eae9b0be542e53481916a","modified":1571386511000},{"_id":"source/resume/link.svg","hash":"046b90f72c65e3a4bb5b3e5635ca38aef8525535","modified":1571368602000},{"_id":"source/resume/main.js","hash":"9fabb3f1c5e7bf1adad7e599fd55f4c5d2e55f6b","modified":1571367690000},{"_id":"public/resume/data.json","hash":"0ef940f717dd8c394b69a6c7b4521e7a154386c4","modified":1571386619202},{"_id":"public/resume/main.js","hash":"9fabb3f1c5e7bf1adad7e599fd55f4c5d2e55f6b","modified":1571386101982},{"_id":"public/resume/link.svg","hash":"046b90f72c65e3a4bb5b3e5635ca38aef8525535","modified":1571386101985}],"Category":[],"Data":[],"Page":[{"_content":"<html>\n    \n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n        <link rel=\"stylesheet\" href=\"progress.css\"/>\n        <script language=\"javascript\" type=\"module\" src=\"main.js\"></script>\n        <title>\n        </title>\n    </head>\n    \n    <body>\n        <h1>\n            <a href=\"https://www.cakeresume.com/s--4Bb__GJvxBLLmXRNg-TlCQ--/enjoymycodinglife\" target=\"_blank\">\n                CakeResume\n                <img src=\"link.svg\" alt=\"CakeResume\" title=\"CakeResume\" class=\"icon-svg\">\n            </a>\n        </h1>\n    \t<h1>Java ( Special Event )</h1>\n        <div id=\"content\"></div>\n    </body>\n</html>","source":"resume/index.html","raw":"<html>\n    \n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n        <link rel=\"stylesheet\" href=\"progress.css\"/>\n        <script language=\"javascript\" type=\"module\" src=\"main.js\"></script>\n        <title>\n        </title>\n    </head>\n    \n    <body>\n        <h1>\n            <a href=\"https://www.cakeresume.com/s--4Bb__GJvxBLLmXRNg-TlCQ--/enjoymycodinglife\" target=\"_blank\">\n                CakeResume\n                <img src=\"link.svg\" alt=\"CakeResume\" title=\"CakeResume\" class=\"icon-svg\">\n            </a>\n        </h1>\n    \t<h1>Java ( Special Event )</h1>\n        <div id=\"content\"></div>\n    </body>\n</html>","date":"2019-10-18T08:11:34.000Z","updated":"2019-10-18T08:11:34.000Z","path":"resume/index.html","_id":"ck1uo5bph001j2bpj2vtgy7rh","title":"","comments":1,"layout":"page","content":"<html>\n    \n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <link rel=\"stylesheet\" href=\"progress.css\">\n        <script language=\"javascript\" type=\"module\" src=\"main.js\"></script>\n        <title>\n        </title>\n    </head>\n    \n    <body>\n        <h1>\n            <a href=\"https://www.cakeresume.com/s--4Bb__GJvxBLLmXRNg-TlCQ--/enjoymycodinglife\" target=\"_blank\">\n                CakeResume\n                <img src=\"link.svg\" alt=\"CakeResume\" title=\"CakeResume\" class=\"icon-svg\">\n            </a>\n        </h1>\n    \t<h1>Java ( Special Event )</h1>\n        <div id=\"content\"></div>\n    </body>\n</html>","site":{"data":{}},"excerpt":"","more":"<html>\n    \n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <link rel=\"stylesheet\" href=\"progress.css\">\n        <script language=\"javascript\" type=\"module\" src=\"main.js\"></script>\n        <title>\n        </title>\n    </head>\n    \n    <body>\n        <h1>\n            <a href=\"https://www.cakeresume.com/s--4Bb__GJvxBLLmXRNg-TlCQ--/enjoymycodinglife\" target=\"_blank\">\n                CakeResume\n                <img src=\"link.svg\" alt=\"CakeResume\" title=\"CakeResume\" class=\"icon-svg\">\n            </a>\n        </h1>\n    \t<h1>Java ( Special Event )</h1>\n        <div id=\"content\"></div>\n    </body>\n</html>"},{"_content":"body {\n    margin: 30px;\n    padding: 10px;\n    font-size: 1rem;\n}\n\na {\n    text-decoration: none;\n}\n\n.title {\n    font-size: 1.5rem;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 100px;\n    display: table;\n}\n\n.ball {\n    width: 20px;\n    height: 20px;\n    border-radius: 10px;\n    margin-left: 20px;\n}\n\n.progress {\n    width: 3px;\n    height: 100%;\n    margin-left: 28px;\n}\n\n.detail {\n    margin-left: 40px;\n    float:left;\n    position: relative;\n    top: -30px;\n    left: 5px;\n}\n\n.flow-detail {\n    margin: 2px;\n}\n\n.active {\n    background-color: #A8A8A8\n}\n\n.icon-svg {\n    width: 30px;\n    height: 30px;\n}","source":"resume/progress.css","raw":"body {\n    margin: 30px;\n    padding: 10px;\n    font-size: 1rem;\n}\n\na {\n    text-decoration: none;\n}\n\n.title {\n    font-size: 1.5rem;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 100px;\n    display: table;\n}\n\n.ball {\n    width: 20px;\n    height: 20px;\n    border-radius: 10px;\n    margin-left: 20px;\n}\n\n.progress {\n    width: 3px;\n    height: 100%;\n    margin-left: 28px;\n}\n\n.detail {\n    margin-left: 40px;\n    float:left;\n    position: relative;\n    top: -30px;\n    left: 5px;\n}\n\n.flow-detail {\n    margin: 2px;\n}\n\n.active {\n    background-color: #A8A8A8\n}\n\n.icon-svg {\n    width: 30px;\n    height: 30px;\n}","date":"2019-10-18T03:23:47.000Z","updated":"2019-10-18T03:23:47.000Z","path":"resume/progress.css","layout":"false","_id":"ck1uoky8q0001eopj9tncqaq6","title":"","comments":1,"content":"body {\n    margin: 30px;\n    padding: 10px;\n    font-size: 1rem;\n}\n\na {\n    text-decoration: none;\n}\n\n.title {\n    font-size: 1.5rem;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 100px;\n    display: table;\n}\n\n.ball {\n    width: 20px;\n    height: 20px;\n    border-radius: 10px;\n    margin-left: 20px;\n}\n\n.progress {\n    width: 3px;\n    height: 100%;\n    margin-left: 28px;\n}\n\n.detail {\n    margin-left: 40px;\n    float:left;\n    position: relative;\n    top: -30px;\n    left: 5px;\n}\n\n.flow-detail {\n    margin: 2px;\n}\n\n.active {\n    background-color: #A8A8A8\n}\n\n.icon-svg {\n    width: 30px;\n    height: 30px;\n}","site":{"data":{}},"excerpt":"","more":"body {\n    margin: 30px;\n    padding: 10px;\n    font-size: 1rem;\n}\n\na {\n    text-decoration: none;\n}\n\n.title {\n    font-size: 1.5rem;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 100px;\n    display: table;\n}\n\n.ball {\n    width: 20px;\n    height: 20px;\n    border-radius: 10px;\n    margin-left: 20px;\n}\n\n.progress {\n    width: 3px;\n    height: 100%;\n    margin-left: 28px;\n}\n\n.detail {\n    margin-left: 40px;\n    float:left;\n    position: relative;\n    top: -30px;\n    left: 5px;\n}\n\n.flow-detail {\n    margin: 2px;\n}\n\n.active {\n    background-color: #A8A8A8\n}\n\n.icon-svg {\n    width: 30px;\n    height: 30px;\n}"},{"_content":"{\n    \"contents\": [\n        {\n            \"title\": \"2019 Servtech - Senior Engineer\",\n            \"content\": [\n                \"I was responsible for Android tablet and smart watch APP. It can using QR code input data and google voice (RecognizerIntent) trigger button.\"\n            ]\n        },\n        {\n            \"title\": \"2018\",\n            \"content\": [\n                \"I was responsible for back-end project by Spring Boot framework, it's a RESTful Server for front-end call API. It's easier to use than Spring MVC.\",\n                \"I was responsible for SPC system project, it calculate the results of CUSUM and EWMA, both are the most common tool for monitoring a quality characteristic of interest.\"\n            ]\n        },\n        {\n            \"title\": \"2017\",\n            \"content\": [\n                \"I was responsible for factory work order scheduling system project, automated multi-line work order scheduling by work order information. ( reference OptaPlanner )\",\n                \"I was responsible for Android APP for mobile display platform information. And I solve APP crashed problem when Android 5.0 update to Android 6.0.\",\n                \"I was responsible for middleware message platform project, it's used for exchange of information among different devices, e.g. Data transfer among platform, Android, iPhone. And I improve platform performance that the original mobile phone requesting two months of data originally needs to be executed for 90 seconds from platform. Finally, it takes only 5 seconds to complete. It's using pre-processing data and proxy LRU cache.\"\n            ]\n        },\n        {\n            \"title\": \"2015\",\n            \"content\": [\n                \"I solve the problem of excessive amount of instant message data volume. Original, we use XML format for message, it needs a lot of flow to transfer data. I use Protocol Buffers to compressed and encrypted data. After a record original 1MB is reduced to 27KB.\",\n                \"I was responsible for Big data rule engine project, it's similar to Excel calculation rules for calculation and pivot analysis of big data. It use expression and Trie tree process data.\"\n            ]\n        },\n        {\n            \"title\": \"2014\",\n            \"content\": [\n                \"I was responsible for back-end project by Spring MVC framework, it's a RESTful Server for front-end call API. We switched to Spring MVC for security reasons. We use gradle build project, and it use MockMVC test. ( Unit test framework )\",\n                \"I improve I/O read file and Master-slave RPC performance that it use NIO selected channel and byte buffer in data processing, it prevent I/O blocking problem.\",\n                \"We participate Intel Global Challenge take first place, I was responsible for demo platform.\"\n            ]\n        },\n        {\n            \"title\": \"2014 Institute for Information Industry (iii) - Platform application development engineer\",\n            \"content\": [\n                \"The platform import NoSQL when the accumulated amount of data is too large. I was responsible for research related NoSQL technologies.  Finally, I deploy cluster of Hbase relies on Zookeeper.\",\n                \"I improve the stability of the platform that it use Memory Analyzer(MAT) analyze file of memory dump. I found some object reference static object, it can't release by garbage collection. I use weak reference solved the problem of occasional memory leaks.\"\n            ]\n        },\n        {\n            \"title\": \"2013\",\n            \"content\": [\n                \"I was responsible for back-end project by Strust2 framework, and JAP with MySQL. It's a RESTful Server for front-end call API. And it use message queue (ActiveMQ) for other services.\",\n                \"I improve platform performance that it change real-time data processed from database to memory and reduce front-end API request by using pre-processing data. Finally, At the same time, original, it can handle data volume of 30 machines, after it can handle data volume of more than 100 machines. ( It fetch CNC controller or PLC point data from factory machine )\"            ]\n        }\n    ]\n}","source":"resume/data.json","raw":"{\n    \"contents\": [\n        {\n            \"title\": \"2019 Servtech - Senior Engineer\",\n            \"content\": [\n                \"I was responsible for Android tablet and smart watch APP. It can using QR code input data and google voice (RecognizerIntent) trigger button.\"\n            ]\n        },\n        {\n            \"title\": \"2018\",\n            \"content\": [\n                \"I was responsible for back-end project by Spring Boot framework, it's a RESTful Server for front-end call API. It's easier to use than Spring MVC.\",\n                \"I was responsible for SPC system project, it calculate the results of CUSUM and EWMA, both are the most common tool for monitoring a quality characteristic of interest.\"\n            ]\n        },\n        {\n            \"title\": \"2017\",\n            \"content\": [\n                \"I was responsible for factory work order scheduling system project, automated multi-line work order scheduling by work order information. ( reference OptaPlanner )\",\n                \"I was responsible for Android APP for mobile display platform information. And I solve APP crashed problem when Android 5.0 update to Android 6.0.\",\n                \"I was responsible for middleware message platform project, it's used for exchange of information among different devices, e.g. Data transfer among platform, Android, iPhone. And I improve platform performance that the original mobile phone requesting two months of data originally needs to be executed for 90 seconds from platform. Finally, it takes only 5 seconds to complete. It's using pre-processing data and proxy LRU cache.\"\n            ]\n        },\n        {\n            \"title\": \"2015\",\n            \"content\": [\n                \"I solve the problem of excessive amount of instant message data volume. Original, we use XML format for message, it needs a lot of flow to transfer data. I use Protocol Buffers to compressed and encrypted data. After a record original 1MB is reduced to 27KB.\",\n                \"I was responsible for Big data rule engine project, it's similar to Excel calculation rules for calculation and pivot analysis of big data. It use expression and Trie tree process data.\"\n            ]\n        },\n        {\n            \"title\": \"2014\",\n            \"content\": [\n                \"I was responsible for back-end project by Spring MVC framework, it's a RESTful Server for front-end call API. We switched to Spring MVC for security reasons. We use gradle build project, and it use MockMVC test. ( Unit test framework )\",\n                \"I improve I/O read file and Master-slave RPC performance that it use NIO selected channel and byte buffer in data processing, it prevent I/O blocking problem.\",\n                \"We participate Intel Global Challenge take first place, I was responsible for demo platform.\"\n            ]\n        },\n        {\n            \"title\": \"2014 Institute for Information Industry (iii) - Platform application development engineer\",\n            \"content\": [\n                \"The platform import NoSQL when the accumulated amount of data is too large. I was responsible for research related NoSQL technologies.  Finally, I deploy cluster of Hbase relies on Zookeeper.\",\n                \"I improve the stability of the platform that it use Memory Analyzer(MAT) analyze file of memory dump. I found some object reference static object, it can't release by garbage collection. I use weak reference solved the problem of occasional memory leaks.\"\n            ]\n        },\n        {\n            \"title\": \"2013\",\n            \"content\": [\n                \"I was responsible for back-end project by Strust2 framework, and JAP with MySQL. It's a RESTful Server for front-end call API. And it use message queue (ActiveMQ) for other services.\",\n                \"I improve platform performance that it change real-time data processed from database to memory and reduce front-end API request by using pre-processing data. Finally, At the same time, original, it can handle data volume of 30 machines, after it can handle data volume of more than 100 machines. ( It fetch CNC controller or PLC point data from factory machine )\"            ]\n        }\n    ]\n}","date":"2019-10-18T08:15:11.000Z","updated":"2019-10-18T08:15:11.000Z","path":"resume/data.json","layout":"false","_id":"ck1uqsool00013dpjk3afr3tr","title":"","comments":1,"content":"{\"contents\":[{\"title\":\"2019 Servtech - Senior Engineer\",\"content\":[\"I was responsible for Android tablet and smart watch APP. It can using QR code input data and google voice (RecognizerIntent) trigger button.\"]},{\"title\":\"2018\",\"content\":[\"I was responsible for back-end project by Spring Boot framework, it's a RESTful Server for front-end call API. It's easier to use than Spring MVC.\",\"I was responsible for SPC system project, it calculate the results of CUSUM and EWMA, both are the most common tool for monitoring a quality characteristic of interest.\"]},{\"title\":\"2017\",\"content\":[\"I was responsible for factory work order scheduling system project, automated multi-line work order scheduling by work order information. ( reference OptaPlanner )\",\"I was responsible for Android APP for mobile display platform information. And I solve APP crashed problem when Android 5.0 update to Android 6.0.\",\"I was responsible for middleware message platform project, it's used for exchange of information among different devices, e.g. Data transfer among platform, Android, iPhone. And I improve platform performance that the original mobile phone requesting two months of data originally needs to be executed for 90 seconds from platform. Finally, it takes only 5 seconds to complete. It's using pre-processing data and proxy LRU cache.\"]},{\"title\":\"2015\",\"content\":[\"I solve the problem of excessive amount of instant message data volume. Original, we use XML format for message, it needs a lot of flow to transfer data. I use Protocol Buffers to compressed and encrypted data. After a record original 1MB is reduced to 27KB.\",\"I was responsible for Big data rule engine project, it's similar to Excel calculation rules for calculation and pivot analysis of big data. It use expression and Trie tree process data.\"]},{\"title\":\"2014\",\"content\":[\"I was responsible for back-end project by Spring MVC framework, it's a RESTful Server for front-end call API. We switched to Spring MVC for security reasons. We use gradle build project, and it use MockMVC test. ( Unit test framework )\",\"I improve I/O read file and Master-slave RPC performance that it use NIO selected channel and byte buffer in data processing, it prevent I/O blocking problem.\",\"We participate Intel Global Challenge take first place, I was responsible for demo platform.\"]},{\"title\":\"2014 Institute for Information Industry (iii) - Platform application development engineer\",\"content\":[\"The platform import NoSQL when the accumulated amount of data is too large. I was responsible for research related NoSQL technologies.  Finally, I deploy cluster of Hbase relies on Zookeeper.\",\"I improve the stability of the platform that it use Memory Analyzer(MAT) analyze file of memory dump. I found some object reference static object, it can't release by garbage collection. I use weak reference solved the problem of occasional memory leaks.\"]},{\"title\":\"2013\",\"content\":[\"I was responsible for back-end project by Strust2 framework, and JAP with MySQL. It's a RESTful Server for front-end call API. And it use message queue (ActiveMQ) for other services.\",\"I improve platform performance that it change real-time data processed from database to memory and reduce front-end API request by using pre-processing data. Finally, At the same time, original, it can handle data volume of 30 machines, after it can handle data volume of more than 100 machines. ( It fetch CNC controller or PLC point data from factory machine )\"]}]}","site":{"data":{}},"excerpt":"","more":"{\"contents\":[{\"title\":\"2019 Servtech - Senior Engineer\",\"content\":[\"I was responsible for Android tablet and smart watch APP. It can using QR code input data and google voice (RecognizerIntent) trigger button.\"]},{\"title\":\"2018\",\"content\":[\"I was responsible for back-end project by Spring Boot framework, it's a RESTful Server for front-end call API. It's easier to use than Spring MVC.\",\"I was responsible for SPC system project, it calculate the results of CUSUM and EWMA, both are the most common tool for monitoring a quality characteristic of interest.\"]},{\"title\":\"2017\",\"content\":[\"I was responsible for factory work order scheduling system project, automated multi-line work order scheduling by work order information. ( reference OptaPlanner )\",\"I was responsible for Android APP for mobile display platform information. And I solve APP crashed problem when Android 5.0 update to Android 6.0.\",\"I was responsible for middleware message platform project, it's used for exchange of information among different devices, e.g. Data transfer among platform, Android, iPhone. And I improve platform performance that the original mobile phone requesting two months of data originally needs to be executed for 90 seconds from platform. Finally, it takes only 5 seconds to complete. It's using pre-processing data and proxy LRU cache.\"]},{\"title\":\"2015\",\"content\":[\"I solve the problem of excessive amount of instant message data volume. Original, we use XML format for message, it needs a lot of flow to transfer data. I use Protocol Buffers to compressed and encrypted data. After a record original 1MB is reduced to 27KB.\",\"I was responsible for Big data rule engine project, it's similar to Excel calculation rules for calculation and pivot analysis of big data. It use expression and Trie tree process data.\"]},{\"title\":\"2014\",\"content\":[\"I was responsible for back-end project by Spring MVC framework, it's a RESTful Server for front-end call API. We switched to Spring MVC for security reasons. We use gradle build project, and it use MockMVC test. ( Unit test framework )\",\"I improve I/O read file and Master-slave RPC performance that it use NIO selected channel and byte buffer in data processing, it prevent I/O blocking problem.\",\"We participate Intel Global Challenge take first place, I was responsible for demo platform.\"]},{\"title\":\"2014 Institute for Information Industry (iii) - Platform application development engineer\",\"content\":[\"The platform import NoSQL when the accumulated amount of data is too large. I was responsible for research related NoSQL technologies.  Finally, I deploy cluster of Hbase relies on Zookeeper.\",\"I improve the stability of the platform that it use Memory Analyzer(MAT) analyze file of memory dump. I found some object reference static object, it can't release by garbage collection. I use weak reference solved the problem of occasional memory leaks.\"]},{\"title\":\"2013\",\"content\":[\"I was responsible for back-end project by Strust2 framework, and JAP with MySQL. It's a RESTful Server for front-end call API. And it use message queue (ActiveMQ) for other services.\",\"I improve platform performance that it change real-time data processed from database to memory and reduce front-end API request by using pre-processing data. Finally, At the same time, original, it can handle data volume of 30 machines, after it can handle data volume of more than 100 machines. ( It fetch CNC controller or PLC point data from factory machine )\"]}]}"},{"_content":"(function(){\n    class Progress {\n        constructor(data){\n            this.contents = data.contents\n        }\n\n        buildHtml () {\n            const contentLen = this.contents.length\n            let progressActive = `<div class=\"progress active\"></div>`\n            return this.contents.map((item, index) => {\n                const detail = item.content.map((content) =>{\n                    return `<li>${content}</li>`\n                }).join('')\n                if(contentLen === (index + 1)){\n                    progressActive = ``\n                }\n                return `\n                <div class=\"progress-bar\">\n                    <div class=\"ball active\"></div>\n                    <div class=\"detail\">\n                        <div class=\"flow-detail title\">${item.title}</div>\n                        <ul class=\"flow-detail\">${detail}</ul>\n                    </div>\n                    ${progressActive}\n                </div>\n                `\n            }).join('')\n        }\n    }\n    fetch('data.json').then((res) => {\n        return res.json()\n    }).then((data) => {\n        const content = new Progress(data).buildHtml()\n        document.getElementById('content').innerHTML = content\n    })\n    \n})()","source":"resume/main.js","raw":"(function(){\n    class Progress {\n        constructor(data){\n            this.contents = data.contents\n        }\n\n        buildHtml () {\n            const contentLen = this.contents.length\n            let progressActive = `<div class=\"progress active\"></div>`\n            return this.contents.map((item, index) => {\n                const detail = item.content.map((content) =>{\n                    return `<li>${content}</li>`\n                }).join('')\n                if(contentLen === (index + 1)){\n                    progressActive = ``\n                }\n                return `\n                <div class=\"progress-bar\">\n                    <div class=\"ball active\"></div>\n                    <div class=\"detail\">\n                        <div class=\"flow-detail title\">${item.title}</div>\n                        <ul class=\"flow-detail\">${detail}</ul>\n                    </div>\n                    ${progressActive}\n                </div>\n                `\n            }).join('')\n        }\n    }\n    fetch('data.json').then((res) => {\n        return res.json()\n    }).then((data) => {\n        const content = new Progress(data).buildHtml()\n        document.getElementById('content').innerHTML = content\n    })\n    \n})()","date":"2019-10-18T03:01:30.000Z","updated":"2019-10-18T03:01:30.000Z","path":"resume/main.js","layout":"false","title":"","comments":1,"_id":"ck1vupnq70000p2pjz7t9y7t9","content":"(function(){\n    class Progress {\n        constructor(data){\n            this.contents = data.contents\n        }\n\n        buildHtml () {\n            const contentLen = this.contents.length\n            let progressActive = `<div class=\"progress active\"></div>`\n            return this.contents.map((item, index) => {\n                const detail = item.content.map((content) =>{\n                    return `<li>${content}</li>`\n                }).join('')\n                if(contentLen === (index + 1)){\n                    progressActive = ``\n                }\n                return `\n                <div class=\"progress-bar\">\n                    <div class=\"ball active\"></div>\n                    <div class=\"detail\">\n                        <div class=\"flow-detail title\">${item.title}</div>\n                        <ul class=\"flow-detail\">${detail}</ul>\n                    </div>\n                    ${progressActive}\n                </div>\n                `\n            }).join('')\n        }\n    }\n    fetch('data.json').then((res) => {\n        return res.json()\n    }).then((data) => {\n        const content = new Progress(data).buildHtml()\n        document.getElementById('content').innerHTML = content\n    })\n    \n})()","site":{"data":{}},"excerpt":"","more":"(function(){\n    class Progress {\n        constructor(data){\n            this.contents = data.contents\n        }\n\n        buildHtml () {\n            const contentLen = this.contents.length\n            let progressActive = `<div class=\"progress active\"></div>`\n            return this.contents.map((item, index) => {\n                const detail = item.content.map((content) =>{\n                    return `<li>${content}</li>`\n                }).join('')\n                if(contentLen === (index + 1)){\n                    progressActive = ``\n                }\n                return `\n                <div class=\"progress-bar\">\n                    <div class=\"ball active\"></div>\n                    <div class=\"detail\">\n                        <div class=\"flow-detail title\">${item.title}</div>\n                        <ul class=\"flow-detail\">${detail}</ul>\n                    </div>\n                    ${progressActive}\n                </div>\n                `\n            }).join('')\n        }\n    }\n    fetch('data.json').then((res) => {\n        return res.json()\n    }).then((data) => {\n        const content = new Progress(data).buildHtml()\n        document.getElementById('content').innerHTML = content\n    })\n    \n})()"}],"Post":[{"title":"JCConf 2018","date":"2018-10-21T14:26:02.000Z","_content":"\n今年又參加了JCConf\n\n<img src=\"/images/jcconf-2018-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"/>\n\n<br/><br/>\n還在Oath攤位抽到一隻黃色小鴨\n\n<img src=\"/images/jcconf-2018-002.png\" width=\"50%\" height=\"50%\" alt=\"img2\"/>\n","source":"_posts/JCConf-2018.md","raw":"---\ntitle: JCConf 2018\ndate: 2018-10-21 22:26:02\ntags:\n- conference\n---\n\n今年又參加了JCConf\n\n<img src=\"/images/jcconf-2018-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"/>\n\n<br/><br/>\n還在Oath攤位抽到一隻黃色小鴨\n\n<img src=\"/images/jcconf-2018-002.png\" width=\"50%\" height=\"50%\" alt=\"img2\"/>\n","slug":"JCConf-2018","published":1,"updated":"2019-10-10T14:10:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bod00002bpju7f0nxda","content":"<p>今年又參加了JCConf</p>\n<p><img src=\"/images/jcconf-2018-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"></p>\n<p><br><br><br>還在Oath攤位抽到一隻黃色小鴨</p>\n<p><img src=\"/images/jcconf-2018-002.png\" width=\"50%\" height=\"50%\" alt=\"img2\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今年又參加了JCConf</p>\n<p><img src=\"/images/jcconf-2018-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"></p>\n<p><br><br><br>還在Oath攤位抽到一隻黃色小鴨</p>\n<p><img src=\"/images/jcconf-2018-002.png\" width=\"50%\" height=\"50%\" alt=\"img2\"></p>\n"},{"title":"JCConf 2019","date":"2019-10-04T13:14:23.000Z","_content":"\n又過了一年，整整一年沒有更新...\n今年又來參加JCConf了，順便記錄一下吧~\n\n<img src=\"/images/jcconf-2019-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"/>\n","source":"_posts/JCConf-2019.md","raw":"---\ntitle: JCConf 2019\ndate: 2019-10-04 21:14:23\ntags:\n- conference\n---\n\n又過了一年，整整一年沒有更新...\n今年又來參加JCConf了，順便記錄一下吧~\n\n<img src=\"/images/jcconf-2019-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"/>\n","slug":"JCConf-2019","published":1,"updated":"2019-10-10T14:11:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5boh00012bpj5b6vg9zz","content":"<p>又過了一年，整整一年沒有更新…<br>今年又來參加JCConf了，順便記錄一下吧~</p>\n<p><img src=\"/images/jcconf-2019-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>又過了一年，整整一年沒有更新…<br>今年又來參加JCConf了，順便記錄一下吧~</p>\n<p><img src=\"/images/jcconf-2019-001.png\" width=\"50%\" height=\"50%\" alt=\"img1\"></p>\n"},{"title":"Linux 如何避免重複執行特定jar","date":"2018-03-17T13:00:34.000Z","_content":"\n因為Linux是真正多人多工，若是在不同電腦上遠端登入\n執行同一個特定jar，就會造成重複執行\n所以在一般情況下，會寫script 做成 service\n再透過 start stop restart 去執行\n\n但是有些時候我們只是要執行一個Java的小程式\n不會想要花費時間將它製作成 service \n所以只需寫一個script，去檢查特定程式的JVM是否已經啟動\n若是已經啟動的話就刪除目前執行的JVM\n\n\n```shell kill jar JVM, if exist .sh\n    PID=$(ps aux | grep jar-[0-9] | awk '{print $2}')\n    echo \"PID: \"$PID\n    if [ -z $PID ]; then\n        echo \"not exist PID\"\n    else\n        echo \"kill PID: \"$PID\n        kill -9 $PID\n    fi\n\n```\n<!-- more -->\n\n第1行 ps aux 是找出所有user目前執行中的process\n接著使用 grep 找出特定的process，因為這個jar會帶版號\n例如： jar-1.1.jar 或是升級後 jar-1.2.jar\n所以多判斷帶版號的regex\n最後執行 awk 印出第2欄（因為第2欄是process的PID）\n第3行是檢查PID是否為空字串\n若PID不是空字串就表示JVM已經存在需要執行第7行去強制刪除JVM\nPS: 要不要刪除JVM就看個人了，因為這是用在開發中的jar，需要重新執行，所以使用kill\n\n這樣一個簡單的script就完成了，現在只需要在執行jar前呼叫此.sh檔\n就可以避免重複執行了\n\n","source":"_posts/Linux-如何避免重複執行特定jar.md","raw":"---\ntitle: Linux 如何避免重複執行特定jar\ndate: 2018-03-17 21:00:34\ntags:\n- shell\n---\n\n因為Linux是真正多人多工，若是在不同電腦上遠端登入\n執行同一個特定jar，就會造成重複執行\n所以在一般情況下，會寫script 做成 service\n再透過 start stop restart 去執行\n\n但是有些時候我們只是要執行一個Java的小程式\n不會想要花費時間將它製作成 service \n所以只需寫一個script，去檢查特定程式的JVM是否已經啟動\n若是已經啟動的話就刪除目前執行的JVM\n\n\n```shell kill jar JVM, if exist .sh\n    PID=$(ps aux | grep jar-[0-9] | awk '{print $2}')\n    echo \"PID: \"$PID\n    if [ -z $PID ]; then\n        echo \"not exist PID\"\n    else\n        echo \"kill PID: \"$PID\n        kill -9 $PID\n    fi\n\n```\n<!-- more -->\n\n第1行 ps aux 是找出所有user目前執行中的process\n接著使用 grep 找出特定的process，因為這個jar會帶版號\n例如： jar-1.1.jar 或是升級後 jar-1.2.jar\n所以多判斷帶版號的regex\n最後執行 awk 印出第2欄（因為第2欄是process的PID）\n第3行是檢查PID是否為空字串\n若PID不是空字串就表示JVM已經存在需要執行第7行去強制刪除JVM\nPS: 要不要刪除JVM就看個人了，因為這是用在開發中的jar，需要重新執行，所以使用kill\n\n這樣一個簡單的script就完成了，現在只需要在執行jar前呼叫此.sh檔\n就可以避免重複執行了\n\n","slug":"Linux-如何避免重複執行特定jar","published":1,"updated":"2018-04-01T13:49:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bok00032bpj5c8sh2oj","content":"<p>因為Linux是真正多人多工，若是在不同電腦上遠端登入<br>執行同一個特定jar，就會造成重複執行<br>所以在一般情況下，會寫script 做成 service<br>再透過 start stop restart 去執行</p>\n<p>但是有些時候我們只是要執行一個Java的小程式<br>不會想要花費時間將它製作成 service<br>所以只需寫一個script，去檢查特定程式的JVM是否已經啟動<br>若是已經啟動的話就刪除目前執行的JVM</p>\n<figure class=\"highlight shell\"><figcaption><span>kill jar JVM, if exist .sh</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PID=$(ps aux | grep jar-[0-9] | awk '&#123;print $2&#125;')</span><br><span class=\"line\">echo \"PID: \"$PID</span><br><span class=\"line\">if [ -z $PID ]; then</span><br><span class=\"line\">    echo \"not exist PID\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo \"kill PID: \"$PID</span><br><span class=\"line\">    kill -9 $PID</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>第1行 ps aux 是找出所有user目前執行中的process<br>接著使用 grep 找出特定的process，因為這個jar會帶版號<br>例如： jar-1.1.jar 或是升級後 jar-1.2.jar<br>所以多判斷帶版號的regex<br>最後執行 awk 印出第2欄（因為第2欄是process的PID）<br>第3行是檢查PID是否為空字串<br>若PID不是空字串就表示JVM已經存在需要執行第7行去強制刪除JVM<br>PS: 要不要刪除JVM就看個人了，因為這是用在開發中的jar，需要重新執行，所以使用kill</p>\n<p>這樣一個簡單的script就完成了，現在只需要在執行jar前呼叫此.sh檔<br>就可以避免重複執行了</p>\n","site":{"data":{}},"excerpt":"<p>因為Linux是真正多人多工，若是在不同電腦上遠端登入<br>執行同一個特定jar，就會造成重複執行<br>所以在一般情況下，會寫script 做成 service<br>再透過 start stop restart 去執行</p>\n<p>但是有些時候我們只是要執行一個Java的小程式<br>不會想要花費時間將它製作成 service<br>所以只需寫一個script，去檢查特定程式的JVM是否已經啟動<br>若是已經啟動的話就刪除目前執行的JVM</p>\n<figure class=\"highlight shell\"><figcaption><span>kill jar JVM, if exist .sh</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PID=$(ps aux | grep jar-[0-9] | awk '&#123;print $2&#125;')</span><br><span class=\"line\">echo \"PID: \"$PID</span><br><span class=\"line\">if [ -z $PID ]; then</span><br><span class=\"line\">    echo \"not exist PID\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo \"kill PID: \"$PID</span><br><span class=\"line\">    kill -9 $PID</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>","more":"<p>第1行 ps aux 是找出所有user目前執行中的process<br>接著使用 grep 找出特定的process，因為這個jar會帶版號<br>例如： jar-1.1.jar 或是升級後 jar-1.2.jar<br>所以多判斷帶版號的regex<br>最後執行 awk 印出第2欄（因為第2欄是process的PID）<br>第3行是檢查PID是否為空字串<br>若PID不是空字串就表示JVM已經存在需要執行第7行去強制刪除JVM<br>PS: 要不要刪除JVM就看個人了，因為這是用在開發中的jar，需要重新執行，所以使用kill</p>\n<p>這樣一個簡單的script就完成了，現在只需要在執行jar前呼叫此.sh檔<br>就可以避免重複執行了</p>"},{"title":"你真的了解Java中的Thread運作嗎？ - 容易讓人誤解的synchronized method","date":"2018-04-29T14:11:28.000Z","_content":"今天下午無意中聽到後方正在討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”\n最後一句話聽起來怪怪的...“thread是鎖method的”，真的是這樣嗎？\n\n我在剛接觸java的時候，其實也有相同的疑問，因為在某個method上面增加synchronized很直覺的會認為只是會鎖此method，但若實際寫code去驗證的話，會發現不是鎖method而是會鎖住整個object，很多時候程式實際運作與自己想像是有落差的，不論是書上寫的或者在技術blog上讀到的都不一定是對的，只有自己嘗試寫code執行過才會知道\n","source":"_posts/你真的了解Java中的Thread運作嗎？-容易讓人誤解的synchronized-method.md","raw":"---\ntitle: 你真的了解Java中的Thread運作嗎？ - 容易讓人誤解的synchronized method\ndate: 2018-04-29 22:11:28\ntags:\n- java\n- thread\n---\n今天下午無意中聽到後方正在討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”\n最後一句話聽起來怪怪的...“thread是鎖method的”，真的是這樣嗎？\n\n我在剛接觸java的時候，其實也有相同的疑問，因為在某個method上面增加synchronized很直覺的會認為只是會鎖此method，但若實際寫code去驗證的話，會發現不是鎖method而是會鎖住整個object，很多時候程式實際運作與自己想像是有落差的，不論是書上寫的或者在技術blog上讀到的都不一定是對的，只有自己嘗試寫code執行過才會知道\n","slug":"你真的了解Java中的Thread運作嗎？-容易讓人誤解的synchronized-method","published":1,"updated":"2019-10-11T08:29:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bom00042bpjq5azf4z3","content":"<p>今天下午無意中聽到後方正在討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”<br>最後一句話聽起來怪怪的…“thread是鎖method的”，真的是這樣嗎？</p>\n<p>我在剛接觸java的時候，其實也有相同的疑問，因為在某個method上面增加synchronized很直覺的會認為只是會鎖此method，但若實際寫code去驗證的話，會發現不是鎖method而是會鎖住整個object，很多時候程式實際運作與自己想像是有落差的，不論是書上寫的或者在技術blog上讀到的都不一定是對的，只有自己嘗試寫code執行過才會知道</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天下午無意中聽到後方正在討論java的同事說“在method上面加上synchronized後，當多個thread執行此method時，同一時間只會有一個thread可以進入執行，但沒有synchronized的method不會被鎖住可以進入執行，因為thread是鎖method的”<br>最後一句話聽起來怪怪的…“thread是鎖method的”，真的是這樣嗎？</p>\n<p>我在剛接觸java的時候，其實也有相同的疑問，因為在某個method上面增加synchronized很直覺的會認為只是會鎖此method，但若實際寫code去驗證的話，會發現不是鎖method而是會鎖住整個object，很多時候程式實際運作與自己想像是有落差的，不論是書上寫的或者在技術blog上讀到的都不一定是對的，只有自己嘗試寫code執行過才會知道</p>\n"},{"title":"以前設計的APP Icon","date":"2019-10-10T14:13:18.000Z","_content":"\n以前設計的APP Icon，全部都是利用下班時在家用自己筆電內的illustrator繪製\n但無償提供給前公司使用沒有收取任何費用，所以沒有版權的問題\n我也沒有打算使用這些Icon營利，但為了維護前公司的權利，我並不允許前公司以外的人使用這些Icon\n在這裡只是單純記錄用\n\n<img src=\"/images/app-icon-001.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 1\"/>\n<img src=\"/images/app-icon-002.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 2\"/>\n\n\n下面是第一代的Icon，在公司新成立時繪製的，有加反光的效果，在新版已移除\n\n<img src=\"/images/app-icon-003.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 3\"/>\n","source":"_posts/以前設計的APP-Icon.md","raw":"---\ntitle: 以前設計的APP Icon\ndate: 2019-10-10 22:13:18\ntags:\n- illustrator\n---\n\n以前設計的APP Icon，全部都是利用下班時在家用自己筆電內的illustrator繪製\n但無償提供給前公司使用沒有收取任何費用，所以沒有版權的問題\n我也沒有打算使用這些Icon營利，但為了維護前公司的權利，我並不允許前公司以外的人使用這些Icon\n在這裡只是單純記錄用\n\n<img src=\"/images/app-icon-001.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 1\"/>\n<img src=\"/images/app-icon-002.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 2\"/>\n\n\n下面是第一代的Icon，在公司新成立時繪製的，有加反光的效果，在新版已移除\n\n<img src=\"/images/app-icon-003.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 3\"/>\n","slug":"以前設計的APP-Icon","published":1,"updated":"2019-10-10T15:16:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bon00052bpj7uz02mma","content":"<p>以前設計的APP Icon，全部都是利用下班時在家用自己筆電內的illustrator繪製<br>但無償提供給前公司使用沒有收取任何費用，所以沒有版權的問題<br>我也沒有打算使用這些Icon營利，但為了維護前公司的權利，我並不允許前公司以外的人使用這些Icon<br>在這裡只是單純記錄用</p>\n<p><img src=\"/images/app-icon-001.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 1\"><br><img src=\"/images/app-icon-002.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 2\"></p>\n<p>下面是第一代的Icon，在公司新成立時繪製的，有加反光的效果，在新版已移除</p>\n<p><img src=\"/images/app-icon-003.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 3\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前設計的APP Icon，全部都是利用下班時在家用自己筆電內的illustrator繪製<br>但無償提供給前公司使用沒有收取任何費用，所以沒有版權的問題<br>我也沒有打算使用這些Icon營利，但為了維護前公司的權利，我並不允許前公司以外的人使用這些Icon<br>在這裡只是單純記錄用</p>\n<p><img src=\"/images/app-icon-001.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 1\"><br><img src=\"/images/app-icon-002.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 2\"></p>\n<p>下面是第一代的Icon，在公司新成立時繪製的，有加反光的效果，在新版已移除</p>\n<p><img src=\"/images/app-icon-003.png\" width=\"50%\" height=\"50%\" alt=\"new icon list 3\"></p>\n"},{"title":"使用 Gradle 自動初始化 Spock","date":"2018-05-20T14:23:10.000Z","_content":"\n第一次接觸gradle是從v1.7這個版本開始的(2013年)\n工作上則是使用v2.2版本(2014年)，開發上測試是使用junit\n但私底下都使用Spock來測試我自己寫的程式\n因為寫過Spock後就不會想寫junit了... 只是工作上就是規定使用junit...也只能乖乖配合\n\n最近升級gradle順便看一下有支援哪些新的功能，發現從v2.11開始可以直接建立Spock的專案了\n[gradle v2.11 release-notes](https://docs.gradle.org/2.11/release-notes.html?_ga=2.65549740.32788303.1526825308-661634901.1526653677)\n\n再往前查看了一下，發現早在v2.6版開始就有支援Spock，只是沒有指令可以直接建立Spock測試，所以只能算半成品吧，直到v2.11後才算完整\n[gradle v2.6 release-notes](https://docs.gradle.org/2.6/release-notes.html?_ga=2.129521294.32788303.1526825308-661634901.1526653677)\n\n指令很簡單，只需打一行\n```java\ngradle init --type java-library --test-framework spock\n\n```\n想到以後就不需要再自己引入Spock，太感動了\ngradle真的是越來越方便，難怪Android會使用gradle來建立專案\n","source":"_posts/使用-Gradle-自動初始化-Spock.md","raw":"---\ntitle: 使用 Gradle 自動初始化 Spock\ndate: 2018-05-20 22:23:10\ntags:\n- gradle\n- unit test\n---\n\n第一次接觸gradle是從v1.7這個版本開始的(2013年)\n工作上則是使用v2.2版本(2014年)，開發上測試是使用junit\n但私底下都使用Spock來測試我自己寫的程式\n因為寫過Spock後就不會想寫junit了... 只是工作上就是規定使用junit...也只能乖乖配合\n\n最近升級gradle順便看一下有支援哪些新的功能，發現從v2.11開始可以直接建立Spock的專案了\n[gradle v2.11 release-notes](https://docs.gradle.org/2.11/release-notes.html?_ga=2.65549740.32788303.1526825308-661634901.1526653677)\n\n再往前查看了一下，發現早在v2.6版開始就有支援Spock，只是沒有指令可以直接建立Spock測試，所以只能算半成品吧，直到v2.11後才算完整\n[gradle v2.6 release-notes](https://docs.gradle.org/2.6/release-notes.html?_ga=2.129521294.32788303.1526825308-661634901.1526653677)\n\n指令很簡單，只需打一行\n```java\ngradle init --type java-library --test-framework spock\n\n```\n想到以後就不需要再自己引入Spock，太感動了\ngradle真的是越來越方便，難怪Android會使用gradle來建立專案\n","slug":"使用-Gradle-自動初始化-Spock","published":1,"updated":"2018-06-04T15:18:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bop00082bpj9ko9u88t","content":"<p>第一次接觸gradle是從v1.7這個版本開始的(2013年)<br>工作上則是使用v2.2版本(2014年)，開發上測試是使用junit<br>但私底下都使用Spock來測試我自己寫的程式<br>因為寫過Spock後就不會想寫junit了… 只是工作上就是規定使用junit…也只能乖乖配合</p>\n<p>最近升級gradle順便看一下有支援哪些新的功能，發現從v2.11開始可以直接建立Spock的專案了<br><a href=\"https://docs.gradle.org/2.11/release-notes.html?_ga=2.65549740.32788303.1526825308-661634901.1526653677\" target=\"_blank\" rel=\"noopener\">gradle v2.11 release-notes</a></p>\n<p>再往前查看了一下，發現早在v2.6版開始就有支援Spock，只是沒有指令可以直接建立Spock測試，所以只能算半成品吧，直到v2.11後才算完整<br><a href=\"https://docs.gradle.org/2.6/release-notes.html?_ga=2.129521294.32788303.1526825308-661634901.1526653677\" target=\"_blank\" rel=\"noopener\">gradle v2.6 release-notes</a></p>\n<p>指令很簡單，只需打一行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradle init --type java-library --test-framework spock</span><br></pre></td></tr></table></figure></p>\n<p>想到以後就不需要再自己引入Spock，太感動了<br>gradle真的是越來越方便，難怪Android會使用gradle來建立專案</p>\n","site":{"data":{}},"excerpt":"","more":"<p>第一次接觸gradle是從v1.7這個版本開始的(2013年)<br>工作上則是使用v2.2版本(2014年)，開發上測試是使用junit<br>但私底下都使用Spock來測試我自己寫的程式<br>因為寫過Spock後就不會想寫junit了… 只是工作上就是規定使用junit…也只能乖乖配合</p>\n<p>最近升級gradle順便看一下有支援哪些新的功能，發現從v2.11開始可以直接建立Spock的專案了<br><a href=\"https://docs.gradle.org/2.11/release-notes.html?_ga=2.65549740.32788303.1526825308-661634901.1526653677\" target=\"_blank\" rel=\"noopener\">gradle v2.11 release-notes</a></p>\n<p>再往前查看了一下，發現早在v2.6版開始就有支援Spock，只是沒有指令可以直接建立Spock測試，所以只能算半成品吧，直到v2.11後才算完整<br><a href=\"https://docs.gradle.org/2.6/release-notes.html?_ga=2.129521294.32788303.1526825308-661634901.1526653677\" target=\"_blank\" rel=\"noopener\">gradle v2.6 release-notes</a></p>\n<p>指令很簡單，只需打一行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradle init --type java-library --test-framework spock</span><br></pre></td></tr></table></figure></p>\n<p>想到以後就不需要再自己引入Spock，太感動了<br>gradle真的是越來越方便，難怪Android會使用gradle來建立專案</p>\n"},{"title":"使用 WeakReference 解決 Android 發生 memory leak 問題","date":"2018-03-10T13:03:49.000Z","_content":"\n源由:\n前陣子幫離職的同事改寫他的Android APP\n因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash...\n所以需要常常重啟APP\n\n在Android Studio上觀察了一下memory\n執行了一段時間後發現記憶體會不正常增長，就算手動執行GC也無法釋放\n初步研判是發生了memory leak\n馬上做heap dump\n再使用MAT稍微分析了一下\n\n果然...\n<!-- more -->\nactivity的context沒有被正常釋放掉\n主因是activity將自身的context傳給了AsyncTask去執行跟Server拿資料的任務\n因為此APP是屬於Web Service，需要頻繁的執行request\n所以同時間會產生多個AsyncTask\n最終造成多個AsyncTask需等待其他AsyncTask完成任務\n但又佔用activity的context，所以activity無法釋放\n\n簡單的說就是AsyncTask的生命週期比activity的生命週期還要長\n所以activity沒辦法回收memory\n\n確認問題的原因後，接下來就好辦了\n\n首先是解決activity context無法釋放的問題\n在這裡我是將傳入activity context宣告成WeakReference\nWeakReference是Java的弱引用，可以讓 activityContext 可以被系統正常GC\n不會因AsyncTask長期佔用 activityContext 造成 memory 無法釋放的問題發生\n\n```java WeakReference 使用方式\n    WeakReference<Context> contextRef = new WeakReference<Context>(activityContext);\n    if(null != contextRef.get()){//判斷有無被系統GC\n        Context context = contextRef.get();\n        //可以執行到這，就表示 context 還未被系統回收，可繼續做接下來的任務\n    }\n```\n\n但是最佳的做法應該是不要隨意傳遞activity的context，因為他的生命週期非常短暫\n若真的需要使用context的話應該使用application context，而不是activity context\n因為application context是APP的context，所以不像activity context一直不斷被創建和釋放\n只是application context不能用來更新UI\n\n若想使用activity context去更新UI的話，也應該要回歸到activity內部執行\n而不是讓外部的Object直接引用，無形中提高了memory leak發生的風險\n\n\n","source":"_posts/使用-WeakReference-解決-Android-發生-memory-leak-問題.md","raw":"---\ntitle: 使用 WeakReference 解決 Android 發生 memory leak 問題\ndate: 2018-03-10 21:03:49\ntags:\n- java\n- android\n- memory leak\n---\n\n源由:\n前陣子幫離職的同事改寫他的Android APP\n因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash...\n所以需要常常重啟APP\n\n在Android Studio上觀察了一下memory\n執行了一段時間後發現記憶體會不正常增長，就算手動執行GC也無法釋放\n初步研判是發生了memory leak\n馬上做heap dump\n再使用MAT稍微分析了一下\n\n果然...\n<!-- more -->\nactivity的context沒有被正常釋放掉\n主因是activity將自身的context傳給了AsyncTask去執行跟Server拿資料的任務\n因為此APP是屬於Web Service，需要頻繁的執行request\n所以同時間會產生多個AsyncTask\n最終造成多個AsyncTask需等待其他AsyncTask完成任務\n但又佔用activity的context，所以activity無法釋放\n\n簡單的說就是AsyncTask的生命週期比activity的生命週期還要長\n所以activity沒辦法回收memory\n\n確認問題的原因後，接下來就好辦了\n\n首先是解決activity context無法釋放的問題\n在這裡我是將傳入activity context宣告成WeakReference\nWeakReference是Java的弱引用，可以讓 activityContext 可以被系統正常GC\n不會因AsyncTask長期佔用 activityContext 造成 memory 無法釋放的問題發生\n\n```java WeakReference 使用方式\n    WeakReference<Context> contextRef = new WeakReference<Context>(activityContext);\n    if(null != contextRef.get()){//判斷有無被系統GC\n        Context context = contextRef.get();\n        //可以執行到這，就表示 context 還未被系統回收，可繼續做接下來的任務\n    }\n```\n\n但是最佳的做法應該是不要隨意傳遞activity的context，因為他的生命週期非常短暫\n若真的需要使用context的話應該使用application context，而不是activity context\n因為application context是APP的context，所以不像activity context一直不斷被創建和釋放\n只是application context不能用來更新UI\n\n若想使用activity context去更新UI的話，也應該要回歸到activity內部執行\n而不是讓外部的Object直接引用，無形中提高了memory leak發生的風險\n\n\n","slug":"使用-WeakReference-解決-Android-發生-memory-leak-問題","published":1,"updated":"2018-03-25T16:07:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bor00092bpj813xdzj6","content":"<p>源由:<br>前陣子幫離職的同事改寫他的Android APP<br>因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash…<br>所以需要常常重啟APP</p>\n<p>在Android Studio上觀察了一下memory<br>執行了一段時間後發現記憶體會不正常增長，就算手動執行GC也無法釋放<br>初步研判是發生了memory leak<br>馬上做heap dump<br>再使用MAT稍微分析了一下</p>\n<p>果然…<br><a id=\"more\"></a><br>activity的context沒有被正常釋放掉<br>主因是activity將自身的context傳給了AsyncTask去執行跟Server拿資料的任務<br>因為此APP是屬於Web Service，需要頻繁的執行request<br>所以同時間會產生多個AsyncTask<br>最終造成多個AsyncTask需等待其他AsyncTask完成任務<br>但又佔用activity的context，所以activity無法釋放</p>\n<p>簡單的說就是AsyncTask的生命週期比activity的生命週期還要長<br>所以activity沒辦法回收memory</p>\n<p>確認問題的原因後，接下來就好辦了</p>\n<p>首先是解決activity context無法釋放的問題<br>在這裡我是將傳入activity context宣告成WeakReference<br>WeakReference是Java的弱引用，可以讓 activityContext 可以被系統正常GC<br>不會因AsyncTask長期佔用 activityContext 造成 memory 無法釋放的問題發生</p>\n<figure class=\"highlight java\"><figcaption><span>WeakReference 使用方式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;Context&gt; contextRef = <span class=\"keyword\">new</span> WeakReference&lt;Context&gt;(activityContext);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != contextRef.get())&#123;<span class=\"comment\">//判斷有無被系統GC</span></span><br><span class=\"line\">    Context context = contextRef.get();</span><br><span class=\"line\">    <span class=\"comment\">//可以執行到這，就表示 context 還未被系統回收，可繼續做接下來的任務</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是最佳的做法應該是不要隨意傳遞activity的context，因為他的生命週期非常短暫<br>若真的需要使用context的話應該使用application context，而不是activity context<br>因為application context是APP的context，所以不像activity context一直不斷被創建和釋放<br>只是application context不能用來更新UI</p>\n<p>若想使用activity context去更新UI的話，也應該要回歸到activity內部執行<br>而不是讓外部的Object直接引用，無形中提高了memory leak發生的風險</p>\n","site":{"data":{}},"excerpt":"<p>源由:<br>前陣子幫離職的同事改寫他的Android APP<br>因為客戶反映此APP在運行一天之後輕則沒有反應，重則crash…<br>所以需要常常重啟APP</p>\n<p>在Android Studio上觀察了一下memory<br>執行了一段時間後發現記憶體會不正常增長，就算手動執行GC也無法釋放<br>初步研判是發生了memory leak<br>馬上做heap dump<br>再使用MAT稍微分析了一下</p>\n<p>果然…<br>","more":"<br>activity的context沒有被正常釋放掉<br>主因是activity將自身的context傳給了AsyncTask去執行跟Server拿資料的任務<br>因為此APP是屬於Web Service，需要頻繁的執行request<br>所以同時間會產生多個AsyncTask<br>最終造成多個AsyncTask需等待其他AsyncTask完成任務<br>但又佔用activity的context，所以activity無法釋放</p>\n<p>簡單的說就是AsyncTask的生命週期比activity的生命週期還要長<br>所以activity沒辦法回收memory</p>\n<p>確認問題的原因後，接下來就好辦了</p>\n<p>首先是解決activity context無法釋放的問題<br>在這裡我是將傳入activity context宣告成WeakReference<br>WeakReference是Java的弱引用，可以讓 activityContext 可以被系統正常GC<br>不會因AsyncTask長期佔用 activityContext 造成 memory 無法釋放的問題發生</p>\n<figure class=\"highlight java\"><figcaption><span>WeakReference 使用方式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;Context&gt; contextRef = <span class=\"keyword\">new</span> WeakReference&lt;Context&gt;(activityContext);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != contextRef.get())&#123;<span class=\"comment\">//判斷有無被系統GC</span></span><br><span class=\"line\">    Context context = contextRef.get();</span><br><span class=\"line\">    <span class=\"comment\">//可以執行到這，就表示 context 還未被系統回收，可繼續做接下來的任務</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是最佳的做法應該是不要隨意傳遞activity的context，因為他的生命週期非常短暫<br>若真的需要使用context的話應該使用application context，而不是activity context<br>因為application context是APP的context，所以不像activity context一直不斷被創建和釋放<br>只是application context不能用來更新UI</p>\n<p>若想使用activity context去更新UI的話，也應該要回歸到activity內部執行<br>而不是讓外部的Object直接引用，無形中提高了memory leak發生的風險</p>"},{"title":"使用視覺化來解釋數學原理的youtube - 3Blue1Brown","date":"2018-06-24T15:27:40.000Z","_content":"\n在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究\n{% youtube spUNpyF58BY %}\n\n3Blue1Brown上還有許多數學相關視覺化影片，如：線性代數, 微積分, 類神經網路\n{% youtube fNk_zzaMoSs %}\n{% youtube WUvTyaaNkzM %}\n{% youtube aircAruvnKk %}\n","source":"_posts/使用視覺化來解釋數學原理的youtube-3Blue1Brown.md","raw":"---\ntitle: 使用視覺化來解釋數學原理的youtube - 3Blue1Brown\ndate: 2018-06-24 23:27:40\ntags:\n- math\n---\n\n在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究\n{% youtube spUNpyF58BY %}\n\n3Blue1Brown上還有許多數學相關視覺化影片，如：線性代數, 微積分, 類神經網路\n{% youtube fNk_zzaMoSs %}\n{% youtube WUvTyaaNkzM %}\n{% youtube aircAruvnKk %}\n","slug":"使用視覺化來解釋數學原理的youtube-3Blue1Brown","published":1,"updated":"2019-10-11T08:14:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bos000c2bpjjgscmgw3","content":"<p>在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究<br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/spUNpyF58BY\" frameborder=\"0\" allowfullscreen></iframe></div></p>\n<p>3Blue1Brown上還有許多數學相關視覺化影片，如：線性代數, 微積分, 類神經網路<br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/fNk_zzaMoSs\" frameborder=\"0\" allowfullscreen></iframe></div><br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/WUvTyaaNkzM\" frameborder=\"0\" allowfullscreen></iframe></div><br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/aircAruvnKk\" frameborder=\"0\" allowfullscreen></iframe></div></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在搜尋傅立葉轉換時偶然看到的影片，要是在以前念碩士期間有這個youtube影片就好了，想當初自己花很多時間在研究<br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/spUNpyF58BY\" frameborder=\"0\" allowfullscreen></iframe></div></p>\n<p>3Blue1Brown上還有許多數學相關視覺化影片，如：線性代數, 微積分, 類神經網路<br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/fNk_zzaMoSs\" frameborder=\"0\" allowfullscreen></iframe></div><br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/WUvTyaaNkzM\" frameborder=\"0\" allowfullscreen></iframe></div><br><div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/aircAruvnKk\" frameborder=\"0\" allowfullscreen></iframe></div></p>\n"},{"title":"更換hexo themes","date":"2018-02-20T13:41:43.000Z","_content":"\n稍微嘗試更換hexo themes\n雖然原生的landscape theme的介面已經很簡潔\n但還是想要更精簡一些\n\n比較了幾個比較知名的theme\n最後決定使用yilia這個theme\n介面簡潔乾淨而且RWD的效果也不錯\n除了不支援舊版IE以外沒什麼好挑惕的\n最後當然要幫作者github上的yilia專案加顆星\n也順便學習設定disqus當作留言板\n\n\n今天是連假的最後一天\n這幾天有空的時候就練習Git的操作\n感覺不賴\n","source":"_posts/更換hexo-themes.md","raw":"---\ntitle: 更換hexo themes\ndate: 2018-02-20 21:41:43\ntags:\n- hexo\n---\n\n稍微嘗試更換hexo themes\n雖然原生的landscape theme的介面已經很簡潔\n但還是想要更精簡一些\n\n比較了幾個比較知名的theme\n最後決定使用yilia這個theme\n介面簡潔乾淨而且RWD的效果也不錯\n除了不支援舊版IE以外沒什麼好挑惕的\n最後當然要幫作者github上的yilia專案加顆星\n也順便學習設定disqus當作留言板\n\n\n今天是連假的最後一天\n這幾天有空的時候就練習Git的操作\n感覺不賴\n","slug":"更換hexo-themes","published":1,"updated":"2018-03-17T16:26:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bot000d2bpjnwowjrnr","content":"<p>稍微嘗試更換hexo themes<br>雖然原生的landscape theme的介面已經很簡潔<br>但還是想要更精簡一些</p>\n<p>比較了幾個比較知名的theme<br>最後決定使用yilia這個theme<br>介面簡潔乾淨而且RWD的效果也不錯<br>除了不支援舊版IE以外沒什麼好挑惕的<br>最後當然要幫作者github上的yilia專案加顆星<br>也順便學習設定disqus當作留言板</p>\n<p>今天是連假的最後一天<br>這幾天有空的時候就練習Git的操作<br>感覺不賴</p>\n","site":{"data":{}},"excerpt":"","more":"<p>稍微嘗試更換hexo themes<br>雖然原生的landscape theme的介面已經很簡潔<br>但還是想要更精簡一些</p>\n<p>比較了幾個比較知名的theme<br>最後決定使用yilia這個theme<br>介面簡潔乾淨而且RWD的效果也不錯<br>除了不支援舊版IE以外沒什麼好挑惕的<br>最後當然要幫作者github上的yilia專案加顆星<br>也順便學習設定disqus當作留言板</p>\n<p>今天是連假的最後一天<br>這幾天有空的時候就練習Git的操作<br>感覺不賴</p>\n"},{"title":"提升Socket傳送Large file的速度","date":"2018-05-13T15:43:53.000Z","_content":"\n在工作上遇到前端上傳large file後需再透過socket傳送給service處理\n若只是幾kb的小檔案最快的做法當然是直接\n`write(byte[] b, 0, b.length);`\n但是遇到這麼大的檔案不可能這麼做，只能分成多次寫入\n測試過各種方法後，發現直接取得檔案大小後直接切好buffer大小，接著操作OutputStream直接寫入的處理的速度是最快的\n\n其實這個做法其實跟Java本身提供的BufferedOutputStream做法一樣\n只是不需要另外檢查buffer是否寫滿(因為這個做法在一開始就知道要切到哪一個byte)\n也少了一層FilterOutputStream (它們的繼承關係 BufferedOutputStream -> FilterOutputStrean -> OutputStream)\n而是選擇直接操作OutputStream，所以才可以做到如此快速\n\n提醒一下\n這個方式比較不是適合用在\"讀檔\"後使用socket傳送大檔案\n因為讀檔可以邊讀邊傳(寫入)可以有效降低memory的使用量，所以直接串BufferedOutputStream就好\n\n最終的程式碼如下\n<!-- more -->\n```java\n    private static final int BYTE_BUF_SIZE = 8192;\n    \n    private boolean sendCmd(String ip, int port, byte[] byteArray){\n        boolean isSuccess = true;\n        Socket socket = null;\n        int bufSize = BYTE_BUF_SIZE;//一次寫入多少byte\n        int byteArrayLength = byteArray.length;\n        int writeCount = byteArrayLength / bufSize;//分幾次寫\n        int byteRemain = byteArrayLength % bufSize;//剩餘的byte\n        int off = 0;\n        try {\n            socket = new Socket(ip, port);\n            OutputStream out = socket.getOutputStream();\n            for(int count=0; count<writeCount; count++){\n                out.write(byteArray, off, bufSize);\n                off += bufSize;\n            }\n            if(byteRemain > 0){//最後有剩(不足buf的)\n                out.write(byteArray, off, byteRemain);\n            }\n            out.flush();\n            out.close();\n        } catch (IOException e) {\n            logger.warn(\"use socket send command fail!!, ip: {}, port: {} exceptionMsg:{}\", ip, port, e);\n            isSuccess = false;\n        }finally {\n            if(socket != null){\n                try {\n                    socket.close();\n                } catch (IOException e1) {\n                    logger.warn(\"socket close fail: {}\", e1);\n                    isSuccess = false;\n                }\n            }\n            return isSuccess;\n        }\n    }\n```\n","source":"_posts/提升Socket傳送Large-file的速度.md","raw":"---\ntitle: 提升Socket傳送Large file的速度\ndate: 2018-05-13 23:43:53\ntags:\n- java\n---\n\n在工作上遇到前端上傳large file後需再透過socket傳送給service處理\n若只是幾kb的小檔案最快的做法當然是直接\n`write(byte[] b, 0, b.length);`\n但是遇到這麼大的檔案不可能這麼做，只能分成多次寫入\n測試過各種方法後，發現直接取得檔案大小後直接切好buffer大小，接著操作OutputStream直接寫入的處理的速度是最快的\n\n其實這個做法其實跟Java本身提供的BufferedOutputStream做法一樣\n只是不需要另外檢查buffer是否寫滿(因為這個做法在一開始就知道要切到哪一個byte)\n也少了一層FilterOutputStream (它們的繼承關係 BufferedOutputStream -> FilterOutputStrean -> OutputStream)\n而是選擇直接操作OutputStream，所以才可以做到如此快速\n\n提醒一下\n這個方式比較不是適合用在\"讀檔\"後使用socket傳送大檔案\n因為讀檔可以邊讀邊傳(寫入)可以有效降低memory的使用量，所以直接串BufferedOutputStream就好\n\n最終的程式碼如下\n<!-- more -->\n```java\n    private static final int BYTE_BUF_SIZE = 8192;\n    \n    private boolean sendCmd(String ip, int port, byte[] byteArray){\n        boolean isSuccess = true;\n        Socket socket = null;\n        int bufSize = BYTE_BUF_SIZE;//一次寫入多少byte\n        int byteArrayLength = byteArray.length;\n        int writeCount = byteArrayLength / bufSize;//分幾次寫\n        int byteRemain = byteArrayLength % bufSize;//剩餘的byte\n        int off = 0;\n        try {\n            socket = new Socket(ip, port);\n            OutputStream out = socket.getOutputStream();\n            for(int count=0; count<writeCount; count++){\n                out.write(byteArray, off, bufSize);\n                off += bufSize;\n            }\n            if(byteRemain > 0){//最後有剩(不足buf的)\n                out.write(byteArray, off, byteRemain);\n            }\n            out.flush();\n            out.close();\n        } catch (IOException e) {\n            logger.warn(\"use socket send command fail!!, ip: {}, port: {} exceptionMsg:{}\", ip, port, e);\n            isSuccess = false;\n        }finally {\n            if(socket != null){\n                try {\n                    socket.close();\n                } catch (IOException e1) {\n                    logger.warn(\"socket close fail: {}\", e1);\n                    isSuccess = false;\n                }\n            }\n            return isSuccess;\n        }\n    }\n```\n","slug":"提升Socket傳送Large-file的速度","published":1,"updated":"2018-06-04T15:17:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bov000f2bpjmvx8fhd8","content":"<p>在工作上遇到前端上傳large file後需再透過socket傳送給service處理<br>若只是幾kb的小檔案最快的做法當然是直接<br><code>write(byte[] b, 0, b.length);</code><br>但是遇到這麼大的檔案不可能這麼做，只能分成多次寫入<br>測試過各種方法後，發現直接取得檔案大小後直接切好buffer大小，接著操作OutputStream直接寫入的處理的速度是最快的</p>\n<p>其實這個做法其實跟Java本身提供的BufferedOutputStream做法一樣<br>只是不需要另外檢查buffer是否寫滿(因為這個做法在一開始就知道要切到哪一個byte)<br>也少了一層FilterOutputStream (它們的繼承關係 BufferedOutputStream -&gt; FilterOutputStrean -&gt; OutputStream)<br>而是選擇直接操作OutputStream，所以才可以做到如此快速</p>\n<p>提醒一下<br>這個方式比較不是適合用在”讀檔”後使用socket傳送大檔案<br>因為讀檔可以邊讀邊傳(寫入)可以有效降低memory的使用量，所以直接串BufferedOutputStream就好</p>\n<p>最終的程式碼如下<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BYTE_BUF_SIZE = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendCmd</span><span class=\"params\">(String ip, <span class=\"keyword\">int</span> port, <span class=\"keyword\">byte</span>[] byteArray)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufSize = BYTE_BUF_SIZE;<span class=\"comment\">//一次寫入多少byte</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> byteArrayLength = byteArray.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> writeCount = byteArrayLength / bufSize;<span class=\"comment\">//分幾次寫</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> byteRemain = byteArrayLength % bufSize;<span class=\"comment\">//剩餘的byte</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> off = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        socket = <span class=\"keyword\">new</span> Socket(ip, port);</span><br><span class=\"line\">        OutputStream out = socket.getOutputStream();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> count=<span class=\"number\">0</span>; count&lt;writeCount; count++)&#123;</span><br><span class=\"line\">            out.write(byteArray, off, bufSize);</span><br><span class=\"line\">            off += bufSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(byteRemain &gt; <span class=\"number\">0</span>)&#123;<span class=\"comment\">//最後有剩(不足buf的)</span></span><br><span class=\"line\">            out.write(byteArray, off, byteRemain);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"use socket send command fail!!, ip: &#123;&#125;, port: &#123;&#125; exceptionMsg:&#123;&#125;\"</span>, ip, port, e);</span><br><span class=\"line\">        isSuccess = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(socket != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                socket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e1) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"socket close fail: &#123;&#125;\"</span>, e1);</span><br><span class=\"line\">                isSuccess = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSuccess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>在工作上遇到前端上傳large file後需再透過socket傳送給service處理<br>若只是幾kb的小檔案最快的做法當然是直接<br><code>write(byte[] b, 0, b.length);</code><br>但是遇到這麼大的檔案不可能這麼做，只能分成多次寫入<br>測試過各種方法後，發現直接取得檔案大小後直接切好buffer大小，接著操作OutputStream直接寫入的處理的速度是最快的</p>\n<p>其實這個做法其實跟Java本身提供的BufferedOutputStream做法一樣<br>只是不需要另外檢查buffer是否寫滿(因為這個做法在一開始就知道要切到哪一個byte)<br>也少了一層FilterOutputStream (它們的繼承關係 BufferedOutputStream -&gt; FilterOutputStrean -&gt; OutputStream)<br>而是選擇直接操作OutputStream，所以才可以做到如此快速</p>\n<p>提醒一下<br>這個方式比較不是適合用在”讀檔”後使用socket傳送大檔案<br>因為讀檔可以邊讀邊傳(寫入)可以有效降低memory的使用量，所以直接串BufferedOutputStream就好</p>\n<p>最終的程式碼如下<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BYTE_BUF_SIZE = <span class=\"number\">8192</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendCmd</span><span class=\"params\">(String ip, <span class=\"keyword\">int</span> port, <span class=\"keyword\">byte</span>[] byteArray)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bufSize = BYTE_BUF_SIZE;<span class=\"comment\">//一次寫入多少byte</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> byteArrayLength = byteArray.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> writeCount = byteArrayLength / bufSize;<span class=\"comment\">//分幾次寫</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> byteRemain = byteArrayLength % bufSize;<span class=\"comment\">//剩餘的byte</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> off = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        socket = <span class=\"keyword\">new</span> Socket(ip, port);</span><br><span class=\"line\">        OutputStream out = socket.getOutputStream();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> count=<span class=\"number\">0</span>; count&lt;writeCount; count++)&#123;</span><br><span class=\"line\">            out.write(byteArray, off, bufSize);</span><br><span class=\"line\">            off += bufSize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(byteRemain &gt; <span class=\"number\">0</span>)&#123;<span class=\"comment\">//最後有剩(不足buf的)</span></span><br><span class=\"line\">            out.write(byteArray, off, byteRemain);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"use socket send command fail!!, ip: &#123;&#125;, port: &#123;&#125; exceptionMsg:&#123;&#125;\"</span>, ip, port, e);</span><br><span class=\"line\">        isSuccess = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(socket != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                socket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e1) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"socket close fail: &#123;&#125;\"</span>, e1);</span><br><span class=\"line\">                isSuccess = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSuccess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"標準常態分佈的機率密度函數","date":"2018-03-24T14:03:21.000Z","_content":"\n前陣子在做SPC逆向工程...\n為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念\n皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果\n為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差...\n\n下一個任務是需要產生機率密度函數去看資料的離散程度...\n至於什麼是常態分佈，可以到{% link 常態分佈wiki https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83 %}上看，應該會比我自己說還要詳細\n一直很好奇為什麼要定義成鐘型，看了下面的youtube影片就才了解，這是自然界的一種規律(巧合？)\n\n{% youtube 4HpvBZnHOVI %}\n\n許多球從中間落下（期望值的位置），最終形成的結果接近於鐘型\n\n上面簡介完了，接著進入主題，開始剖析標準常態分佈的機率密度函數的公式\n$ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $\n\n如果直接從wiki看完公式後，很容易實作出來，只是我更想知道公式背後的原理\n以下是我看書和上網查完資料後，根據自己理解所歸納的結果(趁印象深刻趕快記錄下來)\n\n這時需要將公式拆成兩個部分來看\n現在先看 $ f(x) = \\exp(-{x^2}) $ 這部分：\n\n為什麼要使用 $ -x^2 $ 呢？ \n我們知道$ x^2 $函數是開口向上的鐘型形狀，如下圖所示(以下圖片都是透過Maxima產生)：\n![x^2](/images/st-001.png)\n但我們要的鐘型是開口向下，想要開口向下只需要乘上-1，即 $ -x^2 $\n![-x^2](/images/st-002.png)\n\n接下來看整個 $ \\exp(-{x^2}) $ \n因為經過 $ -x^2 $ 的函數所得的的值是“恆負”的(除了頂點值為0)，永遠落在第二和第三象限\n但是當 $ -x^2 $ 當作常數為底的指數時，透過函數所得到的值是“恆正”的，就會落在第一和第四象限上\n以下是 $ 3^{-x^2} $的函數圖形\n![x^2](/images/st-003.png)\n其實任何常數指數為 $ -x^2 $ 都為鐘型圖形，如下圖為$ 100^{-x^2} $的函數圖形\n![x^2](/images/st-004.png)\n<!-- more -->\n\n雖然取任何常數都可以形成鐘型，那為什麼要取exp當作底呢？\n主要是需要它的部分特性，主要有以下五點：\n1. 左右對稱(以0為中心點，常數c與-c的值會得到相同值)\n2. x軸為0時(中心點)， $ f(0) $ 會取得最大值(鐘型的最高點)\n3. 隨著x值逐漸遠離0時(中心點)，值會漸漸縮小，且值“不會是負的”(這點很重要，因為機率值不可為負的)\n4. 當x趨近於無窮大或趨近於負無窮大時，值趨近於0\n5. 比較好做積分...(連續型的機率是透過計算面積的方式去獲得區間範圍內的機率所以要做積分)\n\n但是只有 $ f(x) = \\exp(-{x^2}) $ 是不夠的，因為對機率來說，總體 $ P(\\Omega) = 1 $\n所以從負無限大到無限大做積分整個 $ f(x) $的總面積必須是1\n嘗試對 $ \\exp(-{x^2}) $從負無窮大到無窮大做積分，得到以下結果\n![x^2](/images/st-005.png)\n總面積會是 $ \\sqrt{\\pi} $ ，所以要讓值為1的方法就是除以 $ \\sqrt{\\pi} $ \n最終會得到 $ f(x) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $\n我們得到了常態分佈的機率密度函數，但還不能稱為“標準”常態分佈的機率密度函數\n因為要達到“標準”的要求還需要有以下三個特性：\n\n1. 期望值( $ \\mu $ )為0\n2. 變異數( $ Var $ )為1\n3. 標準差( $ \\sigma $ )為1\n\n記做 $ N(\\mu, \\sigma) $， 求 $ N(0, 1) $\n但目前得到的機率分佈函數是 $ N(0, {1 \\over \\sqrt{2}}) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $ 這不符合標準的定義，不是我們要的\n\n我們先從wiki上看看連續型隨機變數求期望值和變異數的公式:\n\n$ E[X] = \\int xf(x)dx $\n$ Var(x) = E[(x-\\mu)^2] $\n\n因為標準的期望值為0，則 $ \\mu = 0 $ ，帶入後得到 $ Var(x) = E[x^2] $\n\n先令$ g(x) = af(ax) $，其中a是一個大於零的常數，我們需要求出a值\na值需要滿足 $ \\int x^2g(x) = Var(x) $ 積分等於1\n$ \\int x^2g(x) $ 積分後求得 $ 1 \\over {2a^2} $，因為 $ {1 \\over {2a^2}} = 1$\n所以得到$ a = {1 \\over \\sqrt{2}} $可滿足 $ Var(x) = 1 $ 且 $ \\mu = 0 $\n也可以求得 $ \\sigma = \\sqrt{Var(x)} = 1 $，滿足前面所提到的三個條件\n$ N(0, 1) = {1 \\over \\sqrt{2}} f({x \\over \\sqrt{2}}) $ 帶入公式後得到 $ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $\n這樣就符合“標準”常態機率密度函數\n\n在理解後再回頭看公式，就不覺得怪了\n以上所做的一切努力都是為了“湊出”滿足機率定義的函數\n","source":"_posts/標準常態分佈的機率密度函數.md","raw":"---\ntitle: 標準常態分佈的機率密度函數\ndate: 2018-03-24 22:03:21\ntags:\n- math\n- probability\n- statistics\n---\n\n前陣子在做SPC逆向工程...\n為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念\n皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果\n為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差...\n\n下一個任務是需要產生機率密度函數去看資料的離散程度...\n至於什麼是常態分佈，可以到{% link 常態分佈wiki https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83 %}上看，應該會比我自己說還要詳細\n一直很好奇為什麼要定義成鐘型，看了下面的youtube影片就才了解，這是自然界的一種規律(巧合？)\n\n{% youtube 4HpvBZnHOVI %}\n\n許多球從中間落下（期望值的位置），最終形成的結果接近於鐘型\n\n上面簡介完了，接著進入主題，開始剖析標準常態分佈的機率密度函數的公式\n$ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $\n\n如果直接從wiki看完公式後，很容易實作出來，只是我更想知道公式背後的原理\n以下是我看書和上網查完資料後，根據自己理解所歸納的結果(趁印象深刻趕快記錄下來)\n\n這時需要將公式拆成兩個部分來看\n現在先看 $ f(x) = \\exp(-{x^2}) $ 這部分：\n\n為什麼要使用 $ -x^2 $ 呢？ \n我們知道$ x^2 $函數是開口向上的鐘型形狀，如下圖所示(以下圖片都是透過Maxima產生)：\n![x^2](/images/st-001.png)\n但我們要的鐘型是開口向下，想要開口向下只需要乘上-1，即 $ -x^2 $\n![-x^2](/images/st-002.png)\n\n接下來看整個 $ \\exp(-{x^2}) $ \n因為經過 $ -x^2 $ 的函數所得的的值是“恆負”的(除了頂點值為0)，永遠落在第二和第三象限\n但是當 $ -x^2 $ 當作常數為底的指數時，透過函數所得到的值是“恆正”的，就會落在第一和第四象限上\n以下是 $ 3^{-x^2} $的函數圖形\n![x^2](/images/st-003.png)\n其實任何常數指數為 $ -x^2 $ 都為鐘型圖形，如下圖為$ 100^{-x^2} $的函數圖形\n![x^2](/images/st-004.png)\n<!-- more -->\n\n雖然取任何常數都可以形成鐘型，那為什麼要取exp當作底呢？\n主要是需要它的部分特性，主要有以下五點：\n1. 左右對稱(以0為中心點，常數c與-c的值會得到相同值)\n2. x軸為0時(中心點)， $ f(0) $ 會取得最大值(鐘型的最高點)\n3. 隨著x值逐漸遠離0時(中心點)，值會漸漸縮小，且值“不會是負的”(這點很重要，因為機率值不可為負的)\n4. 當x趨近於無窮大或趨近於負無窮大時，值趨近於0\n5. 比較好做積分...(連續型的機率是透過計算面積的方式去獲得區間範圍內的機率所以要做積分)\n\n但是只有 $ f(x) = \\exp(-{x^2}) $ 是不夠的，因為對機率來說，總體 $ P(\\Omega) = 1 $\n所以從負無限大到無限大做積分整個 $ f(x) $的總面積必須是1\n嘗試對 $ \\exp(-{x^2}) $從負無窮大到無窮大做積分，得到以下結果\n![x^2](/images/st-005.png)\n總面積會是 $ \\sqrt{\\pi} $ ，所以要讓值為1的方法就是除以 $ \\sqrt{\\pi} $ \n最終會得到 $ f(x) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $\n我們得到了常態分佈的機率密度函數，但還不能稱為“標準”常態分佈的機率密度函數\n因為要達到“標準”的要求還需要有以下三個特性：\n\n1. 期望值( $ \\mu $ )為0\n2. 變異數( $ Var $ )為1\n3. 標準差( $ \\sigma $ )為1\n\n記做 $ N(\\mu, \\sigma) $， 求 $ N(0, 1) $\n但目前得到的機率分佈函數是 $ N(0, {1 \\over \\sqrt{2}}) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $ 這不符合標準的定義，不是我們要的\n\n我們先從wiki上看看連續型隨機變數求期望值和變異數的公式:\n\n$ E[X] = \\int xf(x)dx $\n$ Var(x) = E[(x-\\mu)^2] $\n\n因為標準的期望值為0，則 $ \\mu = 0 $ ，帶入後得到 $ Var(x) = E[x^2] $\n\n先令$ g(x) = af(ax) $，其中a是一個大於零的常數，我們需要求出a值\na值需要滿足 $ \\int x^2g(x) = Var(x) $ 積分等於1\n$ \\int x^2g(x) $ 積分後求得 $ 1 \\over {2a^2} $，因為 $ {1 \\over {2a^2}} = 1$\n所以得到$ a = {1 \\over \\sqrt{2}} $可滿足 $ Var(x) = 1 $ 且 $ \\mu = 0 $\n也可以求得 $ \\sigma = \\sqrt{Var(x)} = 1 $，滿足前面所提到的三個條件\n$ N(0, 1) = {1 \\over \\sqrt{2}} f({x \\over \\sqrt{2}}) $ 帶入公式後得到 $ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $\n這樣就符合“標準”常態機率密度函數\n\n在理解後再回頭看公式，就不覺得怪了\n以上所做的一切努力都是為了“湊出”滿足機率定義的函數\n","slug":"標準常態分佈的機率密度函數","published":1,"updated":"2019-10-11T10:03:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bow000h2bpjp0n43pdk","content":"<p>前陣子在做SPC逆向工程…<br>為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念<br>皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果<br>為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差…</p>\n<p>下一個任務是需要產生機率密度函數去看資料的離散程度…<br>至於什麼是常態分佈，可以到<a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">常態分佈wiki</a>上看，應該會比我自己說還要詳細<br>一直很好奇為什麼要定義成鐘型，看了下面的youtube影片就才了解，這是自然界的一種規律(巧合？)</p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/4HpvBZnHOVI\" frameborder=\"0\" allowfullscreen></iframe></div>\n<p>許多球從中間落下（期望值的位置），最終形成的結果接近於鐘型</p>\n<p>上面簡介完了，接著進入主題，開始剖析標準常態分佈的機率密度函數的公式<br>$ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $</p>\n<p>如果直接從wiki看完公式後，很容易實作出來，只是我更想知道公式背後的原理<br>以下是我看書和上網查完資料後，根據自己理解所歸納的結果(趁印象深刻趕快記錄下來)</p>\n<p>這時需要將公式拆成兩個部分來看<br>現在先看 $ f(x) = \\exp(-{x^2}) $ 這部分：</p>\n<p>為什麼要使用 $ -x^2 $ 呢？<br>我們知道$ x^2 $函數是開口向上的鐘型形狀，如下圖所示(以下圖片都是透過Maxima產生)：<br><img src=\"/images/st-001.png\" alt=\"x^2\"><br>但我們要的鐘型是開口向下，想要開口向下只需要乘上-1，即 $ -x^2 $<br><img src=\"/images/st-002.png\" alt=\"-x^2\"></p>\n<p>接下來看整個 $ \\exp(-{x^2}) $<br>因為經過 $ -x^2 $ 的函數所得的的值是“恆負”的(除了頂點值為0)，永遠落在第二和第三象限<br>但是當 $ -x^2 $ 當作常數為底的指數時，透過函數所得到的值是“恆正”的，就會落在第一和第四象限上<br>以下是 $ 3^{-x^2} $的函數圖形<br><img src=\"/images/st-003.png\" alt=\"x^2\"><br>其實任何常數指數為 $ -x^2 $ 都為鐘型圖形，如下圖為$ 100^{-x^2} $的函數圖形<br><img src=\"/images/st-004.png\" alt=\"x^2\"><br><a id=\"more\"></a></p>\n<p>雖然取任何常數都可以形成鐘型，那為什麼要取exp當作底呢？<br>主要是需要它的部分特性，主要有以下五點：</p>\n<ol>\n<li>左右對稱(以0為中心點，常數c與-c的值會得到相同值)</li>\n<li>x軸為0時(中心點)， $ f(0) $ 會取得最大值(鐘型的最高點)</li>\n<li>隨著x值逐漸遠離0時(中心點)，值會漸漸縮小，且值“不會是負的”(這點很重要，因為機率值不可為負的)</li>\n<li>當x趨近於無窮大或趨近於負無窮大時，值趨近於0</li>\n<li>比較好做積分…(連續型的機率是透過計算面積的方式去獲得區間範圍內的機率所以要做積分)</li>\n</ol>\n<p>但是只有 $ f(x) = \\exp(-{x^2}) $ 是不夠的，因為對機率來說，總體 $ P(\\Omega) = 1 $<br>所以從負無限大到無限大做積分整個 $ f(x) $的總面積必須是1<br>嘗試對 $ \\exp(-{x^2}) $從負無窮大到無窮大做積分，得到以下結果<br><img src=\"/images/st-005.png\" alt=\"x^2\"><br>總面積會是 $ \\sqrt{\\pi} $ ，所以要讓值為1的方法就是除以 $ \\sqrt{\\pi} $<br>最終會得到 $ f(x) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $<br>我們得到了常態分佈的機率密度函數，但還不能稱為“標準”常態分佈的機率密度函數<br>因為要達到“標準”的要求還需要有以下三個特性：</p>\n<ol>\n<li>期望值( $ \\mu $ )為0</li>\n<li>變異數( $ Var $ )為1</li>\n<li>標準差( $ \\sigma $ )為1</li>\n</ol>\n<p>記做 $ N(\\mu, \\sigma) $， 求 $ N(0, 1) $<br>但目前得到的機率分佈函數是 $ N(0, {1 \\over \\sqrt{2}}) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $ 這不符合標準的定義，不是我們要的</p>\n<p>我們先從wiki上看看連續型隨機變數求期望值和變異數的公式:</p>\n<p>$ E[X] = \\int xf(x)dx $<br>$ Var(x) = E[(x-\\mu)^2] $</p>\n<p>因為標準的期望值為0，則 $ \\mu = 0 $ ，帶入後得到 $ Var(x) = E[x^2] $</p>\n<p>先令$ g(x) = af(ax) $，其中a是一個大於零的常數，我們需要求出a值<br>a值需要滿足 $ \\int x^2g(x) = Var(x) $ 積分等於1<br>$ \\int x^2g(x) $ 積分後求得 $ 1 \\over {2a^2} $，因為 $ {1 \\over {2a^2}} = 1$<br>所以得到$ a = {1 \\over \\sqrt{2}} $可滿足 $ Var(x) = 1 $ 且 $ \\mu = 0 $<br>也可以求得 $ \\sigma = \\sqrt{Var(x)} = 1 $，滿足前面所提到的三個條件<br>$ N(0, 1) = {1 \\over \\sqrt{2}} f({x \\over \\sqrt{2}}) $ 帶入公式後得到 $ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $<br>這樣就符合“標準”常態機率密度函數</p>\n<p>在理解後再回頭看公式，就不覺得怪了<br>以上所做的一切努力都是為了“湊出”滿足機率定義的函數</p>\n","site":{"data":{}},"excerpt":"<p>前陣子在做SPC逆向工程…<br>為此還買了一本簡體書“程序員的數學2 概率與統計”來複習一下統計的觀念<br>皇天不負苦心人，在經過多天的努力，最終成功的產出與“SPC參考對象”相同的結果<br>為了找到正確的偏移量，在此期間不知實作了多少種不同的標準差…</p>\n<p>下一個任務是需要產生機率密度函數去看資料的離散程度…<br>至於什麼是常態分佈，可以到<a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">常態分佈wiki</a>上看，應該會比我自己說還要詳細<br>一直很好奇為什麼要定義成鐘型，看了下面的youtube影片就才了解，這是自然界的一種規律(巧合？)</p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/4HpvBZnHOVI\" frameborder=\"0\" allowfullscreen></iframe></div>\n<p>許多球從中間落下（期望值的位置），最終形成的結果接近於鐘型</p>\n<p>上面簡介完了，接著進入主題，開始剖析標準常態分佈的機率密度函數的公式<br>$ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $</p>\n<p>如果直接從wiki看完公式後，很容易實作出來，只是我更想知道公式背後的原理<br>以下是我看書和上網查完資料後，根據自己理解所歸納的結果(趁印象深刻趕快記錄下來)</p>\n<p>這時需要將公式拆成兩個部分來看<br>現在先看 $ f(x) = \\exp(-{x^2}) $ 這部分：</p>\n<p>為什麼要使用 $ -x^2 $ 呢？<br>我們知道$ x^2 $函數是開口向上的鐘型形狀，如下圖所示(以下圖片都是透過Maxima產生)：<br><img src=\"/images/st-001.png\" alt=\"x^2\"><br>但我們要的鐘型是開口向下，想要開口向下只需要乘上-1，即 $ -x^2 $<br><img src=\"/images/st-002.png\" alt=\"-x^2\"></p>\n<p>接下來看整個 $ \\exp(-{x^2}) $<br>因為經過 $ -x^2 $ 的函數所得的的值是“恆負”的(除了頂點值為0)，永遠落在第二和第三象限<br>但是當 $ -x^2 $ 當作常數為底的指數時，透過函數所得到的值是“恆正”的，就會落在第一和第四象限上<br>以下是 $ 3^{-x^2} $的函數圖形<br><img src=\"/images/st-003.png\" alt=\"x^2\"><br>其實任何常數指數為 $ -x^2 $ 都為鐘型圖形，如下圖為$ 100^{-x^2} $的函數圖形<br><img src=\"/images/st-004.png\" alt=\"x^2\"><br>","more":"</p>\n<p>雖然取任何常數都可以形成鐘型，那為什麼要取exp當作底呢？<br>主要是需要它的部分特性，主要有以下五點：</p>\n<ol>\n<li>左右對稱(以0為中心點，常數c與-c的值會得到相同值)</li>\n<li>x軸為0時(中心點)， $ f(0) $ 會取得最大值(鐘型的最高點)</li>\n<li>隨著x值逐漸遠離0時(中心點)，值會漸漸縮小，且值“不會是負的”(這點很重要，因為機率值不可為負的)</li>\n<li>當x趨近於無窮大或趨近於負無窮大時，值趨近於0</li>\n<li>比較好做積分…(連續型的機率是透過計算面積的方式去獲得區間範圍內的機率所以要做積分)</li>\n</ol>\n<p>但是只有 $ f(x) = \\exp(-{x^2}) $ 是不夠的，因為對機率來說，總體 $ P(\\Omega) = 1 $<br>所以從負無限大到無限大做積分整個 $ f(x) $的總面積必須是1<br>嘗試對 $ \\exp(-{x^2}) $從負無窮大到無窮大做積分，得到以下結果<br><img src=\"/images/st-005.png\" alt=\"x^2\"><br>總面積會是 $ \\sqrt{\\pi} $ ，所以要讓值為1的方法就是除以 $ \\sqrt{\\pi} $<br>最終會得到 $ f(x) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $<br>我們得到了常態分佈的機率密度函數，但還不能稱為“標準”常態分佈的機率密度函數<br>因為要達到“標準”的要求還需要有以下三個特性：</p>\n<ol>\n<li>期望值( $ \\mu $ )為0</li>\n<li>變異數( $ Var $ )為1</li>\n<li>標準差( $ \\sigma $ )為1</li>\n</ol>\n<p>記做 $ N(\\mu, \\sigma) $， 求 $ N(0, 1) $<br>但目前得到的機率分佈函數是 $ N(0, {1 \\over \\sqrt{2}}) = {1 \\over \\sqrt{\\pi}}\\exp(-{x^2}) $ 這不符合標準的定義，不是我們要的</p>\n<p>我們先從wiki上看看連續型隨機變數求期望值和變異數的公式:</p>\n<p>$ E[X] = \\int xf(x)dx $<br>$ Var(x) = E[(x-\\mu)^2] $</p>\n<p>因為標準的期望值為0，則 $ \\mu = 0 $ ，帶入後得到 $ Var(x) = E[x^2] $</p>\n<p>先令$ g(x) = af(ax) $，其中a是一個大於零的常數，我們需要求出a值<br>a值需要滿足 $ \\int x^2g(x) = Var(x) $ 積分等於1<br>$ \\int x^2g(x) $ 積分後求得 $ 1 \\over {2a^2} $，因為 $ {1 \\over {2a^2}} = 1$<br>所以得到$ a = {1 \\over \\sqrt{2}} $可滿足 $ Var(x) = 1 $ 且 $ \\mu = 0 $<br>也可以求得 $ \\sigma = \\sqrt{Var(x)} = 1 $，滿足前面所提到的三個條件<br>$ N(0, 1) = {1 \\over \\sqrt{2}} f({x \\over \\sqrt{2}}) $ 帶入公式後得到 $ f(x) = {1 \\over \\sqrt{2\\pi}}\\exp(-{x^2 \\over 2}) $<br>這樣就符合“標準”常態機率密度函數</p>\n<p>在理解後再回頭看公式，就不覺得怪了<br>以上所做的一切努力都是為了“湊出”滿足機率定義的函數</p>"},{"title":"比較好的nested map寫法","date":"2018-03-03T15:02:41.000Z","_content":"\n在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code\n仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group\n\n輸入資料為n*m的matrix\n```java\nString[][] dataMatrix = {{\"level 1\", \"level 2\", \"level 3\", \"data 1\"},\n                         {\"level 1\", \"level 2\", \"level 3\", \"data 2\"}};\n```\n\n但是原始的code寫的滿複雜的，為了方便說明就簡化一下，寫成程式碼 1\n\n```java 程式碼 1:\n    //Map<level 1, Map<level 2, Map<level 3, List<data>>>>\n    Map<String, Map<String, Map<String, List<String>>>> map = new HashMap<>();\n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n    \n    if(map.containsKey(level1)){\n        if(map.get(level1).containsKey(level2)){\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }else{\n            map.get(level1).put(level2, new HashMap<>());\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }\n    }else{\n        map.put(level1, new HashMap<>());\n        if(map.get(level1).containsKey(level2)){\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }else{\n            map.get(level1).put(level2, new HashMap<>());\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }\n    }\n\n    System.out.println(map.get(level1).get(level2).get(level3).get(0));\n    System.out.println(map.get(level1).get(level2).get(level3).get(1));\n```\n<!-- more -->\n\n程式碼 1 的寫法用了三層的巢狀，也包含許多重複的判斷邏輯，不但不容易閱讀，也不利於後續的維護和修改...\n看到這段程式碼時，當下真的有種想幫他重構的衝動\n但想一想此段code沒有bug，只是醜了點，若重構既花時間也沒有實質效益\n最終只在程式碼 1 的上方增加註解，寫了個比較好的作法，就是下方的程式碼 2\n\n```java 程式碼 2:\n    //Map<level 1, Map<level 2, Map<level 3, List<data>>>>\n    Map<String, Map<String, Map<String, List<String>>>> map = new HashMap<>();\n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n\n    if(!map.containsKey(level1)) {\n        map.put(level1, new HashMap<>());\n    }\n    if(!map.get(level1).containsKey(level2)) {\n        map.get(level1).put(level2, new HashMap<>());\n    }\n    if(!map.get(level1).get(level2).containsKey(level3)) {\n        map.get(level1).get(level2).put(level3, new LinkedList<>());\n    }\n\n    map.get(level1).get(level2).get(level3).add(\"data 1\");\n    map.get(level1).get(level2).get(level3).add(\"data 2\");\n    \n    System.out.println(map.get(level1).get(level2).get(level3).get(0));\n    System.out.println(map.get(level1).get(level2).get(level3).get(1));\n```\n\n程式碼 2 的寫法可以輕鬆地在執行過程中自動做初始化\n因為第7~9行就可以將level 1為null的可以性完全排除，在第7行後level 1就不可能是null\n以此類推第10行和第13行都可以自動幫level 2和level 3做初始化，所以後面只需專注於放資料即可\n不管之後增加幾層map都不需要寫成複雜的巢狀判斷式\n\n隔天想了一下，如果沒有什麼特殊需求，其實只需要將三層的key組合成一個唯一的字串即可...\n就如同下方的程式碼 3\n\n```java 程式碼 3:\n    //Map<level 1 + level 2 + level 3, List<data>>\n    Map<String, List<String>> map = new HashMap<>();\n    \n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n    \n    String combinKey = level1 + level2 + level3;\n    \n    if(!map.put(combinKey)) {\n        map,put(combinKey, new LinkedList<>());\n    }\n\n    map.get(combinKey).add(\"data 1\");\n    map.get(combinKey).add(\"data 2\");\n    \n    System.out.println(map.get(combinKey).get(0));\n    System.out.println(map.get(combinKey).get(1));\n```\n\n\n若是能夠使用 java 8 的 stream 的話就更簡單了，如同下方的程式碼 4\n\n```java 程式碼 4:\nMap<String, List<String>> map = Arrays.stream(dataMatrix).collect(\n                Collectors.toMap(\n                    kv -> kv[0] + kv[1] + kv[2],\n                    kv -> Lists.newArrayList(kv[3]),\n                    (newVal, oldVal) -> {\n                        newVal.addAll(oldVal);\n                        return newVal;\n                    }\n                )\n            );\n```\n\n結論： \n我一直認為寫出簡潔易讀且好維護的程式碼是身為一個軟體開發者該有的素養\n不是只求程式會跑就好，這樣只會累積一些不必要的技術債...\n所以我覺得每個開發者，都應該買本“clean code 無瑕的程式碼 + 番外篇”來讀一讀\n時時提醒自己不要埋地雷給別人踩，顯現自己的專業\n\n此時想起我放在辦公室的clean code一書被同事們借來借去，現在也不知道流浪到哪位同事的辦公桌上...\n","source":"_posts/比較好的nested-map寫法.md","raw":"---\ntitle: 比較好的nested map寫法\ndate: 2018-03-03 23:02:41\ntags:\n- java\n- clean code\n---\n\n在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code\n仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group\n\n輸入資料為n*m的matrix\n```java\nString[][] dataMatrix = {{\"level 1\", \"level 2\", \"level 3\", \"data 1\"},\n                         {\"level 1\", \"level 2\", \"level 3\", \"data 2\"}};\n```\n\n但是原始的code寫的滿複雜的，為了方便說明就簡化一下，寫成程式碼 1\n\n```java 程式碼 1:\n    //Map<level 1, Map<level 2, Map<level 3, List<data>>>>\n    Map<String, Map<String, Map<String, List<String>>>> map = new HashMap<>();\n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n    \n    if(map.containsKey(level1)){\n        if(map.get(level1).containsKey(level2)){\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }else{\n            map.get(level1).put(level2, new HashMap<>());\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }\n    }else{\n        map.put(level1, new HashMap<>());\n        if(map.get(level1).containsKey(level2)){\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }else{\n            map.get(level1).put(level2, new HashMap<>());\n            if(map.get(level1).get(level2).containsKey(level3)){\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }else{\n                map.get(level1).get(level2).put(level3, new LinkedList<>());\n                map.get(level1).get(level2).get(level3).add(\"data 1\");\n                map.get(level1).get(level2).get(level3).add(\"data 2\");\n            }\n        }\n    }\n\n    System.out.println(map.get(level1).get(level2).get(level3).get(0));\n    System.out.println(map.get(level1).get(level2).get(level3).get(1));\n```\n<!-- more -->\n\n程式碼 1 的寫法用了三層的巢狀，也包含許多重複的判斷邏輯，不但不容易閱讀，也不利於後續的維護和修改...\n看到這段程式碼時，當下真的有種想幫他重構的衝動\n但想一想此段code沒有bug，只是醜了點，若重構既花時間也沒有實質效益\n最終只在程式碼 1 的上方增加註解，寫了個比較好的作法，就是下方的程式碼 2\n\n```java 程式碼 2:\n    //Map<level 1, Map<level 2, Map<level 3, List<data>>>>\n    Map<String, Map<String, Map<String, List<String>>>> map = new HashMap<>();\n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n\n    if(!map.containsKey(level1)) {\n        map.put(level1, new HashMap<>());\n    }\n    if(!map.get(level1).containsKey(level2)) {\n        map.get(level1).put(level2, new HashMap<>());\n    }\n    if(!map.get(level1).get(level2).containsKey(level3)) {\n        map.get(level1).get(level2).put(level3, new LinkedList<>());\n    }\n\n    map.get(level1).get(level2).get(level3).add(\"data 1\");\n    map.get(level1).get(level2).get(level3).add(\"data 2\");\n    \n    System.out.println(map.get(level1).get(level2).get(level3).get(0));\n    System.out.println(map.get(level1).get(level2).get(level3).get(1));\n```\n\n程式碼 2 的寫法可以輕鬆地在執行過程中自動做初始化\n因為第7~9行就可以將level 1為null的可以性完全排除，在第7行後level 1就不可能是null\n以此類推第10行和第13行都可以自動幫level 2和level 3做初始化，所以後面只需專注於放資料即可\n不管之後增加幾層map都不需要寫成複雜的巢狀判斷式\n\n隔天想了一下，如果沒有什麼特殊需求，其實只需要將三層的key組合成一個唯一的字串即可...\n就如同下方的程式碼 3\n\n```java 程式碼 3:\n    //Map<level 1 + level 2 + level 3, List<data>>\n    Map<String, List<String>> map = new HashMap<>();\n    \n    String level1 = \"level 1\";\n    String level2 = \"level 2\";\n    String level3 = \"level 3\";\n    \n    String combinKey = level1 + level2 + level3;\n    \n    if(!map.put(combinKey)) {\n        map,put(combinKey, new LinkedList<>());\n    }\n\n    map.get(combinKey).add(\"data 1\");\n    map.get(combinKey).add(\"data 2\");\n    \n    System.out.println(map.get(combinKey).get(0));\n    System.out.println(map.get(combinKey).get(1));\n```\n\n\n若是能夠使用 java 8 的 stream 的話就更簡單了，如同下方的程式碼 4\n\n```java 程式碼 4:\nMap<String, List<String>> map = Arrays.stream(dataMatrix).collect(\n                Collectors.toMap(\n                    kv -> kv[0] + kv[1] + kv[2],\n                    kv -> Lists.newArrayList(kv[3]),\n                    (newVal, oldVal) -> {\n                        newVal.addAll(oldVal);\n                        return newVal;\n                    }\n                )\n            );\n```\n\n結論： \n我一直認為寫出簡潔易讀且好維護的程式碼是身為一個軟體開發者該有的素養\n不是只求程式會跑就好，這樣只會累積一些不必要的技術債...\n所以我覺得每個開發者，都應該買本“clean code 無瑕的程式碼 + 番外篇”來讀一讀\n時時提醒自己不要埋地雷給別人踩，顯現自己的專業\n\n此時想起我放在辦公室的clean code一書被同事們借來借去，現在也不知道流浪到哪位同事的辦公桌上...\n","slug":"比較好的nested-map寫法","published":1,"updated":"2018-03-25T16:09:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5box000k2bpjrt8u0qdf","content":"<p>在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code<br>仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group</p>\n<p>輸入資料為n*m的matrix<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] dataMatrix = &#123;&#123;<span class=\"string\">\"level 1\"</span>, <span class=\"string\">\"level 2\"</span>, <span class=\"string\">\"level 3\"</span>, <span class=\"string\">\"data 1\"</span>&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"level 1\"</span>, <span class=\"string\">\"level 2\"</span>, <span class=\"string\">\"level 3\"</span>, <span class=\"string\">\"data 2\"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是原始的code寫的滿複雜的，為了方便說明就簡化一下，寫成程式碼 1</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 1:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(level1))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    map.put(level1, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>程式碼 1 的寫法用了三層的巢狀，也包含許多重複的判斷邏輯，不但不容易閱讀，也不利於後續的維護和修改…<br>看到這段程式碼時，當下真的有種想幫他重構的衝動<br>但想一想此段code沒有bug，只是醜了點，若重構既花時間也沒有實質效益<br>最終只在程式碼 1 的上方增加註解，寫了個比較好的作法，就是下方的程式碼 2</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 2:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.containsKey(level1)) &#123;</span><br><span class=\"line\">    map.put(level1, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.get(level1).containsKey(level2)) &#123;</span><br><span class=\"line\">    map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.get(level1).get(level2).containsKey(level3)) &#123;</span><br><span class=\"line\">    map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<p>程式碼 2 的寫法可以輕鬆地在執行過程中自動做初始化<br>因為第7~9行就可以將level 1為null的可以性完全排除，在第7行後level 1就不可能是null<br>以此類推第10行和第13行都可以自動幫level 2和level 3做初始化，所以後面只需專注於放資料即可<br>不管之後增加幾層map都不需要寫成複雜的巢狀判斷式</p>\n<p>隔天想了一下，如果沒有什麼特殊需求，其實只需要將三層的key組合成一個唯一的字串即可…<br>就如同下方的程式碼 3</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 3:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1 + level 2 + level 3, List&lt;data&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">String combinKey = level1 + level2 + level3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.put(combinKey)) &#123;</span><br><span class=\"line\">    map,put(combinKey, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(combinKey).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">map.get(combinKey).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(combinKey).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(combinKey).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<p>若是能夠使用 java 8 的 stream 的話就更簡單了，如同下方的程式碼 4</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 4:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(dataMatrix).collect(</span><br><span class=\"line\">                Collectors.toMap(</span><br><span class=\"line\">                    kv -&gt; kv[<span class=\"number\">0</span>] + kv[<span class=\"number\">1</span>] + kv[<span class=\"number\">2</span>],</span><br><span class=\"line\">                    kv -&gt; Lists.newArrayList(kv[<span class=\"number\">3</span>]),</span><br><span class=\"line\">                    (newVal, oldVal) -&gt; &#123;</span><br><span class=\"line\">                        newVal.addAll(oldVal);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> newVal;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            );</span><br></pre></td></tr></table></figure>\n<p>結論：<br>我一直認為寫出簡潔易讀且好維護的程式碼是身為一個軟體開發者該有的素養<br>不是只求程式會跑就好，這樣只會累積一些不必要的技術債…<br>所以我覺得每個開發者，都應該買本“clean code 無瑕的程式碼 + 番外篇”來讀一讀<br>時時提醒自己不要埋地雷給別人踩，顯現自己的專業</p>\n<p>此時想起我放在辦公室的clean code一書被同事們借來借去，現在也不知道流浪到哪位同事的辦公桌上…</p>\n","site":{"data":{}},"excerpt":"<p>在幫離職同事修正Android的bug時，看到了一段令人匪夷所思的code<br>仔細的看了一下，才知道是使用一個三層的nested map結構來幫資料做group</p>\n<p>輸入資料為n*m的matrix<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] dataMatrix = &#123;&#123;<span class=\"string\">\"level 1\"</span>, <span class=\"string\">\"level 2\"</span>, <span class=\"string\">\"level 3\"</span>, <span class=\"string\">\"data 1\"</span>&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"level 1\"</span>, <span class=\"string\">\"level 2\"</span>, <span class=\"string\">\"level 3\"</span>, <span class=\"string\">\"data 2\"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是原始的code寫的滿複雜的，為了方便說明就簡化一下，寫成程式碼 1</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 1:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(level1))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    map.put(level1, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(map.get(level1).containsKey(level2))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.get(level1).get(level2).containsKey(level3))&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">            map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>","more":"<p>程式碼 1 的寫法用了三層的巢狀，也包含許多重複的判斷邏輯，不但不容易閱讀，也不利於後續的維護和修改…<br>看到這段程式碼時，當下真的有種想幫他重構的衝動<br>但想一想此段code沒有bug，只是醜了點，若重構既花時間也沒有實質效益<br>最終只在程式碼 1 的上方增加註解，寫了個比較好的作法，就是下方的程式碼 2</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 2:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1, Map&lt;level 2, Map&lt;level 3, List&lt;data&gt;&gt;&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.containsKey(level1)) &#123;</span><br><span class=\"line\">    map.put(level1, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.get(level1).containsKey(level2)) &#123;</span><br><span class=\"line\">    map.get(level1).put(level2, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.get(level1).get(level2).containsKey(level3)) &#123;</span><br><span class=\"line\">    map.get(level1).get(level2).put(level3, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">map.get(level1).get(level2).get(level3).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(level1).get(level2).get(level3).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<p>程式碼 2 的寫法可以輕鬆地在執行過程中自動做初始化<br>因為第7~9行就可以將level 1為null的可以性完全排除，在第7行後level 1就不可能是null<br>以此類推第10行和第13行都可以自動幫level 2和level 3做初始化，所以後面只需專注於放資料即可<br>不管之後增加幾層map都不需要寫成複雜的巢狀判斷式</p>\n<p>隔天想了一下，如果沒有什麼特殊需求，其實只需要將三層的key組合成一個唯一的字串即可…<br>就如同下方的程式碼 3</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 3:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map&lt;level 1 + level 2 + level 3, List&lt;data&gt;&gt;</span></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">String level1 = <span class=\"string\">\"level 1\"</span>;</span><br><span class=\"line\">String level2 = <span class=\"string\">\"level 2\"</span>;</span><br><span class=\"line\">String level3 = <span class=\"string\">\"level 3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">String combinKey = level1 + level2 + level3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!map.put(combinKey)) &#123;</span><br><span class=\"line\">    map,put(combinKey, <span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(combinKey).add(<span class=\"string\">\"data 1\"</span>);</span><br><span class=\"line\">map.get(combinKey).add(<span class=\"string\">\"data 2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(map.get(combinKey).get(<span class=\"number\">0</span>));</span><br><span class=\"line\">System.out.println(map.get(combinKey).get(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<p>若是能夠使用 java 8 的 stream 的話就更簡單了，如同下方的程式碼 4</p>\n<figure class=\"highlight java\"><figcaption><span>程式碼 4:</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(dataMatrix).collect(</span><br><span class=\"line\">                Collectors.toMap(</span><br><span class=\"line\">                    kv -&gt; kv[<span class=\"number\">0</span>] + kv[<span class=\"number\">1</span>] + kv[<span class=\"number\">2</span>],</span><br><span class=\"line\">                    kv -&gt; Lists.newArrayList(kv[<span class=\"number\">3</span>]),</span><br><span class=\"line\">                    (newVal, oldVal) -&gt; &#123;</span><br><span class=\"line\">                        newVal.addAll(oldVal);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> newVal;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            );</span><br></pre></td></tr></table></figure>\n<p>結論：<br>我一直認為寫出簡潔易讀且好維護的程式碼是身為一個軟體開發者該有的素養<br>不是只求程式會跑就好，這樣只會累積一些不必要的技術債…<br>所以我覺得每個開發者，都應該買本“clean code 無瑕的程式碼 + 番外篇”來讀一讀<br>時時提醒自己不要埋地雷給別人踩，顯現自己的專業</p>\n<p>此時想起我放在辦公室的clean code一書被同事們借來借去，現在也不知道流浪到哪位同事的辦公桌上…</p>"},{"title":"用illustrator幫自己畫一個新頭像","date":"2018-07-15T15:33:59.000Z","_content":"\n今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像\n\n決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式\n所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用\n但看起來好像少了些什麼...\n\n<img src=\"/images/heng-001.png\" width=\"50%\" height=\"50%\" alt=\"head img 1\"/>\n\n<br/><br/>\n現在增加coding字型的底座，看起來就像火炬，滿符合我設定的主題\n\n<img src=\"/images/heng-002.png\" width=\"50%\" height=\"50%\" alt=\"head img 2\"/>\n\n替換成功囉!\n","source":"_posts/用illustrator幫自己畫一個新頭像.md","raw":"---\ntitle: 用illustrator幫自己畫一個新頭像\ndate: 2018-07-15 23:33:59\ntags:\n- illustrator\n---\n\n今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像\n\n決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式\n所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用\n但看起來好像少了些什麼...\n\n<img src=\"/images/heng-001.png\" width=\"50%\" height=\"50%\" alt=\"head img 1\"/>\n\n<br/><br/>\n現在增加coding字型的底座，看起來就像火炬，滿符合我設定的主題\n\n<img src=\"/images/heng-002.png\" width=\"50%\" height=\"50%\" alt=\"head img 2\"/>\n\n替換成功囉!\n","slug":"用illustrator幫自己畫一個新頭像","published":1,"updated":"2019-10-10T15:42:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5boy000l2bpj0l19m7tq","content":"<p>今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像</p>\n<p>決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式<br>所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用<br>但看起來好像少了些什麼…</p>\n<p><img src=\"/images/heng-001.png\" width=\"50%\" height=\"50%\" alt=\"head img 1\"></p>\n<p><br><br><br>現在增加coding字型的底座，看起來就像火炬，滿符合我設定的主題</p>\n<p><img src=\"/images/heng-002.png\" width=\"50%\" height=\"50%\" alt=\"head img 2\"></p>\n<p>替換成功囉!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天晚上沒事，心血來潮用illustrator幫自己畫個Github的頭像</p>\n<p>決定用我的名字Heng來創作，主題就用燃燒自己的生命來寫程式<br>所以Heng就畫成熊熊燃燒的樣子，畫成圓形方便在某些頭像濾鏡為圓形可直接套用<br>但看起來好像少了些什麼…</p>\n<p><img src=\"/images/heng-001.png\" width=\"50%\" height=\"50%\" alt=\"head img 1\"></p>\n<p><br><br><br>現在增加coding字型的底座，看起來就像火炬，滿符合我設定的主題</p>\n<p><img src=\"/images/heng-002.png\" width=\"50%\" height=\"50%\" alt=\"head img 2\"></p>\n<p>替換成功囉!</p>\n"},{"title":"第一篇Blog，從SVN到Git","date":"2018-02-16T09:28:42.000Z","_content":"\n今天是大年初一\n趁春節的這段時間，來讀之前買的 O'Reilly “版本控制使用Git”\n\n在這之前都是使用SVN來管理自己的source code\n直到去年我的MacBook Pro的SSD硬碟無預期掛掉...\n近五年的code就跟著一起消失了...\n\n所以今年改使用Git管理，因為可以免費將code上傳到github上儲存\n至少下次硬碟壞掉時，code不會跟著蒸發\n","source":"_posts/第一篇Blog，從SVN到Git.md","raw":"---\ntitle: 第一篇Blog，從SVN到Git\ndate: 2018-02-16 17:28:42\ntags:\n- Blog\n---\n\n今天是大年初一\n趁春節的這段時間，來讀之前買的 O'Reilly “版本控制使用Git”\n\n在這之前都是使用SVN來管理自己的source code\n直到去年我的MacBook Pro的SSD硬碟無預期掛掉...\n近五年的code就跟著一起消失了...\n\n所以今年改使用Git管理，因為可以免費將code上傳到github上儲存\n至少下次硬碟壞掉時，code不會跟著蒸發\n","slug":"第一篇Blog，從SVN到Git","published":1,"updated":"2018-02-18T08:11:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5boz000n2bpjueu9fmb9","content":"<p>今天是大年初一<br>趁春節的這段時間，來讀之前買的 O’Reilly “版本控制使用Git”</p>\n<p>在這之前都是使用SVN來管理自己的source code<br>直到去年我的MacBook Pro的SSD硬碟無預期掛掉…<br>近五年的code就跟著一起消失了…</p>\n<p>所以今年改使用Git管理，因為可以免費將code上傳到github上儲存<br>至少下次硬碟壞掉時，code不會跟著蒸發</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天是大年初一<br>趁春節的這段時間，來讀之前買的 O’Reilly “版本控制使用Git”</p>\n<p>在這之前都是使用SVN來管理自己的source code<br>直到去年我的MacBook Pro的SSD硬碟無預期掛掉…<br>近五年的code就跟著一起消失了…</p>\n<p>所以今年改使用Git管理，因為可以免費將code上傳到github上儲存<br>至少下次硬碟壞掉時，code不會跟著蒸發</p>\n"},{"title":"從無到有DIY chart (二)","date":"2018-04-14T14:17:36.000Z","_content":"\n增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下\n{% raw %}\n<html>\n    <head>\n    \n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\nclass Chart{\n    constructor(params){\n    this._LINE_TENSION = 0.2\n    this._LINE_WIDTH_ORI = 2;\n    this._LINE_WIDTH_FOCUS = 5;\n    this._COLOR_GRAY = 'gray';\n    this._COLOR_WHITE = 'white';\n    \n    this._id = params.id;\n    this._matrix = params.matrix;\n    this._radius = params.radius;\n    this._dataSet = [];\n    this._curveDataSet = [];\n    \n    this._canvas;\n    this._canvasWidth;\n    this._canvasHeight;\n    this._ctx;\n    this._preFocusPoint;\n    \n    this._Coordinate;\n    \n    this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    \n        this._initCoordinate();\n        this._initDataSet();\n        this._initCurveLines();\n        this._bindMouseEvent();\n        this.draw();\n    }\n    \n    _initCoordinate(){\n        this._Coordinate = new Coordinate({\n            canvas: this._canvas,\n            matrix: this._matrix\n        });\n    }\n\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n    \n    _initFrame(){\n        const rect = this._Coordinate.getChartBoundingRect();\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n        \n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n    \n    _initLines(){\n        this._ctx.beginPath();\n        const dataLength = this._dataSet.length;\n        if(dataLength < 2) return;\n        if(dataLength == 2){\n            const firstPoint = this._dataSet[0];\n            const secondPoint = this._dataSet[1];\n            this._ctx.moveTo(firstPoint.x, firstPoint.y);\n            this._ctx.lineTo(secondPoint.x, secondPoint.y);\n            this._ctx.stroke();\n            return;\n        }\n        \n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                this._ctx.moveTo(point.x, point.y);\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            this._ctx.bezierCurveTo(\n                preControlPoint.next.x, preControlPoint.next.y, \n                controlPoint.pre.x, controlPoint.pre.y, \n                point.x, point.y\n            );            \n        }\n        this._ctx.stroke();\n    }\n    \n    _showControlPoint(){\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            \n            this._drawCircle({x: preControlPoint.next.x, y: preControlPoint.next.y, radius: 2, lineWidth: 1, color: preControlPoint.oriPoint.color});\n            this._drawCircle({x: controlPoint.pre.x,     y: controlPoint.pre.y,     radius: 2, lineWidth: 1, color: controlPoint.oriPoint.color});\n            \n            this._ctx.stroke();\n        }\n    }\n    \n    _initCircles(){\n        const _self = this;\n        this._dataSet.forEach((point) => {\n            _self._drawCircle({\n                x: point.x, \n                y: point.y, \n                radius: _self._radius, \n                lineWidth: _self._LINE_WIDTH_ORI,\n                color: point.color\n            });\n        });\n    }\n    \n    _initCurveLines(){\n        const dataLength = this._dataSet.length;\n        /*\n            less than three points don't need to use curve\n        */\n        if(dataLength <= 2) return;\n        for(let index=1; index<(dataLength-1); index++){\n            const prePoint = this._dataSet[index - 1];\n            const currentPoint = this._dataSet[index];\n            const nextPoint = this._dataSet[index + 1];\n            /*\n                use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n            */\n            const deltaX = nextPoint.x - prePoint.x;\n            const deltaY = nextPoint.y - prePoint.y;\n            const distance = this._distance(prePoint, nextPoint);\n            const cos = deltaX / distance;\n            const sin = deltaY / distance;\n            /*\n                calc current point distance between two points pre and next\n            */\n            const preRelativeDistance = this._distance(prePoint, currentPoint);\n            const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n            /*\n                calc actual offset by current point and pre point\n                ps: actual offset = current point - (scale * two point distance * tension)\n            */\n            const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);\n            const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n            /*\n                calc actual offset by current point and next point\n            */\n            const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n            const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n            /*\n                \n            */\n            this._curveDataSet.push({\n                oriPoint: currentPoint,\n                pre: {x: preControlPointX, y: preControlPointY}, \n                next: {x: nextControlPointX, y: nextControlPointY},\n            });\n            \n        }\n    \n        const firstPoint = this._dataSet[0];\n        const secondCurvePoint = this._curveDataSet[1];\n        this._curveDataSet.unshift({\n            oriPoint: firstPoint,\n            next: {\n                x: (firstPoint.x + secondCurvePoint.pre.x) / 2,\n                y: (firstPoint.y + secondCurvePoint.pre.y) / 2\n            }\n        });\n        \n        const lastPoint = this._dataSet[dataLength - 1];\n        const secondLastCurvePoint = this._curveDataSet[dataLength - 2];\n        this._curveDataSet.push({\n            oriPoint: lastPoint,\n            pre: {\n                x: (lastPoint.x + secondLastCurvePoint.next.x) / 2, \n                y: (lastPoint.y + secondLastCurvePoint.next.y) / 2\n            }\n        });\n    }\n    \n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n    \n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n    \n    _drawRect(params){\n        this._ctx.lineWidth = params.lineWidth;\n        this._ctx.strokeStyle = params.color;\n        this._ctx.beginPath();\n        this._ctx.rect(params.x, params.y, params.width, params.height);\n        this._ctx.stroke();\n    }\n    \n    _drawLine(point1, point2){\n        this._ctx.lineWidth = point2.lineWidth;\n        this._ctx.strokeStyle = point2.color;\n        this._ctx.beginPath();\n        this._ctx.moveTo(point1.x, point1.y);\n        this._ctx.lineTo(point2.x, point2.y);\n        this._ctx.stroke();\n    }\n\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n    \n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n            if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n    \n    _clear(){\n        this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n    }\n    \n    /* public */\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n    \n    render(){\n        this._clear();\n        this.draw();\n        console.log('render');\n    }\n\n    printDataSet(){\n        console.log('dataSet', this._dataSet);\n    }\n}\n\nclass Coordinate{\n    constructor(params){\n        this._LEFT_OFFSET = 20;\n        this._BOTTOM_OFFSET = 20;\n        this._TOP_OFFSET = 10;\n        this._RIGHT_OFFSET = 10;\n        \n        this._canvas = params.canvas;\n        this._oriMatrix = params.matrix;\n        \n        this._chartBoundingRect;\n        this._xAxis;\n        this._yAxis;\n        \n        this._init();\n    }\n    \n    _init(){\n        this._initChartBoundingRect();\n        this._initXAxisAndYAxis();\n    }\n    \n    _initChartBoundingRect(){\n        const oriCanvasRect = this._canvas.getBoundingClientRect();\n        //console.log(oriCanvasRect);\n        this._chartBoundingRect = {\n            left: 0 + this._LEFT_OFFSET,\n            top: 0 + this._TOP_OFFSET,\n            bottom: oriCanvasRect.height - this._BOTTOM_OFFSET,\n            right: oriCanvasRect.width - this._RIGHT_OFFSET,\n            \n            width: oriCanvasRect.width - this._LEFT_OFFSET - this._RIGHT_OFFSET,\n            height: oriCanvasRect.height - this._BOTTOM_OFFSET - this._TOP_OFFSET,\n        }\n        console.log(this._chartBoundingRect);\n    }\n\n    _initXAxisAndYAxis(){\n        let xMax = Number.MIN_VALUE;\n        let xMin = Number.MAX_VALUE;\n        \n        let yMax = Number.MIN_VALUE;\n        let yMin = Number.MAX_VALUE;\n        \n        this._oriMatrix.forEach((point) => {\n            const x = point[0];\n            const y = point[1];\n            \n            xMax = Math.max(xMax, x);\n            xMin = Math.min(xMin, x);\n            \n            yMax = Math.max(yMax, y);\n            yMin = Math.min(yMin, y);\n        });\n        \n        const xNormal = (xMax - xMin);\n        const yNormal = (yMax - yMin);\n    }\n    \n    getChartBoundingRect(){\n        return this._chartBoundingRect;\n    }\n}\n\n(function(global){\n    const canvasId = 'chart';\n    const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n    const radius = 4;\n    const chart = new Chart({\n        id: canvasId, \n        matrix: matrix,\n        radius: radius\n    });\n    chart.draw();\n    chart.printDataSet();\n    console.log('chart', chart);\n    console.log(chart._id);\n})(this);\n</script>\n{% endraw %}\n\n主要增加的程式碼如下，參考chart.js繪製曲線的方式，自己試做看看，主要是針對點與點之間距離的計算出偏移強度\n```js\n    for(let index=1; index<(dataLength-1); index++){\n        const prePoint = this._dataSet[index - 1];\n        const currentPoint = this._dataSet[index];\n        const nextPoint = this._dataSet[index + 1];\n        /*\n            use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n        */\n        const deltaX = nextPoint.x - prePoint.x;\n        const deltaY = nextPoint.y - prePoint.y;\n        const distance = this._distance(prePoint, nextPoint);\n        const cos = deltaX / distance;\n        const sin = deltaY / distance;\n        /*\n            calc current point distance between two points pre and next\n        */\n        const preRelativeDistance = this._distance(prePoint, currentPoint);\n        const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n        /*\n            calc actual offset by current point and pre point\n            ps: actual offset = current point - (scale * two point distance * tension)\n        */\n        const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);// _LINE_TENSION = 0.2\n        const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n        /*\n            calc actual offset by current point and next point\n        */\n        const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n        const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n        \n        this._curveDataSet.push({\n            oriPoint: currentPoint,\n            pre: {x: preControlPointX, y: preControlPointY}, \n            next: {x: nextControlPointX, y: nextControlPointY},\n        });\n    }\n```\n","source":"_posts/從無到有DIY-chart-二.md","raw":"---\ntitle: 從無到有DIY chart (二)\ndate: 2018-04-14 22:17:36\ntags:\n- js\n---\n\n增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下\n{% raw %}\n<html>\n    <head>\n    \n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\nclass Chart{\n    constructor(params){\n    this._LINE_TENSION = 0.2\n    this._LINE_WIDTH_ORI = 2;\n    this._LINE_WIDTH_FOCUS = 5;\n    this._COLOR_GRAY = 'gray';\n    this._COLOR_WHITE = 'white';\n    \n    this._id = params.id;\n    this._matrix = params.matrix;\n    this._radius = params.radius;\n    this._dataSet = [];\n    this._curveDataSet = [];\n    \n    this._canvas;\n    this._canvasWidth;\n    this._canvasHeight;\n    this._ctx;\n    this._preFocusPoint;\n    \n    this._Coordinate;\n    \n    this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    \n        this._initCoordinate();\n        this._initDataSet();\n        this._initCurveLines();\n        this._bindMouseEvent();\n        this.draw();\n    }\n    \n    _initCoordinate(){\n        this._Coordinate = new Coordinate({\n            canvas: this._canvas,\n            matrix: this._matrix\n        });\n    }\n\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n    \n    _initFrame(){\n        const rect = this._Coordinate.getChartBoundingRect();\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n        \n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n    \n    _initLines(){\n        this._ctx.beginPath();\n        const dataLength = this._dataSet.length;\n        if(dataLength < 2) return;\n        if(dataLength == 2){\n            const firstPoint = this._dataSet[0];\n            const secondPoint = this._dataSet[1];\n            this._ctx.moveTo(firstPoint.x, firstPoint.y);\n            this._ctx.lineTo(secondPoint.x, secondPoint.y);\n            this._ctx.stroke();\n            return;\n        }\n        \n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                this._ctx.moveTo(point.x, point.y);\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            this._ctx.bezierCurveTo(\n                preControlPoint.next.x, preControlPoint.next.y, \n                controlPoint.pre.x, controlPoint.pre.y, \n                point.x, point.y\n            );            \n        }\n        this._ctx.stroke();\n    }\n    \n    _showControlPoint(){\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            \n            this._drawCircle({x: preControlPoint.next.x, y: preControlPoint.next.y, radius: 2, lineWidth: 1, color: preControlPoint.oriPoint.color});\n            this._drawCircle({x: controlPoint.pre.x,     y: controlPoint.pre.y,     radius: 2, lineWidth: 1, color: controlPoint.oriPoint.color});\n            \n            this._ctx.stroke();\n        }\n    }\n    \n    _initCircles(){\n        const _self = this;\n        this._dataSet.forEach((point) => {\n            _self._drawCircle({\n                x: point.x, \n                y: point.y, \n                radius: _self._radius, \n                lineWidth: _self._LINE_WIDTH_ORI,\n                color: point.color\n            });\n        });\n    }\n    \n    _initCurveLines(){\n        const dataLength = this._dataSet.length;\n        /*\n            less than three points don't need to use curve\n        */\n        if(dataLength <= 2) return;\n        for(let index=1; index<(dataLength-1); index++){\n            const prePoint = this._dataSet[index - 1];\n            const currentPoint = this._dataSet[index];\n            const nextPoint = this._dataSet[index + 1];\n            /*\n                use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n            */\n            const deltaX = nextPoint.x - prePoint.x;\n            const deltaY = nextPoint.y - prePoint.y;\n            const distance = this._distance(prePoint, nextPoint);\n            const cos = deltaX / distance;\n            const sin = deltaY / distance;\n            /*\n                calc current point distance between two points pre and next\n            */\n            const preRelativeDistance = this._distance(prePoint, currentPoint);\n            const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n            /*\n                calc actual offset by current point and pre point\n                ps: actual offset = current point - (scale * two point distance * tension)\n            */\n            const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);\n            const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n            /*\n                calc actual offset by current point and next point\n            */\n            const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n            const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n            /*\n                \n            */\n            this._curveDataSet.push({\n                oriPoint: currentPoint,\n                pre: {x: preControlPointX, y: preControlPointY}, \n                next: {x: nextControlPointX, y: nextControlPointY},\n            });\n            \n        }\n    \n        const firstPoint = this._dataSet[0];\n        const secondCurvePoint = this._curveDataSet[1];\n        this._curveDataSet.unshift({\n            oriPoint: firstPoint,\n            next: {\n                x: (firstPoint.x + secondCurvePoint.pre.x) / 2,\n                y: (firstPoint.y + secondCurvePoint.pre.y) / 2\n            }\n        });\n        \n        const lastPoint = this._dataSet[dataLength - 1];\n        const secondLastCurvePoint = this._curveDataSet[dataLength - 2];\n        this._curveDataSet.push({\n            oriPoint: lastPoint,\n            pre: {\n                x: (lastPoint.x + secondLastCurvePoint.next.x) / 2, \n                y: (lastPoint.y + secondLastCurvePoint.next.y) / 2\n            }\n        });\n    }\n    \n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n    \n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n    \n    _drawRect(params){\n        this._ctx.lineWidth = params.lineWidth;\n        this._ctx.strokeStyle = params.color;\n        this._ctx.beginPath();\n        this._ctx.rect(params.x, params.y, params.width, params.height);\n        this._ctx.stroke();\n    }\n    \n    _drawLine(point1, point2){\n        this._ctx.lineWidth = point2.lineWidth;\n        this._ctx.strokeStyle = point2.color;\n        this._ctx.beginPath();\n        this._ctx.moveTo(point1.x, point1.y);\n        this._ctx.lineTo(point2.x, point2.y);\n        this._ctx.stroke();\n    }\n\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n    \n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n            if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n    \n    _clear(){\n        this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n    }\n    \n    /* public */\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n    \n    render(){\n        this._clear();\n        this.draw();\n        console.log('render');\n    }\n\n    printDataSet(){\n        console.log('dataSet', this._dataSet);\n    }\n}\n\nclass Coordinate{\n    constructor(params){\n        this._LEFT_OFFSET = 20;\n        this._BOTTOM_OFFSET = 20;\n        this._TOP_OFFSET = 10;\n        this._RIGHT_OFFSET = 10;\n        \n        this._canvas = params.canvas;\n        this._oriMatrix = params.matrix;\n        \n        this._chartBoundingRect;\n        this._xAxis;\n        this._yAxis;\n        \n        this._init();\n    }\n    \n    _init(){\n        this._initChartBoundingRect();\n        this._initXAxisAndYAxis();\n    }\n    \n    _initChartBoundingRect(){\n        const oriCanvasRect = this._canvas.getBoundingClientRect();\n        //console.log(oriCanvasRect);\n        this._chartBoundingRect = {\n            left: 0 + this._LEFT_OFFSET,\n            top: 0 + this._TOP_OFFSET,\n            bottom: oriCanvasRect.height - this._BOTTOM_OFFSET,\n            right: oriCanvasRect.width - this._RIGHT_OFFSET,\n            \n            width: oriCanvasRect.width - this._LEFT_OFFSET - this._RIGHT_OFFSET,\n            height: oriCanvasRect.height - this._BOTTOM_OFFSET - this._TOP_OFFSET,\n        }\n        console.log(this._chartBoundingRect);\n    }\n\n    _initXAxisAndYAxis(){\n        let xMax = Number.MIN_VALUE;\n        let xMin = Number.MAX_VALUE;\n        \n        let yMax = Number.MIN_VALUE;\n        let yMin = Number.MAX_VALUE;\n        \n        this._oriMatrix.forEach((point) => {\n            const x = point[0];\n            const y = point[1];\n            \n            xMax = Math.max(xMax, x);\n            xMin = Math.min(xMin, x);\n            \n            yMax = Math.max(yMax, y);\n            yMin = Math.min(yMin, y);\n        });\n        \n        const xNormal = (xMax - xMin);\n        const yNormal = (yMax - yMin);\n    }\n    \n    getChartBoundingRect(){\n        return this._chartBoundingRect;\n    }\n}\n\n(function(global){\n    const canvasId = 'chart';\n    const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n    const radius = 4;\n    const chart = new Chart({\n        id: canvasId, \n        matrix: matrix,\n        radius: radius\n    });\n    chart.draw();\n    chart.printDataSet();\n    console.log('chart', chart);\n    console.log(chart._id);\n})(this);\n</script>\n{% endraw %}\n\n主要增加的程式碼如下，參考chart.js繪製曲線的方式，自己試做看看，主要是針對點與點之間距離的計算出偏移強度\n```js\n    for(let index=1; index<(dataLength-1); index++){\n        const prePoint = this._dataSet[index - 1];\n        const currentPoint = this._dataSet[index];\n        const nextPoint = this._dataSet[index + 1];\n        /*\n            use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n        */\n        const deltaX = nextPoint.x - prePoint.x;\n        const deltaY = nextPoint.y - prePoint.y;\n        const distance = this._distance(prePoint, nextPoint);\n        const cos = deltaX / distance;\n        const sin = deltaY / distance;\n        /*\n            calc current point distance between two points pre and next\n        */\n        const preRelativeDistance = this._distance(prePoint, currentPoint);\n        const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n        /*\n            calc actual offset by current point and pre point\n            ps: actual offset = current point - (scale * two point distance * tension)\n        */\n        const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);// _LINE_TENSION = 0.2\n        const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n        /*\n            calc actual offset by current point and next point\n        */\n        const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n        const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n        \n        this._curveDataSet.push({\n            oriPoint: currentPoint,\n            pre: {x: preControlPointX, y: preControlPointY}, \n            next: {x: nextControlPointX, y: nextControlPointY},\n        });\n    }\n```\n","slug":"從無到有DIY-chart-二","published":1,"updated":"2019-10-11T07:55:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bpg001i2bpj2s9btrxn","content":"<p>增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下<br>\n<html>\n    <head>\n    \n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\nclass Chart{\n    constructor(params){\n    this._LINE_TENSION = 0.2\n    this._LINE_WIDTH_ORI = 2;\n    this._LINE_WIDTH_FOCUS = 5;\n    this._COLOR_GRAY = 'gray';\n    this._COLOR_WHITE = 'white';\n    \n    this._id = params.id;\n    this._matrix = params.matrix;\n    this._radius = params.radius;\n    this._dataSet = [];\n    this._curveDataSet = [];\n    \n    this._canvas;\n    this._canvasWidth;\n    this._canvasHeight;\n    this._ctx;\n    this._preFocusPoint;\n    \n    this._Coordinate;\n    \n    this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    \n        this._initCoordinate();\n        this._initDataSet();\n        this._initCurveLines();\n        this._bindMouseEvent();\n        this.draw();\n    }\n    \n    _initCoordinate(){\n        this._Coordinate = new Coordinate({\n            canvas: this._canvas,\n            matrix: this._matrix\n        });\n    }\n\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n    \n    _initFrame(){\n        const rect = this._Coordinate.getChartBoundingRect();\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n        \n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n    \n    _initLines(){\n        this._ctx.beginPath();\n        const dataLength = this._dataSet.length;\n        if(dataLength < 2) return;\n        if(dataLength == 2){\n            const firstPoint = this._dataSet[0];\n            const secondPoint = this._dataSet[1];\n            this._ctx.moveTo(firstPoint.x, firstPoint.y);\n            this._ctx.lineTo(secondPoint.x, secondPoint.y);\n            this._ctx.stroke();\n            return;\n        }\n        \n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                this._ctx.moveTo(point.x, point.y);\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            this._ctx.bezierCurveTo(\n                preControlPoint.next.x, preControlPoint.next.y, \n                controlPoint.pre.x, controlPoint.pre.y, \n                point.x, point.y\n            );            \n        }\n        this._ctx.stroke();\n    }\n    \n    _showControlPoint(){\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            \n            this._drawCircle({x: preControlPoint.next.x, y: preControlPoint.next.y, radius: 2, lineWidth: 1, color: preControlPoint.oriPoint.color});\n            this._drawCircle({x: controlPoint.pre.x,     y: controlPoint.pre.y,     radius: 2, lineWidth: 1, color: controlPoint.oriPoint.color});\n            \n            this._ctx.stroke();\n        }\n    }\n    \n    _initCircles(){\n        const _self = this;\n        this._dataSet.forEach((point) => {\n            _self._drawCircle({\n                x: point.x, \n                y: point.y, \n                radius: _self._radius, \n                lineWidth: _self._LINE_WIDTH_ORI,\n                color: point.color\n            });\n        });\n    }\n    \n    _initCurveLines(){\n        const dataLength = this._dataSet.length;\n        /*\n            less than three points don't need to use curve\n        */\n        if(dataLength <= 2) return;\n        for(let index=1; index<(dataLength-1); index++){\n            const prePoint = this._dataSet[index - 1];\n            const currentPoint = this._dataSet[index];\n            const nextPoint = this._dataSet[index + 1];\n            /*\n                use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n            */\n            const deltaX = nextPoint.x - prePoint.x;\n            const deltaY = nextPoint.y - prePoint.y;\n            const distance = this._distance(prePoint, nextPoint);\n            const cos = deltaX / distance;\n            const sin = deltaY / distance;\n            /*\n                calc current point distance between two points pre and next\n            */\n            const preRelativeDistance = this._distance(prePoint, currentPoint);\n            const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n            /*\n                calc actual offset by current point and pre point\n                ps: actual offset = current point - (scale * two point distance * tension)\n            */\n            const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);\n            const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n            /*\n                calc actual offset by current point and next point\n            */\n            const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n            const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n            /*\n                \n            */\n            this._curveDataSet.push({\n                oriPoint: currentPoint,\n                pre: {x: preControlPointX, y: preControlPointY}, \n                next: {x: nextControlPointX, y: nextControlPointY},\n            });\n            \n        }\n    \n        const firstPoint = this._dataSet[0];\n        const secondCurvePoint = this._curveDataSet[1];\n        this._curveDataSet.unshift({\n            oriPoint: firstPoint,\n            next: {\n                x: (firstPoint.x + secondCurvePoint.pre.x) / 2,\n                y: (firstPoint.y + secondCurvePoint.pre.y) / 2\n            }\n        });\n        \n        const lastPoint = this._dataSet[dataLength - 1];\n        const secondLastCurvePoint = this._curveDataSet[dataLength - 2];\n        this._curveDataSet.push({\n            oriPoint: lastPoint,\n            pre: {\n                x: (lastPoint.x + secondLastCurvePoint.next.x) / 2, \n                y: (lastPoint.y + secondLastCurvePoint.next.y) / 2\n            }\n        });\n    }\n    \n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n    \n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n    \n    _drawRect(params){\n        this._ctx.lineWidth = params.lineWidth;\n        this._ctx.strokeStyle = params.color;\n        this._ctx.beginPath();\n        this._ctx.rect(params.x, params.y, params.width, params.height);\n        this._ctx.stroke();\n    }\n    \n    _drawLine(point1, point2){\n        this._ctx.lineWidth = point2.lineWidth;\n        this._ctx.strokeStyle = point2.color;\n        this._ctx.beginPath();\n        this._ctx.moveTo(point1.x, point1.y);\n        this._ctx.lineTo(point2.x, point2.y);\n        this._ctx.stroke();\n    }\n\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n    \n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n            if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n    \n    _clear(){\n        this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n    }\n    \n    /* public */\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n    \n    render(){\n        this._clear();\n        this.draw();\n        console.log('render');\n    }\n\n    printDataSet(){\n        console.log('dataSet', this._dataSet);\n    }\n}\n\nclass Coordinate{\n    constructor(params){\n        this._LEFT_OFFSET = 20;\n        this._BOTTOM_OFFSET = 20;\n        this._TOP_OFFSET = 10;\n        this._RIGHT_OFFSET = 10;\n        \n        this._canvas = params.canvas;\n        this._oriMatrix = params.matrix;\n        \n        this._chartBoundingRect;\n        this._xAxis;\n        this._yAxis;\n        \n        this._init();\n    }\n    \n    _init(){\n        this._initChartBoundingRect();\n        this._initXAxisAndYAxis();\n    }\n    \n    _initChartBoundingRect(){\n        const oriCanvasRect = this._canvas.getBoundingClientRect();\n        //console.log(oriCanvasRect);\n        this._chartBoundingRect = {\n            left: 0 + this._LEFT_OFFSET,\n            top: 0 + this._TOP_OFFSET,\n            bottom: oriCanvasRect.height - this._BOTTOM_OFFSET,\n            right: oriCanvasRect.width - this._RIGHT_OFFSET,\n            \n            width: oriCanvasRect.width - this._LEFT_OFFSET - this._RIGHT_OFFSET,\n            height: oriCanvasRect.height - this._BOTTOM_OFFSET - this._TOP_OFFSET,\n        }\n        console.log(this._chartBoundingRect);\n    }\n\n    _initXAxisAndYAxis(){\n        let xMax = Number.MIN_VALUE;\n        let xMin = Number.MAX_VALUE;\n        \n        let yMax = Number.MIN_VALUE;\n        let yMin = Number.MAX_VALUE;\n        \n        this._oriMatrix.forEach((point) => {\n            const x = point[0];\n            const y = point[1];\n            \n            xMax = Math.max(xMax, x);\n            xMin = Math.min(xMin, x);\n            \n            yMax = Math.max(yMax, y);\n            yMin = Math.min(yMin, y);\n        });\n        \n        const xNormal = (xMax - xMin);\n        const yNormal = (yMax - yMin);\n    }\n    \n    getChartBoundingRect(){\n        return this._chartBoundingRect;\n    }\n}\n\n(function(global){\n    const canvasId = 'chart';\n    const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n    const radius = 4;\n    const chart = new Chart({\n        id: canvasId, \n        matrix: matrix,\n        radius: radius\n    });\n    chart.draw();\n    chart.printDataSet();\n    console.log('chart', chart);\n    console.log(chart._id);\n})(this);\n</script>\n</p>\n<p>主要增加的程式碼如下，參考chart.js繪製曲線的方式，自己試做看看，主要是針對點與點之間距離的計算出偏移強度<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> index=<span class=\"number\">1</span>; index&lt;(dataLength<span class=\"number\">-1</span>); index++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prePoint = <span class=\"keyword\">this</span>._dataSet[index - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> currentPoint = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextPoint = <span class=\"keyword\">this</span>._dataSet[index + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> deltaX = nextPoint.x - prePoint.x;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> deltaY = nextPoint.y - prePoint.y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> distance = <span class=\"keyword\">this</span>._distance(prePoint, nextPoint);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cos = deltaX / distance;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sin = deltaY / distance;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc current point distance between two points pre and next</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preRelativeDistance = <span class=\"keyword\">this</span>._distance(prePoint, currentPoint);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextRelativeDistance = <span class=\"keyword\">this</span>._distance(currentPoint, nextPoint);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc actual offset by current point and pre point</span></span><br><span class=\"line\"><span class=\"comment\">        ps: actual offset = current point - (scale * two point distance * tension)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preControlPointX = currentPoint.x - (cos * preRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);<span class=\"comment\">// _LINE_TENSION = 0.2</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preControlPointY = currentPoint.y - (sin * preRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc actual offset by current point and next point</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>._curveDataSet.push(&#123;</span><br><span class=\"line\">        oriPoint: currentPoint,</span><br><span class=\"line\">        pre: &#123;<span class=\"attr\">x</span>: preControlPointX, <span class=\"attr\">y</span>: preControlPointY&#125;, </span><br><span class=\"line\">        next: &#123;<span class=\"attr\">x</span>: nextControlPointX, <span class=\"attr\">y</span>: nextControlPointY&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>增加曲線效果，點與點之間的線條轉折變得更加柔和，效果如下<br>\n<html>\n    <head>\n    \n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\nclass Chart{\n    constructor(params){\n    this._LINE_TENSION = 0.2\n    this._LINE_WIDTH_ORI = 2;\n    this._LINE_WIDTH_FOCUS = 5;\n    this._COLOR_GRAY = 'gray';\n    this._COLOR_WHITE = 'white';\n    \n    this._id = params.id;\n    this._matrix = params.matrix;\n    this._radius = params.radius;\n    this._dataSet = [];\n    this._curveDataSet = [];\n    \n    this._canvas;\n    this._canvasWidth;\n    this._canvasHeight;\n    this._ctx;\n    this._preFocusPoint;\n    \n    this._Coordinate;\n    \n    this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    \n        this._initCoordinate();\n        this._initDataSet();\n        this._initCurveLines();\n        this._bindMouseEvent();\n        this.draw();\n    }\n    \n    _initCoordinate(){\n        this._Coordinate = new Coordinate({\n            canvas: this._canvas,\n            matrix: this._matrix\n        });\n    }\n\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n    \n    _initFrame(){\n        const rect = this._Coordinate.getChartBoundingRect();\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n        \n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n    \n    _initLines(){\n        this._ctx.beginPath();\n        const dataLength = this._dataSet.length;\n        if(dataLength < 2) return;\n        if(dataLength == 2){\n            const firstPoint = this._dataSet[0];\n            const secondPoint = this._dataSet[1];\n            this._ctx.moveTo(firstPoint.x, firstPoint.y);\n            this._ctx.lineTo(secondPoint.x, secondPoint.y);\n            this._ctx.stroke();\n            return;\n        }\n        \n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                this._ctx.moveTo(point.x, point.y);\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            this._ctx.bezierCurveTo(\n                preControlPoint.next.x, preControlPoint.next.y, \n                controlPoint.pre.x, controlPoint.pre.y, \n                point.x, point.y\n            );            \n        }\n        this._ctx.stroke();\n    }\n    \n    _showControlPoint(){\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                continue;\n            }\n            const preControlPoint = this._curveDataSet[index - 1];\n            const controlPoint = this._curveDataSet[index];\n            \n            this._drawCircle({x: preControlPoint.next.x, y: preControlPoint.next.y, radius: 2, lineWidth: 1, color: preControlPoint.oriPoint.color});\n            this._drawCircle({x: controlPoint.pre.x,     y: controlPoint.pre.y,     radius: 2, lineWidth: 1, color: controlPoint.oriPoint.color});\n            \n            this._ctx.stroke();\n        }\n    }\n    \n    _initCircles(){\n        const _self = this;\n        this._dataSet.forEach((point) => {\n            _self._drawCircle({\n                x: point.x, \n                y: point.y, \n                radius: _self._radius, \n                lineWidth: _self._LINE_WIDTH_ORI,\n                color: point.color\n            });\n        });\n    }\n    \n    _initCurveLines(){\n        const dataLength = this._dataSet.length;\n        /*\n            less than three points don't need to use curve\n        */\n        if(dataLength <= 2) return;\n        for(let index=1; index<(dataLength-1); index++){\n            const prePoint = this._dataSet[index - 1];\n            const currentPoint = this._dataSet[index];\n            const nextPoint = this._dataSet[index + 1];\n            /*\n                use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale\n            */\n            const deltaX = nextPoint.x - prePoint.x;\n            const deltaY = nextPoint.y - prePoint.y;\n            const distance = this._distance(prePoint, nextPoint);\n            const cos = deltaX / distance;\n            const sin = deltaY / distance;\n            /*\n                calc current point distance between two points pre and next\n            */\n            const preRelativeDistance = this._distance(prePoint, currentPoint);\n            const nextRelativeDistance = this._distance(currentPoint, nextPoint);\n            /*\n                calc actual offset by current point and pre point\n                ps: actual offset = current point - (scale * two point distance * tension)\n            */\n            const preControlPointX = currentPoint.x - (cos * preRelativeDistance * this._LINE_TENSION);\n            const preControlPointY = currentPoint.y - (sin * preRelativeDistance * this._LINE_TENSION);\n            /*\n                calc actual offset by current point and next point\n            */\n            const nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * this._LINE_TENSION);\n            const nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * this._LINE_TENSION);\n            /*\n                \n            */\n            this._curveDataSet.push({\n                oriPoint: currentPoint,\n                pre: {x: preControlPointX, y: preControlPointY}, \n                next: {x: nextControlPointX, y: nextControlPointY},\n            });\n            \n        }\n    \n        const firstPoint = this._dataSet[0];\n        const secondCurvePoint = this._curveDataSet[1];\n        this._curveDataSet.unshift({\n            oriPoint: firstPoint,\n            next: {\n                x: (firstPoint.x + secondCurvePoint.pre.x) / 2,\n                y: (firstPoint.y + secondCurvePoint.pre.y) / 2\n            }\n        });\n        \n        const lastPoint = this._dataSet[dataLength - 1];\n        const secondLastCurvePoint = this._curveDataSet[dataLength - 2];\n        this._curveDataSet.push({\n            oriPoint: lastPoint,\n            pre: {\n                x: (lastPoint.x + secondLastCurvePoint.next.x) / 2, \n                y: (lastPoint.y + secondLastCurvePoint.next.y) / 2\n            }\n        });\n    }\n    \n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n    \n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n    \n    _drawRect(params){\n        this._ctx.lineWidth = params.lineWidth;\n        this._ctx.strokeStyle = params.color;\n        this._ctx.beginPath();\n        this._ctx.rect(params.x, params.y, params.width, params.height);\n        this._ctx.stroke();\n    }\n    \n    _drawLine(point1, point2){\n        this._ctx.lineWidth = point2.lineWidth;\n        this._ctx.strokeStyle = point2.color;\n        this._ctx.beginPath();\n        this._ctx.moveTo(point1.x, point1.y);\n        this._ctx.lineTo(point2.x, point2.y);\n        this._ctx.stroke();\n    }\n\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n    \n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n            if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n    \n    _clear(){\n        this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n    }\n    \n    /* public */\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n    \n    render(){\n        this._clear();\n        this.draw();\n        console.log('render');\n    }\n\n    printDataSet(){\n        console.log('dataSet', this._dataSet);\n    }\n}\n\nclass Coordinate{\n    constructor(params){\n        this._LEFT_OFFSET = 20;\n        this._BOTTOM_OFFSET = 20;\n        this._TOP_OFFSET = 10;\n        this._RIGHT_OFFSET = 10;\n        \n        this._canvas = params.canvas;\n        this._oriMatrix = params.matrix;\n        \n        this._chartBoundingRect;\n        this._xAxis;\n        this._yAxis;\n        \n        this._init();\n    }\n    \n    _init(){\n        this._initChartBoundingRect();\n        this._initXAxisAndYAxis();\n    }\n    \n    _initChartBoundingRect(){\n        const oriCanvasRect = this._canvas.getBoundingClientRect();\n        //console.log(oriCanvasRect);\n        this._chartBoundingRect = {\n            left: 0 + this._LEFT_OFFSET,\n            top: 0 + this._TOP_OFFSET,\n            bottom: oriCanvasRect.height - this._BOTTOM_OFFSET,\n            right: oriCanvasRect.width - this._RIGHT_OFFSET,\n            \n            width: oriCanvasRect.width - this._LEFT_OFFSET - this._RIGHT_OFFSET,\n            height: oriCanvasRect.height - this._BOTTOM_OFFSET - this._TOP_OFFSET,\n        }\n        console.log(this._chartBoundingRect);\n    }\n\n    _initXAxisAndYAxis(){\n        let xMax = Number.MIN_VALUE;\n        let xMin = Number.MAX_VALUE;\n        \n        let yMax = Number.MIN_VALUE;\n        let yMin = Number.MAX_VALUE;\n        \n        this._oriMatrix.forEach((point) => {\n            const x = point[0];\n            const y = point[1];\n            \n            xMax = Math.max(xMax, x);\n            xMin = Math.min(xMin, x);\n            \n            yMax = Math.max(yMax, y);\n            yMin = Math.min(yMin, y);\n        });\n        \n        const xNormal = (xMax - xMin);\n        const yNormal = (yMax - yMin);\n    }\n    \n    getChartBoundingRect(){\n        return this._chartBoundingRect;\n    }\n}\n\n(function(global){\n    const canvasId = 'chart';\n    const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n    const radius = 4;\n    const chart = new Chart({\n        id: canvasId, \n        matrix: matrix,\n        radius: radius\n    });\n    chart.draw();\n    chart.printDataSet();\n    console.log('chart', chart);\n    console.log(chart._id);\n})(this);\n</script>\n</p>\n<p>主要增加的程式碼如下，參考chart.js繪製曲線的方式，自己試做看看，主要是針對點與點之間距離的計算出偏移強度<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> index=<span class=\"number\">1</span>; index&lt;(dataLength<span class=\"number\">-1</span>); index++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prePoint = <span class=\"keyword\">this</span>._dataSet[index - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> currentPoint = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextPoint = <span class=\"keyword\">this</span>._dataSet[index + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        use pre point p(x0, y0) and next p(x2, y2) point to calc current point p(x1, y1) offset scale</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> deltaX = nextPoint.x - prePoint.x;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> deltaY = nextPoint.y - prePoint.y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> distance = <span class=\"keyword\">this</span>._distance(prePoint, nextPoint);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cos = deltaX / distance;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sin = deltaY / distance;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc current point distance between two points pre and next</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preRelativeDistance = <span class=\"keyword\">this</span>._distance(prePoint, currentPoint);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextRelativeDistance = <span class=\"keyword\">this</span>._distance(currentPoint, nextPoint);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc actual offset by current point and pre point</span></span><br><span class=\"line\"><span class=\"comment\">        ps: actual offset = current point - (scale * two point distance * tension)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preControlPointX = currentPoint.x - (cos * preRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);<span class=\"comment\">// _LINE_TENSION = 0.2</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> preControlPointY = currentPoint.y - (sin * preRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        calc actual offset by current point and next point</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextControlPointX = currentPoint.x + (cos * nextRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextControlPointY = currentPoint.y + (sin * nextRelativeDistance * <span class=\"keyword\">this</span>._LINE_TENSION);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>._curveDataSet.push(&#123;</span><br><span class=\"line\">        oriPoint: currentPoint,</span><br><span class=\"line\">        pre: &#123;<span class=\"attr\">x</span>: preControlPointX, <span class=\"attr\">y</span>: preControlPointY&#125;, </span><br><span class=\"line\">        next: &#123;<span class=\"attr\">x</span>: nextControlPointX, <span class=\"attr\">y</span>: nextControlPointY&#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"從無到有DIY chart (一)","date":"2018-04-01T13:32:41.000Z","_content":"\n目前工作中的前端開發因規範只能使用jQuery，要使用比較新的js語法只能透過underscore.js來實現\n但最近看了許多關於es6的資料，想要來練習一下\n若單純練習語法就太無聊了，所以決定使用es6的語法來DIY一個chart\n\n首先使用`class`定義Chart的Object\n在使用es6之前，只能透過擴展prototype達成method共用\n\n```js\n    var Chart = function(){\n        this._canvas;\n    )\n    \n    Chart.prototype = {\n        _init: function(){\n            this._canvas = document.getElementById(this._id);\n        }\n    }\n\n\n```\n\n現在有了`class`就不需要再分開寫了，看起來直覺多了\n\n```js\n    class Chart{\n        constructor(params){\n            this._canvas;\n        }\n        \n        _init(){\n            this._canvas = document.getElementById(this._id);\n        }\n    }\n```\n<!-- more -->\n\n首先初始化canvas，canvas可以想像成是一個畫布，我們必須設定畫布的大小和透過`getContext('2d')`取得渲染環境\n\n```js\n    constructor(params){\n        this._id = params.id;\n        this._canvas;\n        this._canvasWidth;\n        this._canvasHeight;\n        this._ctx;\n\n        this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    }\n\n\n```\n接著將chart的資料設置到canvas上，因為對於canvas而言原點是從左上角`(0,0)`的座標開始，所以使用原始資料直接打出點的話，會發現會上下相反，所以需要將y軸進行反轉\n\n因為還沒有想到chart要使用哪種顏色，就先使用亂數產生吧...\n```js\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n\n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n\n```\n\n我們的chart需要有畫布的外框且資料兩點需要使用直線串連起來\n```js\n    constructor(params){\n        this._LINE_TENSION = 0.2\n        this._LINE_WIDTH_ORI = 2;\n        this._LINE_WIDTH_FOCUS = 5;\n        this._COLOR_GRAY = 'gray';\n        this._COLOR_WHITE = 'white';\n    }\n\n    _initFrame(){\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n\n    _initLines(){\n        let prePoint;\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                prePoint = point;\n                continue;\n            }\n            this._drawLine(prePoint, point);\n            prePoint = point;\n        }\n    }\n\n    draw(){\n        this._initFrame();\n        this._initLines();\n    }\n```\n\n執行一下看看效果\n![chart](/images/chart-diy-001.png)\n\n\n有了簡單的雛形後，接著可以慢慢慢慢進行優化，增加新功能\n\n像現在我想凸顯每個資料點，將點放大，所以需要增加繪製圓形的function\n\n```js\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n\n```\n執行一下看看效果\n![chart](/images/chart-diy-002.png)\n\n市面上大部份cahrt都可以透過滑鼠去取得最近資料點，所以我們的chart也來要增加此功能\n\n首先在canvas增加mousemove事件，用於取得目前滑鼠的座標，接著算出每個資料點與目前滑鼠之間的距離 (這次參考Flot Charts的做法)\n```js\n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n\n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n        if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n```\n執行一下看一下效果 (這裡為了顯示實際效果， 所以就直接執行js而不是使用貼圖，瀏覽器必須支援es6才能看見，畢竟沒有透過babel進行轉換)\n{% raw %}\n<html>\n    <head>\n\n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n\n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n            \n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n        \n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n        \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    }\n    \n    (function(global){\n        const canvasId = 'chart';\n        const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n        const radius = 4;\n        const chart = new Chart({\n            id: canvasId, \n            matrix: matrix,\n            radius: radius\n        });\n        chart.draw();\n        chart.printDataSet();\n        console.log('chart', chart);\n        console.log(chart._id);\n    })(this);\n</script>\n{% endraw %}\n\n以下是完整的程式碼，看起來與java有點像...\n也可以到我[github](https://github.com/HengLin31/chart)上去下載完整的程式碼，今天的練習就到此結束了\n```js\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n            \n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n\n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n\n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n    \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it's need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    } \n```\n\n","source":"_posts/從無到有DIY-chart-一.md","raw":"---\ntitle: 從無到有DIY chart (一)\ndate: 2018-04-01 21:32:41\ntags:\n- js\n---\n\n目前工作中的前端開發因規範只能使用jQuery，要使用比較新的js語法只能透過underscore.js來實現\n但最近看了許多關於es6的資料，想要來練習一下\n若單純練習語法就太無聊了，所以決定使用es6的語法來DIY一個chart\n\n首先使用`class`定義Chart的Object\n在使用es6之前，只能透過擴展prototype達成method共用\n\n```js\n    var Chart = function(){\n        this._canvas;\n    )\n    \n    Chart.prototype = {\n        _init: function(){\n            this._canvas = document.getElementById(this._id);\n        }\n    }\n\n\n```\n\n現在有了`class`就不需要再分開寫了，看起來直覺多了\n\n```js\n    class Chart{\n        constructor(params){\n            this._canvas;\n        }\n        \n        _init(){\n            this._canvas = document.getElementById(this._id);\n        }\n    }\n```\n<!-- more -->\n\n首先初始化canvas，canvas可以想像成是一個畫布，我們必須設定畫布的大小和透過`getContext('2d')`取得渲染環境\n\n```js\n    constructor(params){\n        this._id = params.id;\n        this._canvas;\n        this._canvasWidth;\n        this._canvasHeight;\n        this._ctx;\n\n        this._init();\n    }\n\n    _init(){\n        this._canvas = document.getElementById(this._id);\n        if(!this._canvas.getContext){\n            throw \"can't get canvas context!\";\n        }\n        this._canvasWidth = this._canvas.width;\n        this._canvasHeight = this._canvas.height;\n        this._ctx = this._canvas.getContext('2d');\n    }\n\n\n```\n接著將chart的資料設置到canvas上，因為對於canvas而言原點是從左上角`(0,0)`的座標開始，所以使用原始資料直接打出點的話，會發現會上下相反，所以需要將y軸進行反轉\n\n因為還沒有想到chart要使用哪種顏色，就先使用亂數產生吧...\n```js\n    _initDataSet(){\n        for(const [index, point] of this._matrix.entries()){\n            var reverseY = this._canvasHeight - point[1];\n            this._dataSet.push({\n                index: index,\n                x: point[0],\n                y: reverseY,\n                color: this._randomColor()\n            });\n        }\n    }\n\n    _randomColor(){\n        return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n    }\n\n```\n\n我們的chart需要有畫布的外框且資料兩點需要使用直線串連起來\n```js\n    constructor(params){\n        this._LINE_TENSION = 0.2\n        this._LINE_WIDTH_ORI = 2;\n        this._LINE_WIDTH_FOCUS = 5;\n        this._COLOR_GRAY = 'gray';\n        this._COLOR_WHITE = 'white';\n    }\n\n    _initFrame(){\n        this._drawRect({\n            x: 0,\n            y: 0,\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            lineWidth: this._LINE_WIDTH_ORI,\n            color: this._COLOR_GRAY\n        });\n    }\n\n    _initLines(){\n        let prePoint;\n        for(const [index, point] of this._dataSet.entries()){\n            if(index == 0){\n                prePoint = point;\n                continue;\n            }\n            this._drawLine(prePoint, point);\n            prePoint = point;\n        }\n    }\n\n    draw(){\n        this._initFrame();\n        this._initLines();\n    }\n```\n\n執行一下看看效果\n![chart](/images/chart-diy-001.png)\n\n\n有了簡單的雛形後，接著可以慢慢慢慢進行優化，增加新功能\n\n像現在我想凸顯每個資料點，將點放大，所以需要增加繪製圓形的function\n\n```js\n    _drawCircle(point){\n        this._ctx.lineWidth = point.lineWidth;\n        this._ctx.beginPath();\n        this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n        this._ctx.strokeStyle = point.color;\n        this._ctx.fillStyle  = point.color;\n        this._ctx.fill();\n        this._ctx.stroke();\n    }\n\n    draw(){\n        this._initFrame();\n        this._initLines();\n        this._initCircles();\n    }\n\n```\n執行一下看看效果\n![chart](/images/chart-diy-002.png)\n\n市面上大部份cahrt都可以透過滑鼠去取得最近資料點，所以我們的chart也來要增加此功能\n\n首先在canvas增加mousemove事件，用於取得目前滑鼠的座標，接著算出每個資料點與目前滑鼠之間的距離 (這次參考Flot Charts的做法)\n```js\n    _bindMouseEvent(){\n        const _self = this;\n        this._canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = _self._canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            _self._findNearPointByMouse({x: x, y: y});\n        });\n    }\n\n    _drawFocusPoint(point){\n        this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n    }\n    \n    _findNearPointByMouse(mousePos){\n        let minDistancePoint;\n        let minDistance = Number.MAX_VALUE;\n        for(var index=0, size= this._dataSet.length; index<size; index++){\n            const currentPos = this._dataSet[index];\n            const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n            \n            if(minDistance > distanceBetweenTwoPoints){\n                minDistancePoint = currentPos;\n                minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n            }\n        }\n        if(!this._preFocusPoint){\n            this._drawFocusPoint(minDistancePoint);\n            this._preFocusPoint = minDistancePoint;\n            return;\n        }\n        /*\n        if pre point isn't self, it's need to render\n        */\n        if(this._preFocusPoint.index !== minDistancePoint.index){\n            this.render();\n            this._drawFocusPoint(minDistancePoint);\n        }\n        this._preFocusPoint = minDistancePoint;\n    }\n    \n    _distance(point1, point2){\n        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n    }\n```\n執行一下看一下效果 (這裡為了顯示實際效果， 所以就直接執行js而不是使用貼圖，瀏覽器必須支援es6才能看見，畢竟沒有透過babel進行轉換)\n{% raw %}\n<html>\n    <head>\n\n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n\n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n            \n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n        \n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n        \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    }\n    \n    (function(global){\n        const canvasId = 'chart';\n        const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n        const radius = 4;\n        const chart = new Chart({\n            id: canvasId, \n            matrix: matrix,\n            radius: radius\n        });\n        chart.draw();\n        chart.printDataSet();\n        console.log('chart', chart);\n        console.log(chart._id);\n    })(this);\n</script>\n{% endraw %}\n\n以下是完整的程式碼，看起來與java有點像...\n也可以到我[github](https://github.com/HengLin31/chart)上去下載完整的程式碼，今天的練習就到此結束了\n```js\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n            \n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n\n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n\n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n    \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it's need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    } \n```\n\n","slug":"從無到有DIY-chart-一","published":1,"updated":"2018-06-06T15:08:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1uo5bpo001m2bpjvcxmntmi","content":"<p>目前工作中的前端開發因規範只能使用jQuery，要使用比較新的js語法只能透過underscore.js來實現<br>但最近看了許多關於es6的資料，想要來練習一下<br>若單純練習語法就太無聊了，所以決定使用es6的語法來DIY一個chart</p>\n<p>首先使用<code>class</code>定義Chart的Object<br>在使用es6之前，只能透過擴展prototype達成method共用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Chart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">Chart.prototype = &#123;</span><br><span class=\"line\">    _init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>現在有了<code>class</code>就不需要再分開寫了，看起來直覺多了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chart</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _init()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>首先初始化canvas，canvas可以想像成是一個畫布，我們必須設定畫布的大小和透過<code>getContext(&#39;2d&#39;)</code>取得渲染環境</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._id = params.id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasWidth;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasHeight;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_init()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._canvas.getContext)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">\"can't get canvas context!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasWidth = <span class=\"keyword\">this</span>._canvas.width;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasHeight = <span class=\"keyword\">this</span>._canvas.height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx = <span class=\"keyword\">this</span>._canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接著將chart的資料設置到canvas上，因為對於canvas而言原點是從左上角<code>(0,0)</code>的座標開始，所以使用原始資料直接打出點的話，會發現會上下相反，所以需要將y軸進行反轉</p>\n<p>因為還沒有想到chart要使用哪種顏色，就先使用亂數產生吧…<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_initDataSet()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._matrix.entries())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> reverseY = <span class=\"keyword\">this</span>._canvasHeight - point[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet.push(&#123;</span><br><span class=\"line\">            index: index,</span><br><span class=\"line\">            x: point[<span class=\"number\">0</span>],</span><br><span class=\"line\">            y: reverseY,</span><br><span class=\"line\">            color: <span class=\"keyword\">this</span>._randomColor()</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_randomColor()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xFFFFFF</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我們的chart需要有畫布的外框且資料兩點需要使用直線串連起來<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_TENSION = <span class=\"number\">0.2</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_WIDTH_ORI = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._COLOR_GRAY = <span class=\"string\">'gray'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._COLOR_WHITE = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_initFrame()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._drawRect(&#123;</span><br><span class=\"line\">        x: <span class=\"number\">0</span>,</span><br><span class=\"line\">        y: <span class=\"number\">0</span>,</span><br><span class=\"line\">        width: <span class=\"keyword\">this</span>._canvasWidth,</span><br><span class=\"line\">        height: <span class=\"keyword\">this</span>._canvasHeight,</span><br><span class=\"line\">        lineWidth: <span class=\"keyword\">this</span>._LINE_WIDTH_ORI,</span><br><span class=\"line\">        color: <span class=\"keyword\">this</span>._COLOR_GRAY</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_initLines()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prePoint;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._dataSet.entries())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            prePoint = point;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawLine(prePoint, point);</span><br><span class=\"line\">        prePoint = point;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">draw()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>執行一下看看效果<br><img src=\"/images/chart-diy-001.png\" alt=\"chart\"></p>\n<p>有了簡單的雛形後，接著可以慢慢慢慢進行優化，增加新功能</p>\n<p>像現在我想凸顯每個資料點，將點放大，所以需要增加繪製圓形的function</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_drawCircle(point)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.lineWidth = point.lineWidth;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.arc(point.x, point.y, point.radius, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.strokeStyle = point.color;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.fillStyle  = point.color;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.fill();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">draw()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initCircles();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>執行一下看看效果<br><img src=\"/images/chart-diy-002.png\" alt=\"chart\"></p>\n<p>市面上大部份cahrt都可以透過滑鼠去取得最近資料點，所以我們的chart也來要增加此功能</p>\n<p>首先在canvas增加mousemove事件，用於取得目前滑鼠的座標，接著算出每個資料點與目前滑鼠之間的距離 (這次參考Flot Charts的做法)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_bindMouseEvent()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>, (event) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> rect = _self._canvas.getBoundingClientRect();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = event.clientX - rect.left;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = event.clientY - rect.top;</span><br><span class=\"line\">        _self._findNearPointByMouse(&#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_drawFocusPoint(point)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._drawCircle(&#123;<span class=\"attr\">x</span>: point.x, <span class=\"attr\">y</span>: point.y, <span class=\"attr\">radius</span>: <span class=\"keyword\">this</span>._radius, <span class=\"attr\">lineWidth</span>: <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS, <span class=\"attr\">color</span>: point.color&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_findNearPointByMouse(mousePos)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minDistancePoint;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minDistance = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> index=<span class=\"number\">0</span>, size= <span class=\"keyword\">this</span>._dataSet.length; index&lt;size; index++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> currentPos = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> distanceBetweenTwoPoints = <span class=\"keyword\">this</span>._distance(currentPos, mousePos);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minDistance &gt; distanceBetweenTwoPoints)&#123;</span><br><span class=\"line\">            minDistancePoint = currentPos;</span><br><span class=\"line\">            minDistance = <span class=\"built_in\">Math</span>.min(minDistance, distanceBetweenTwoPoints);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._preFocusPoint)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    if pre point isn't self, it's need to render</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._preFocusPoint.index !== minDistancePoint.index)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.render();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_distance(point1, point2)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"built_in\">Math</span>.pow(point1.x - point2.x, <span class=\"number\">2</span>) + <span class=\"built_in\">Math</span>.pow(point1.y - point2.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>執行一下看一下效果 (這裡為了顯示實際效果， 所以就直接執行js而不是使用貼圖，瀏覽器必須支援es6才能看見，畢竟沒有透過babel進行轉換)<br>\n<html>\n    <head>\n\n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n\n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n            \n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n        \n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n        \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    }\n    \n    (function(global){\n        const canvasId = 'chart';\n        const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n        const radius = 4;\n        const chart = new Chart({\n            id: canvasId, \n            matrix: matrix,\n            radius: radius\n        });\n        chart.draw();\n        chart.printDataSet();\n        console.log('chart', chart);\n        console.log(chart._id);\n    })(this);\n</script>\n</p>\n<p>以下是完整的程式碼，看起來與java有點像…<br>也可以到我<a href=\"https://github.com/HengLin31/chart\" target=\"_blank\" rel=\"noopener\">github</a>上去下載完整的程式碼，今天的練習就到此結束了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chart</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_TENSION = <span class=\"number\">0.2</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_WIDTH_ORI = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._COLOR_GRAY = <span class=\"string\">'gray'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._COLOR_WHITE = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._id = params.id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._matrix = params.matrix;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._radius = params.radius;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._curveDataSet = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasHeight;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _init()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._canvas.getContext)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"string\">\"can't get canvas context!\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasWidth = <span class=\"keyword\">this</span>._canvas.width;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasHeight = <span class=\"keyword\">this</span>._canvas.height;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx = <span class=\"keyword\">this</span>._canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initDataSet();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._bindMouseEvent();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _initDataSet()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._matrix.entries())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> reverseY = <span class=\"keyword\">this</span>._canvasHeight - point[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._dataSet.push(&#123;</span><br><span class=\"line\">                index: index,</span><br><span class=\"line\">                x: point[<span class=\"number\">0</span>],</span><br><span class=\"line\">                y: reverseY,</span><br><span class=\"line\">                color: <span class=\"keyword\">this</span>._randomColor()</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _initFrame()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawRect(&#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span>,</span><br><span class=\"line\">            width: <span class=\"keyword\">this</span>._canvasWidth,</span><br><span class=\"line\">            height: <span class=\"keyword\">this</span>._canvasHeight,</span><br><span class=\"line\">            lineWidth: <span class=\"keyword\">this</span>._LINE_WIDTH_ORI,</span><br><span class=\"line\">            color: <span class=\"keyword\">this</span>._COLOR_GRAY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _initLines()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> prePoint;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._dataSet.entries())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                prePoint = point;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawLine(prePoint, point);</span><br><span class=\"line\">            prePoint = point;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _initCircles()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet.forEach(<span class=\"function\">(<span class=\"params\">point</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            _self._drawCircle(&#123;</span><br><span class=\"line\">                x: point.x, </span><br><span class=\"line\">                y: point.y, </span><br><span class=\"line\">                radius: _self._radius, </span><br><span class=\"line\">                lineWidth: _self._LINE_WIDTH_ORI,</span><br><span class=\"line\">                color: point.color</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _bindMouseEvent()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>, (event) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> rect = _self._canvas.getBoundingClientRect();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = event.clientX - rect.left;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> y = event.clientY - rect.top;</span><br><span class=\"line\">            _self._findNearPointByMouse(&#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _randomColor()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xFFFFFF</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawRect(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = params.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = params.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.rect(params.x, params.y, params.width, params.height);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawLine(point1, point2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = point2.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = point2.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.moveTo(point1.x, point1.y);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineTo(point2.x, point2.y);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawCircle(point)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = point.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.arc(point.x, point.y, point.radius, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = point.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.fillStyle  = point.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.fill();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawFocusPoint(point)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawCircle(&#123;<span class=\"attr\">x</span>: point.x, <span class=\"attr\">y</span>: point.y, <span class=\"attr\">radius</span>: <span class=\"keyword\">this</span>._radius, <span class=\"attr\">lineWidth</span>: <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS, <span class=\"attr\">color</span>: point.color&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _findNearPointByMouse(mousePos)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> minDistancePoint;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> minDistance = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> index=<span class=\"number\">0</span>, size= <span class=\"keyword\">this</span>._dataSet.length; index&lt;size; index++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> currentPos = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">            <span class=\"keyword\">const</span> distanceBetweenTwoPoints = <span class=\"keyword\">this</span>._distance(currentPos, mousePos);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minDistance &gt; distanceBetweenTwoPoints)&#123;</span><br><span class=\"line\">                minDistancePoint = currentPos;</span><br><span class=\"line\">                minDistance = <span class=\"built_in\">Math</span>.min(minDistance, distanceBetweenTwoPoints);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._preFocusPoint)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        if pre point isn't self, it's need to render</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._preFocusPoint.index !== minDistancePoint.index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _distance(point1, point2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"built_in\">Math</span>.pow(point1.x - point2.x, <span class=\"number\">2</span>) + <span class=\"built_in\">Math</span>.pow(point1.y - point2.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clear()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>._canvasWidth, <span class=\"keyword\">this</span>._canvasHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* public */</span></span><br><span class=\"line\">    draw()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initCircles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._clear();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.draw();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>目前工作中的前端開發因規範只能使用jQuery，要使用比較新的js語法只能透過underscore.js來實現<br>但最近看了許多關於es6的資料，想要來練習一下<br>若單純練習語法就太無聊了，所以決定使用es6的語法來DIY一個chart</p>\n<p>首先使用<code>class</code>定義Chart的Object<br>在使用es6之前，只能透過擴展prototype達成method共用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Chart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">Chart.prototype = &#123;</span><br><span class=\"line\">    _init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>現在有了<code>class</code>就不需要再分開寫了，看起來直覺多了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chart</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _init()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>首先初始化canvas，canvas可以想像成是一個畫布，我們必須設定畫布的大小和透過<code>getContext(&#39;2d&#39;)</code>取得渲染環境</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._id = params.id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasWidth;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasHeight;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_init()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._canvas.getContext)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">\"can't get canvas context!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasWidth = <span class=\"keyword\">this</span>._canvas.width;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvasHeight = <span class=\"keyword\">this</span>._canvas.height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx = <span class=\"keyword\">this</span>._canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接著將chart的資料設置到canvas上，因為對於canvas而言原點是從左上角<code>(0,0)</code>的座標開始，所以使用原始資料直接打出點的話，會發現會上下相反，所以需要將y軸進行反轉</p>\n<p>因為還沒有想到chart要使用哪種顏色，就先使用亂數產生吧…<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_initDataSet()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._matrix.entries())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> reverseY = <span class=\"keyword\">this</span>._canvasHeight - point[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet.push(&#123;</span><br><span class=\"line\">            index: index,</span><br><span class=\"line\">            x: point[<span class=\"number\">0</span>],</span><br><span class=\"line\">            y: reverseY,</span><br><span class=\"line\">            color: <span class=\"keyword\">this</span>._randomColor()</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_randomColor()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xFFFFFF</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我們的chart需要有畫布的外框且資料兩點需要使用直線串連起來<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_TENSION = <span class=\"number\">0.2</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_WIDTH_ORI = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._COLOR_GRAY = <span class=\"string\">'gray'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._COLOR_WHITE = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_initFrame()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._drawRect(&#123;</span><br><span class=\"line\">        x: <span class=\"number\">0</span>,</span><br><span class=\"line\">        y: <span class=\"number\">0</span>,</span><br><span class=\"line\">        width: <span class=\"keyword\">this</span>._canvasWidth,</span><br><span class=\"line\">        height: <span class=\"keyword\">this</span>._canvasHeight,</span><br><span class=\"line\">        lineWidth: <span class=\"keyword\">this</span>._LINE_WIDTH_ORI,</span><br><span class=\"line\">        color: <span class=\"keyword\">this</span>._COLOR_GRAY</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_initLines()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prePoint;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._dataSet.entries())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            prePoint = point;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawLine(prePoint, point);</span><br><span class=\"line\">        prePoint = point;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">draw()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>執行一下看看效果<br><img src=\"/images/chart-diy-001.png\" alt=\"chart\"></p>\n<p>有了簡單的雛形後，接著可以慢慢慢慢進行優化，增加新功能</p>\n<p>像現在我想凸顯每個資料點，將點放大，所以需要增加繪製圓形的function</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_drawCircle(point)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.lineWidth = point.lineWidth;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.arc(point.x, point.y, point.radius, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.strokeStyle = point.color;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.fillStyle  = point.color;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.fill();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">draw()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._initCircles();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>執行一下看看效果<br><img src=\"/images/chart-diy-002.png\" alt=\"chart\"></p>\n<p>市面上大部份cahrt都可以透過滑鼠去取得最近資料點，所以我們的chart也來要增加此功能</p>\n<p>首先在canvas增加mousemove事件，用於取得目前滑鼠的座標，接著算出每個資料點與目前滑鼠之間的距離 (這次參考Flot Charts的做法)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_bindMouseEvent()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>, (event) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> rect = _self._canvas.getBoundingClientRect();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = event.clientX - rect.left;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = event.clientY - rect.top;</span><br><span class=\"line\">        _self._findNearPointByMouse(&#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_drawFocusPoint(point)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._drawCircle(&#123;<span class=\"attr\">x</span>: point.x, <span class=\"attr\">y</span>: point.y, <span class=\"attr\">radius</span>: <span class=\"keyword\">this</span>._radius, <span class=\"attr\">lineWidth</span>: <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS, <span class=\"attr\">color</span>: point.color&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_findNearPointByMouse(mousePos)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minDistancePoint;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minDistance = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> index=<span class=\"number\">0</span>, size= <span class=\"keyword\">this</span>._dataSet.length; index&lt;size; index++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> currentPos = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> distanceBetweenTwoPoints = <span class=\"keyword\">this</span>._distance(currentPos, mousePos);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minDistance &gt; distanceBetweenTwoPoints)&#123;</span><br><span class=\"line\">            minDistancePoint = currentPos;</span><br><span class=\"line\">            minDistance = <span class=\"built_in\">Math</span>.min(minDistance, distanceBetweenTwoPoints);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._preFocusPoint)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    if pre point isn't self, it's need to render</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._preFocusPoint.index !== minDistancePoint.index)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.render();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_distance(point1, point2)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"built_in\">Math</span>.pow(point1.x - point2.x, <span class=\"number\">2</span>) + <span class=\"built_in\">Math</span>.pow(point1.y - point2.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>執行一下看一下效果 (這裡為了顯示實際效果， 所以就直接執行js而不是使用貼圖，瀏覽器必須支援es6才能看見，畢竟沒有透過babel進行轉換)<br>\n<html>\n    <head>\n\n    </head>\n    <body>\n        <div align=\"center\">\n            <h2>Chart</h2>\n            <div>\n                <canvas id=\"chart\" width=\"300\" height=\"150\"></canvas>\n            </div>\n        </div>\n    </body>\n</html>\n<script language=\"javascript\">\n    class Chart{\n        constructor(params){\n            this._LINE_TENSION = 0.2\n            this._LINE_WIDTH_ORI = 2;\n            this._LINE_WIDTH_FOCUS = 5;\n            this._COLOR_GRAY = 'gray';\n            this._COLOR_WHITE = 'white';\n            \n            this._id = params.id;\n            this._matrix = params.matrix;\n            this._radius = params.radius;\n            this._dataSet = [];\n            this._curveDataSet = [];\n\n            this._canvas;\n            this._canvasWidth;\n            this._canvasHeight;\n            this._ctx;\n            this._preFocusPoint;\n            \n            this._init();\n        }\n\n        _init(){\n            this._canvas = document.getElementById(this._id);\n            if(!this._canvas.getContext){\n                throw \"can't get canvas context!\";\n            }\n            this._canvasWidth = this._canvas.width;\n            this._canvasHeight = this._canvas.height;\n            this._ctx = this._canvas.getContext('2d');\n            \n            this._initDataSet();\n            this._bindMouseEvent();\n            this.draw();\n        }\n        \n        _initDataSet(){\n            for(const [index, point] of this._matrix.entries()){\n                var reverseY = this._canvasHeight - point[1];\n                this._dataSet.push({\n                    index: index,\n                    x: point[0],\n                    y: reverseY,\n                    color: this._randomColor()\n                });\n            }\n        }\n        \n        _initFrame(){\n            this._drawRect({\n                x: 0,\n                y: 0,\n                width: this._canvasWidth,\n                height: this._canvasHeight,\n                lineWidth: this._LINE_WIDTH_ORI,\n                color: this._COLOR_GRAY\n            });\n        }\n        \n        _initLines(){\n            let prePoint;\n            for(const [index, point] of this._dataSet.entries()){\n                if(index == 0){\n                    prePoint = point;\n                    continue;\n                }\n                this._drawLine(prePoint, point);\n                prePoint = point;\n            }\n        }\n        \n        _initCircles(){\n            const _self = this;\n            this._dataSet.forEach((point) => {\n                _self._drawCircle({\n                    x: point.x, \n                    y: point.y, \n                    radius: _self._radius, \n                    lineWidth: _self._LINE_WIDTH_ORI,\n                    color: point.color\n                });\n            });\n        }\n        \n        _bindMouseEvent(){\n            const _self = this;\n            this._canvas.addEventListener(\"mousemove\", (event) => {\n                const rect = _self._canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                _self._findNearPointByMouse({x: x, y: y});\n            });\n        }\n        \n        _randomColor(){\n            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n        }\n        \n        _drawRect(params){\n            this._ctx.lineWidth = params.lineWidth;\n            this._ctx.strokeStyle = params.color;\n            this._ctx.beginPath();\n            this._ctx.rect(params.x, params.y, params.width, params.height);\n            this._ctx.stroke();\n        }\n        \n        _drawLine(point1, point2){\n            this._ctx.lineWidth = point2.lineWidth;\n            this._ctx.strokeStyle = point2.color;\n            this._ctx.beginPath();\n            this._ctx.moveTo(point1.x, point1.y);\n            this._ctx.lineTo(point2.x, point2.y);\n            this._ctx.stroke();\n        }\n        \n        _drawCircle(point){\n            this._ctx.lineWidth = point.lineWidth;\n            this._ctx.beginPath();\n            this._ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);\n            this._ctx.strokeStyle = point.color;\n            this._ctx.fillStyle  = point.color;\n            this._ctx.fill();\n            this._ctx.stroke();\n        }\n        \n        _drawFocusPoint(point){\n            this._drawCircle({x: point.x, y: point.y, radius: this._radius, lineWidth: this._LINE_WIDTH_FOCUS, color: point.color});\n        }\n        \n        _findNearPointByMouse(mousePos){\n            let minDistancePoint;\n            let minDistance = Number.MAX_VALUE;\n            for(var index=0, size= this._dataSet.length; index<size; index++){\n                const currentPos = this._dataSet[index];\n                const distanceBetweenTwoPoints = this._distance(currentPos, mousePos);\n                \n                if(minDistance > distanceBetweenTwoPoints){\n                    minDistancePoint = currentPos;\n                    minDistance = Math.min(minDistance, distanceBetweenTwoPoints);\n                }\n            }\n            if(!this._preFocusPoint){\n                this._drawFocusPoint(minDistancePoint);\n                this._preFocusPoint = minDistancePoint;\n                return;\n            }\n            /*\n            if pre point isn't self, it need to render\n            */\n            if(this._preFocusPoint.index !== minDistancePoint.index){\n                this.render();\n                this._drawFocusPoint(minDistancePoint);\n            }\n            this._preFocusPoint = minDistancePoint;\n        }\n        \n        _distance(point1, point2){\n            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n        }\n        \n        _clear(){\n            this._ctx.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        }\n        \n        /* public */\n        draw(){\n            this._initFrame();\n            this._initLines();\n            this._initCircles();\n        }\n        \n        render(){\n            this._clear();\n            this.draw();\n            console.log('render');\n        }\n    }\n    \n    (function(global){\n        const canvasId = 'chart';\n        const matrix = [[10, 90], [30, 40], [70, 80], [90, 40], [120, 120], [150, 10], [190, 70]];\n        const radius = 4;\n        const chart = new Chart({\n            id: canvasId, \n            matrix: matrix,\n            radius: radius\n        });\n        chart.draw();\n        chart.printDataSet();\n        console.log('chart', chart);\n        console.log(chart._id);\n    })(this);\n</script>\n</p>\n<p>以下是完整的程式碼，看起來與java有點像…<br>也可以到我<a href=\"https://github.com/HengLin31/chart\" target=\"_blank\" rel=\"noopener\">github</a>上去下載完整的程式碼，今天的練習就到此結束了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chart</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_TENSION = <span class=\"number\">0.2</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_WIDTH_ORI = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._COLOR_GRAY = <span class=\"string\">'gray'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._COLOR_WHITE = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._id = params.id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._matrix = params.matrix;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._radius = params.radius;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._curveDataSet = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasHeight;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _init()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>._id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._canvas.getContext)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"string\">\"can't get canvas context!\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasWidth = <span class=\"keyword\">this</span>._canvas.width;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvasHeight = <span class=\"keyword\">this</span>._canvas.height;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx = <span class=\"keyword\">this</span>._canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initDataSet();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._bindMouseEvent();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _initDataSet()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._matrix.entries())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> reverseY = <span class=\"keyword\">this</span>._canvasHeight - point[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._dataSet.push(&#123;</span><br><span class=\"line\">                index: index,</span><br><span class=\"line\">                x: point[<span class=\"number\">0</span>],</span><br><span class=\"line\">                y: reverseY,</span><br><span class=\"line\">                color: <span class=\"keyword\">this</span>._randomColor()</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _initFrame()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawRect(&#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span>,</span><br><span class=\"line\">            width: <span class=\"keyword\">this</span>._canvasWidth,</span><br><span class=\"line\">            height: <span class=\"keyword\">this</span>._canvasHeight,</span><br><span class=\"line\">            lineWidth: <span class=\"keyword\">this</span>._LINE_WIDTH_ORI,</span><br><span class=\"line\">            color: <span class=\"keyword\">this</span>._COLOR_GRAY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _initLines()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> prePoint;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> [index, point] <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>._dataSet.entries())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                prePoint = point;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawLine(prePoint, point);</span><br><span class=\"line\">            prePoint = point;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _initCircles()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._dataSet.forEach(<span class=\"function\">(<span class=\"params\">point</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            _self._drawCircle(&#123;</span><br><span class=\"line\">                x: point.x, </span><br><span class=\"line\">                y: point.y, </span><br><span class=\"line\">                radius: _self._radius, </span><br><span class=\"line\">                lineWidth: _self._LINE_WIDTH_ORI,</span><br><span class=\"line\">                color: point.color</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _bindMouseEvent()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> _self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>, (event) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> rect = _self._canvas.getBoundingClientRect();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = event.clientX - rect.left;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> y = event.clientY - rect.top;</span><br><span class=\"line\">            _self._findNearPointByMouse(&#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _randomColor()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0xFFFFFF</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawRect(params)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = params.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = params.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.rect(params.x, params.y, params.width, params.height);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawLine(point1, point2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = point2.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = point2.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.moveTo(point1.x, point1.y);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineTo(point2.x, point2.y);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawCircle(point)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.lineWidth = point.lineWidth;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.beginPath();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.arc(point.x, point.y, point.radius, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.strokeStyle = point.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.fillStyle  = point.color;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.fill();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.stroke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _drawFocusPoint(point)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._drawCircle(&#123;<span class=\"attr\">x</span>: point.x, <span class=\"attr\">y</span>: point.y, <span class=\"attr\">radius</span>: <span class=\"keyword\">this</span>._radius, <span class=\"attr\">lineWidth</span>: <span class=\"keyword\">this</span>._LINE_WIDTH_FOCUS, <span class=\"attr\">color</span>: point.color&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _findNearPointByMouse(mousePos)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> minDistancePoint;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> minDistance = <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> index=<span class=\"number\">0</span>, size= <span class=\"keyword\">this</span>._dataSet.length; index&lt;size; index++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> currentPos = <span class=\"keyword\">this</span>._dataSet[index];</span><br><span class=\"line\">            <span class=\"keyword\">const</span> distanceBetweenTwoPoints = <span class=\"keyword\">this</span>._distance(currentPos, mousePos);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minDistance &gt; distanceBetweenTwoPoints)&#123;</span><br><span class=\"line\">                minDistancePoint = currentPos;</span><br><span class=\"line\">                minDistance = <span class=\"built_in\">Math</span>.min(minDistance, distanceBetweenTwoPoints);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>._preFocusPoint)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        if pre point isn't self, it's need to render</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>._preFocusPoint.index !== minDistancePoint.index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._drawFocusPoint(minDistancePoint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._preFocusPoint = minDistancePoint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _distance(point1, point2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(<span class=\"built_in\">Math</span>.pow(point1.x - point2.x, <span class=\"number\">2</span>) + <span class=\"built_in\">Math</span>.pow(point1.y - point2.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clear()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>._canvasWidth, <span class=\"keyword\">this</span>._canvasHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* public */</span></span><br><span class=\"line\">    draw()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initFrame();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initLines();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._initCircles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._clear();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.draw();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck1uo5bod00002bpju7f0nxda","tag_id":"ck1uo5boj00022bpj9pglmt2d","_id":"ck1uo5bop00072bpj7hbxqvmn"},{"post_id":"ck1uo5boh00012bpj5b6vg9zz","tag_id":"ck1uo5boj00022bpj9pglmt2d","_id":"ck1uo5bos000b2bpj4q3dxvhl"},{"post_id":"ck1uo5bok00032bpj5c8sh2oj","tag_id":"ck1uo5bor000a2bpjn9re7w56","_id":"ck1uo5bow000g2bpj6rajldyx"},{"post_id":"ck1uo5bov000f2bpjmvx8fhd8","tag_id":"ck1uo5bov000e2bpj3vuj2ypl","_id":"ck1uo5box000j2bpjymdsj0to"},{"post_id":"ck1uo5bom00042bpjq5azf4z3","tag_id":"ck1uo5bov000e2bpj3vuj2ypl","_id":"ck1uo5bp0000o2bpjoy4klz0n"},{"post_id":"ck1uo5bom00042bpjq5azf4z3","tag_id":"ck1uo5box000i2bpjgiafzs4d","_id":"ck1uo5bp0000p2bpjyd1cmn00"},{"post_id":"ck1uo5bon00052bpj7uz02mma","tag_id":"ck1uo5boz000m2bpj5tsdl2en","_id":"ck1uo5bp0000r2bpjkrkh5jns"},{"post_id":"ck1uo5bop00082bpj9ko9u88t","tag_id":"ck1uo5bp0000q2bpj5k1pdcsu","_id":"ck1uo5bp1000u2bpj276s58pk"},{"post_id":"ck1uo5bop00082bpj9ko9u88t","tag_id":"ck1uo5bp0000s2bpjptiqp6l7","_id":"ck1uo5bp1000v2bpjt1997sgv"},{"post_id":"ck1uo5bor00092bpj813xdzj6","tag_id":"ck1uo5bov000e2bpj3vuj2ypl","_id":"ck1uo5bp2000z2bpj6f2yzb7k"},{"post_id":"ck1uo5bor00092bpj813xdzj6","tag_id":"ck1uo5bp1000w2bpjo6bz7v3p","_id":"ck1uo5bp200102bpjf3cbbsom"},{"post_id":"ck1uo5bor00092bpj813xdzj6","tag_id":"ck1uo5bp1000x2bpjenccuzrq","_id":"ck1uo5bp200122bpjlrp7x339"},{"post_id":"ck1uo5bos000c2bpjjgscmgw3","tag_id":"ck1uo5bp2000y2bpjsw58wkh0","_id":"ck1uo5bp200132bpjtdl7f0ni"},{"post_id":"ck1uo5bot000d2bpjnwowjrnr","tag_id":"ck1uo5bp200112bpjie0g2jnk","_id":"ck1uo5bp300152bpj6daxktrr"},{"post_id":"ck1uo5bow000h2bpjp0n43pdk","tag_id":"ck1uo5bp2000y2bpjsw58wkh0","_id":"ck1uo5bp300192bpjrfj2wl3x"},{"post_id":"ck1uo5bow000h2bpjp0n43pdk","tag_id":"ck1uo5bp300162bpj0oznggbm","_id":"ck1uo5bp3001a2bpjnjkuuu5d"},{"post_id":"ck1uo5bow000h2bpjp0n43pdk","tag_id":"ck1uo5bp300172bpjp6aylg2f","_id":"ck1uo5bp4001c2bpj3x2ofndu"},{"post_id":"ck1uo5box000k2bpjrt8u0qdf","tag_id":"ck1uo5bov000e2bpj3vuj2ypl","_id":"ck1uo5bp4001d2bpjvmzofb25"},{"post_id":"ck1uo5box000k2bpjrt8u0qdf","tag_id":"ck1uo5bp300182bpjb10r4u94","_id":"ck1uo5bp4001f2bpjrtyeo41s"},{"post_id":"ck1uo5boy000l2bpj0l19m7tq","tag_id":"ck1uo5boz000m2bpj5tsdl2en","_id":"ck1uo5bp4001g2bpjqn619k40"},{"post_id":"ck1uo5boz000n2bpjueu9fmb9","tag_id":"ck1uo5bp4001e2bpjx2kuxrx4","_id":"ck1uo5bp4001h2bpj2k323xxf"},{"post_id":"ck1uo5bpg001i2bpj2s9btrxn","tag_id":"ck1uo5bpi001k2bpjmij3bvbc","_id":"ck1uo5bpj001l2bpjfen31lng"},{"post_id":"ck1uo5bpo001m2bpjvcxmntmi","tag_id":"ck1uo5bpi001k2bpjmij3bvbc","_id":"ck1uo5bpp001n2bpje18vmttt"}],"Tag":[{"name":"conference","_id":"ck1uo5boj00022bpj9pglmt2d"},{"name":"shell","_id":"ck1uo5bor000a2bpjn9re7w56"},{"name":"java","_id":"ck1uo5bov000e2bpj3vuj2ypl"},{"name":"thread","_id":"ck1uo5box000i2bpjgiafzs4d"},{"name":"illustrator","_id":"ck1uo5boz000m2bpj5tsdl2en"},{"name":"gradle","_id":"ck1uo5bp0000q2bpj5k1pdcsu"},{"name":"unit test","_id":"ck1uo5bp0000s2bpjptiqp6l7"},{"name":"android","_id":"ck1uo5bp1000w2bpjo6bz7v3p"},{"name":"memory leak","_id":"ck1uo5bp1000x2bpjenccuzrq"},{"name":"math","_id":"ck1uo5bp2000y2bpjsw58wkh0"},{"name":"hexo","_id":"ck1uo5bp200112bpjie0g2jnk"},{"name":"probability","_id":"ck1uo5bp300162bpj0oznggbm"},{"name":"statistics","_id":"ck1uo5bp300172bpjp6aylg2f"},{"name":"clean code","_id":"ck1uo5bp300182bpjb10r4u94"},{"name":"Blog","_id":"ck1uo5bp4001e2bpjx2kuxrx4"},{"name":"js","_id":"ck1uo5bpi001k2bpjmij3bvbc"}]}}